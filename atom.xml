<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fancy&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fancy-blogs.com/"/>
  <updated>2018-09-04T06:15:37.852Z</updated>
  <id>http://fancy-blogs.com/</id>
  
  <author>
    <name>fancy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FileMonitorHook例子(translate)</title>
    <link href="http://fancy-blogs.com/2018/09/01/EasyHook/"/>
    <id>http://fancy-blogs.com/2018/09/01/EasyHook/</id>
    <published>2018-09-01T08:35:29.832Z</published>
    <updated>2018-09-04T06:15:37.852Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="EasyHook-FileMonitorHook"><a href="#EasyHook-FileMonitorHook" class="headerlink" title="EasyHook-FileMonitorHook"></a>EasyHook-FileMonitorHook</h1><h3 id="创建远程文件监视器"><a href="#创建远程文件监视器" class="headerlink" title="创建远程文件监视器"></a>创建远程文件监视器</h3><p>在本教程中，我们将使用EasyHook创建一个远程文件监视器。<br>我们将介绍如何：<br>根据进程ID将托管程序集注入现有目标进程,使用可执行文件路径将托管程序集注入新创建（并暂停）的进程<br>在远程进程中创建本地挂钩以监视3个文件操作（CreateFile，ReadFile和WriteFile）,使用.NET进程间通信（IPC）将报告文件访问回主控制台应用程序.</p><p>在本教程中，我们将创建一个包含两个项目的解决方案：<br>FileMonitor：一个C＃控制台应用程序;<br>FileMonitorHook：包含钩子逻辑和IPC接口的C＃类库。该组件是我们的注入payload。</p><h3 id="Remote-hooking-概述"><a href="#Remote-hooking-概述" class="headerlink" title="Remote hooking 概述"></a>Remote hooking 概述</h3><p>远程hook通常先用“injector”向目标进程注入一个payload，利用这个payload再安装我们的钩子。<br>由此，EasyHook库提供了“EasyHook.RemoteHooking”静态类和“EasyHook.IEntryPoint”接口。</p><ol><li>EasyHook.RemoteHooking.Inject:<br> 向指定的进程注入特定的32位/64位payload指令集，提供的参数将被传递给被注入的库。</li><li>EasyHook.RemoteHooking.CreateAndInject:<br> 从提供的可执行路径和命令行以挂起状态创建一个新进程，然后以“Inject”方式注入一个特定的32位/64位payload。</li><li>EasyHook.RemoteHooking.WakeUpProcess:<br> 与payload/注入库中的CreateAndInject结合使用，以在准备就绪时唤醒进程。</li><li>EasyHook.RemoteHooking.IpcCreateServer<t>:<br> 一个用来初始化injector和host的IPC通道的辅助方法。</t></li><li>EasyHook.RemoteHooking.IpcConnectClient<t>:<br> 一个用来在注入完成后将客户端连接至IPC通道的辅助方法。（被运行在目标进程中的注入的dll所调用）</t></li><li>EasyHook.IEntryPoint:<br> payload指令集必须包含一个public类来实现此接口。</li></ol><p>待完成注入后payload将使用EasyHook.LocalHook来创建钩子。</p><h3 id="EasyHook-RemoteHooking-Inject"><a href="#EasyHook-RemoteHooking-Inject" class="headerlink" title="EasyHook.RemoteHooking.Inject"></a>EasyHook.RemoteHooking.Inject</h3><ul><li>1.&emsp;EasyHook.RemoteHooking.Inject 序列化配置，包括payload集合的路径和参数。</li><li><p>2.&emsp;向指定的目标进程中注入原生EasyHook32.dll或EasyHook64.dll依赖于它本身是32位或64位。如果有必要的话，EasyHook将自动使用EasyHookSvc32/64.exe来帮助程序将32位注入到64位中或反过来。</p><p>  EasyHook.RemoteHooking.Inject 将会等待，直到它超时或者它已经发出注入已完成/失败的信号。</p></li></ul><p>– 此时已运行在目标进程中 –</p><ul><li><p>3.&emsp;EasyHook32/64.dll通过加载EasyLoad32/64.dll来完成“managed injection”<br>（EasyLoad尝试创建一个新的AppDomain，以便可以卸载注入库）<br>（EasyHook32/64.dll发出EasyHook.RemoteHooking.Inject注入完成的信号）</p></li><li><p>4.&emsp;EasyLoad将托管程序集EasyHook.dll加载到目标进程并调用EasyHook.InjectionLoader.Main方法。</p></li><li>5.&emsp;EasyHook.InjectionLoader反序列化配置，加载有效负载程序集并查找与提供给EasyHook.RemoteHooking.Inject调用的参数相匹配的EasyHook.IEntryPoint。</li><li>6.&emsp;如果找到，就会实例化payload集合中相匹配的EasyHook.IEntryPoint并最终调用对应的Run方法。</li><li>7.&emsp;Payload的Run方法安装若干钩子。</li></ul><p>&emsp;&emsp;&emsp;&emsp;最后当Run方法退出后，EasyLoad将会尝试卸载AppDomain</p><h3 id="EasyHook-RemoteHooking-CreateAndInject"><a href="#EasyHook-RemoteHooking-CreateAndInject" class="headerlink" title="EasyHook.RemoteHooking.CreateAndInject"></a>EasyHook.RemoteHooking.CreateAndInject</h3><ol><li>从提供的可执行路径和命令行以挂起状态创建一个新进程。</li><li>按照EasyHook.RemoteHooking.Inject的运行逻辑。</li><li>被创建的进程会保持被挂起的状态直到payload调用RemoteHooking.WakeUpProcess。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;EasyHook-FileMonitorHook&quot;&gt;&lt;a href=&quot;#EasyHook-FileMonitorHook&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>望</title>
    <link href="http://fancy-blogs.com/2018/08/03/play20180803/"/>
    <id>http://fancy-blogs.com/2018/08/03/play20180803/</id>
    <published>2018-08-03T06:16:31.975Z</published>
    <updated>2018-08-07T06:45:43.023Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>四周张望，空旷得慌张；看着远方，残云里惘惘。你的出现，拉近了我的焦点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;四周张望，空旷得慌张；看着远方，残云里惘惘。你的出现，拉近了我的焦点。&lt;/p&gt;

      
    
    </summary>
    
      <category term="play" scheme="http://fancy-blogs.com/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>远</title>
    <link href="http://fancy-blogs.com/2018/08/01/play201808012/"/>
    <id>http://fancy-blogs.com/2018/08/01/play201808012/</id>
    <published>2018-08-01T04:24:22.576Z</published>
    <updated>2018-08-02T04:18:50.434Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>遇了越来越多的人，说着越来越少的话，在越来越小的屋子里，等着越来越远的云。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;梦见越来越模糊的你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;遇了越来越多的人，说着越来越少的话，在越来越小的屋子里，等着越来越远的云。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
      <category term="play" scheme="http://fancy-blogs.com/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>意</title>
    <link href="http://fancy-blogs.com/2018/08/01/play20180801/"/>
    <id>http://fancy-blogs.com/2018/08/01/play20180801/</id>
    <published>2018-08-01T01:37:08.441Z</published>
    <updated>2018-08-01T04:38:14.467Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>蝉，吵得身临其境。雪，下得记忆犹新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;蝉，吵得身临其境。雪，下得记忆犹新。&lt;/p&gt;

      
    
    </summary>
    
      <category term="play" scheme="http://fancy-blogs.com/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>NDK gdb插件——peda-arm</title>
    <link href="http://fancy-blogs.com/2018/07/23/androidgdbplus/"/>
    <id>http://fancy-blogs.com/2018/07/23/androidgdbplus/</id>
    <published>2018-07-23T06:38:24.593Z</published>
    <updated>2018-08-21T06:18:05.057Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="NDK-gdb插件——peda-arm"><a href="#NDK-gdb插件——peda-arm" class="headerlink" title="NDK gdb插件——peda-arm"></a>NDK gdb插件——peda-arm</h1><p>gdb调试时配合插件可以提高效率，Linux下gdb调试可以使用peda、gef等。在android调试里，使用gdbserver配合gdb可以远程调试，那有没有对应的插件呢？<br>最近发现一款支持arm的插件，是peda改的，<a href="https://github.com/alset0326/peda-arm" target="_blank" rel="noopener">peda-arm</a>.</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><p>从github上拉下来后，直接把文件夹复制过去。<br>gdb的目录(MACOS)是：<br><code>/Users/username/Library/Android/sdk/ndk-bundle/prebuilt/darwin-x86_64/bin</code><br>反正在ndk的目录下。<br>把clone下来的文件夹复制进去。<br><img src="http://p1ju8xds4.bkt.clouddn.com/15323283415621.jpg" alt="w100"></p><p>修改初始化配置文件:<br><code>echo “source ./peda-arm/peda-arm.py” &gt;&gt; ./.gdbinit</code></p><h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p>把gdbserver上传到手机后：<br><code>gdbserver remote:port --attach targetpid</code></p><p>本地端口转发<br><code>adb forward tcp:port tcp:port</code></p><p>gdb调试<br><code>./gdb</code><br><code>target remote:port</code></p><p><img src="http://p1ju8xds4.bkt.clouddn.com//15323286476307.jpg" alt="w100"></p><p>这用就OK啦。</p><p>Debug for fun～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;NDK-gdb插件——peda-arm&quot;&gt;&lt;a href=&quot;#NDK-gdb插件——peda-arm&quot; class=&quot;headerlink&quot; title=&quot;NDK 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全技术竞赛决赛第一题writeup</title>
    <link href="http://fancy-blogs.com/2018/05/04/mtp2/"/>
    <id>http://fancy-blogs.com/2018/05/04/mtp2/</id>
    <published>2018-05-04T08:07:53.876Z</published>
    <updated>2018-05-14T10:55:52.872Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="腾讯游戏安全技术竞赛决赛第一题writeup"><a href="#腾讯游戏安全技术竞赛决赛第一题writeup" class="headerlink" title="腾讯游戏安全技术竞赛决赛第一题writeup"></a>腾讯游戏安全技术竞赛决赛第一题writeup</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目是用OpenGL ES 3.0编写的一个程序，用<code>textures/container.jpg</code>作为贴图，去渲染。目的是去寻找绘制出的flag，由于绘制区域限制，移动不到绘制区域。</p><h2 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h2><p>之前没有接触过openGL，相关函数一个个找，浏览了《opengl es 3.0 编程指南》。</p><p>贴图绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub_30604(v23);</span><br><span class="line">dword_AA108 = v23;</span><br><span class="line">_aeabi_memcpy8(&amp;v48, dword_A1AA0, 720);</span><br><span class="line">glGenVertexArrays(1, &amp;v38);</span><br><span class="line">glGenBuffers(1, &amp;v39);</span><br><span class="line">glBindVertexArray(v38);</span><br><span class="line">glBindBuffer(0x8892, v39);</span><br><span class="line">glBufferData(0x8892, 720, &amp;v48, 35044);</span><br><span class="line">glVertexAttribPointer(0, 3, 0x1406, 0, 20, 0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">glVertexAttribPointer(1, 2, 5126, 0, 20, 12);</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glGenTextures(1, &amp;textures);</span><br><span class="line">glBindTexture(0xDE1u, textures);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2802u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2803u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2801u, 9729);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2800u, 9729);</span><br><span class="line">pixels = (const GLvoid *)sub_31578(v42, v43, &amp;v35, &amp;v34, &amp;v33, 0);</span><br><span class="line">      if ( pixels )</span><br><span class="line">      &#123;</span><br><span class="line">        glTexImage2D(0xDE1u, 0, 6407, *(GLsizei *)&amp;v35, v34, 0, 0x1907u, 0x1401u, pixels);</span><br><span class="line">        glGenerateMipmap(3553);</span><br><span class="line">      &#125;</span><br><span class="line">      j_j_free(pixels);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>将<code>textures/container.jpg</code>作为贴图纹理，<code>dword_A1AA0</code>为顶点数组（36个坐标），得到的结果就是一个立方体（以三角形为单位渲染，6<em> 2 </em>3=36）。</p><p>在程序中看到一个箭头上布满了箱子，就是以图片纹理渲染出的箱子来布满箭头。</p><p>找到的资料都是单个图像渲染，没找到怎么设置贴图目标。</p><p>找屏幕显示的地方，sub_30098里看到屏幕清除的函数，下面是一大堆浮点运算。该不会是逆浮点运算过程吧？？<br>找了一下数据来源：<code>dword_AA0FC</code><br>在so的init里找到了函数，里面是对着色器代码的复制，还有就是<code>dword_AA0FC</code>的赋值，数据来源就是<code>dword_9E8D8</code>。一堆数据，分析之后是浮点数，联系之前顶点坐标也是浮点数组，那么这也是个坐标数组。</p><p>一番搜索，glDrawElements和glDrawArrays是绘制函数，在绘制前，调用<code>glUniformMatrix4fv</code>,通过uniform上传至GPU,来绘制最终的图像。调试中发现传入的指针指向的是空数组。不清楚为什么。从代码来看就是将，dword_AA0FC传入的数据，每个循环处理x和y坐标。刚刚那个座标是一个三维坐标。</p><p>没仔细研究一大段的浮点运算具体是干什么的，猜测是三维到二维的映射计算。</p><p>把dword_9E8D8数据抠出来。用matplotlib绘制出来。哇！惊喜，这个坐标数组就是绘制图像的坐标数组。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15254223943601.jpg" alt=""></p><p>由于旧的题里出现了flag的图片，还是给了不少启示的，所以这题做的还是有点侥幸的。</p><h2 id="OpenGL相关"><a href="#OpenGL相关" class="headerlink" title="OpenGL相关"></a>OpenGL相关</h2><p>有关OpenGL的知识，需要了解一下几个概念。<br>这个系列文章写的不错：<a href="http://www.cnblogs.com/lijihong/p/5365677.html" target="_blank" rel="noopener">http://www.cnblogs.com/lijihong/p/5365677.html</a></p><h3 id="vertex-顶点"><a href="#vertex-顶点" class="headerlink" title="vertex(顶点)"></a>vertex(顶点)</h3><p>在设置贴图映射和绘制对象时会用到顶点。</p><p>例如在贴图映射中，会指定贴图所需要映射方式的一个顶点数组。如下是一个浮点数组。<br><img src="http://p1ju8xds4.bkt.clouddn.com/15262860614297.jpg" alt=""></p><h3 id="VBO-顶点缓冲对象"><a href="#VBO-顶点缓冲对象" class="headerlink" title="VBO(顶点缓冲对象)"></a>VBO(顶点缓冲对象)</h3><p>顶点缓冲对象VBO是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，不需要从CPU传输数据，处理效率更高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void CreateVertexBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建含有一个顶点的顶点数组</span><br><span class="line">    Vector3f Vertices[1];</span><br><span class="line">    // 将点置于屏幕中央</span><br><span class="line">    Vertices[0] = Vector3f(0.0f, 0.0f, 0.0f);</span><br><span class="line"></span><br><span class="line">    // 创建缓冲器</span><br><span class="line">    glGenBuffers(1, &amp;VBO);</span><br><span class="line">    // 绑定GL_ARRAY_BUFFER缓冲器</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    // 绑定顶点数据</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shader-着色器"><a href="#Shader-着色器" class="headerlink" title="Shader(着色器)"></a>Shader(着色器)</h3><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>在so中的init区段初始化了着色器代码。<br><img src="http://p1ju8xds4.bkt.clouddn.com/15262922120545.jpg" alt="0-w500"></p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15262922381037.jpg" alt="1-w500"></p><p><code>sub_30604(v23);</code>函数中完成了对着色器的创建和编译绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLuint ShaderProgram = glCreateProgram(); </span><br><span class="line">GLuint ShaderObj = glCreateShader(ShaderType); </span><br><span class="line">glShaderSource(ShaderObj, 1, p, Lengths); </span><br><span class="line">glCompileShader(ShaderObj); </span><br><span class="line">glAttachShader(ShaderProgram, ShaderObj); </span><br><span class="line">glUseProgram(ShaderProgram);</span><br></pre></td></tr></table></figure><p>详细解释参考：<a href="https://blog.csdn.net/cordova/article/details/52495077" target="_blank" rel="noopener">https://blog.csdn.net/cordova/article/details/52495077</a></p><p>图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。<br><img src="https://pic4.zhimg.com/80/v2-1e286dd517c717e3f1c48792275f7e87_hd.jpg" alt=""><br>摘自：<a href="https://www.zhihu.com/question/29163054" target="_blank" rel="noopener">https://www.zhihu.com/question/29163054</a></p><h3 id="贴图纹理"><a href="#贴图纹理" class="headerlink" title="贴图纹理"></a>贴图纹理</h3><p>为了实现纹理贴图我们需要做三件事：<br>将一张贴图加载到OpenGL中<br>提供纹理坐标和顶点（将纹理对应匹配到顶点上）<br>并使用纹理坐标从纹理中进行取样操作取得像素颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sub_2F79C(*(_DWORD *)(*(_DWORD *)(v10 + 12) + 32), &quot;textures/container.jpg&quot;, &amp;v42);</span><br><span class="line">...</span><br><span class="line">sub_30604(v23);</span><br><span class="line">dword_AA108 = v23;</span><br><span class="line">_aeabi_memcpy8(&amp;v48, dword_A1AA0, 720);</span><br><span class="line">glGenVertexArrays(1, &amp;v38);</span><br><span class="line">glGenBuffers(1, &amp;v39);</span><br><span class="line">glBindVertexArray(v38);</span><br><span class="line">glBindBuffer(0x8892, v39);</span><br><span class="line">glBufferData(0x8892, 720, &amp;v48, 35044);</span><br><span class="line">glVertexAttribPointer(0, 3, 0x1406, 0, 20, 0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">glVertexAttribPointer(1, 2, 5126, 0, 20, 12);</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glGenTextures(1, &amp;textures);</span><br><span class="line">glBindTexture(0xDE1u, textures);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2802u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2803u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2801u, 9729);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2800u, 9729);</span><br><span class="line">pixels = (const GLvoid *)sub_31578(v42, v43, &amp;v35, &amp;v34, &amp;v33, 0);</span><br><span class="line">      if ( pixels )</span><br><span class="line">      &#123;</span><br><span class="line">        glTexImage2D(0xDE1u, 0, 6407, *(GLsizei *)&amp;v35, v34, 0, 0x1907u, 0x1401u, pixels);</span><br><span class="line">        glGenerateMipmap(3553);</span><br><span class="line">      &#125;</span><br><span class="line">      j_j_free(pixels);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>将<code>textures/container.jpg</code>作为贴图纹理，<code>dword_A1AA0</code>为顶点数组（顶点数组是<strong>顶点</strong>中的截图），得到的结果就是一个立方体（以三角形为单位渲染，6<em> 2 </em>3=36）。</p><p>函数详解参考：<a href="https://blog.csdn.net/cordova/article/details/52825859" target="_blank" rel="noopener">https://blog.csdn.net/cordova/article/details/52825859</a></p><h3 id="帧缓冲区"><a href="#帧缓冲区" class="headerlink" title="帧缓冲区"></a>帧缓冲区</h3><h3 id="glUniform函数"><a href="#glUniform函数" class="headerlink" title="glUniform函数"></a>glUniform函数</h3><p>uniform修饰符可以指定一个在应用中设置好的变量，它不会在图元处理的过程中发生变化，且在所有的着色阶段之间都是共享的——着色器中的全局变量。</p><p>详细参考：<a href="https://www.cnblogs.com/android-blogs/p/5454692.html" target="_blank" rel="noopener">https://www.cnblogs.com/android-blogs/p/5454692.html</a></p><p><code>sub_30098(int a1)</code>函数中对顶点的x、y坐标处理后会调用到<code>sub_30EEC(int *a1, int a2, int a3)</code>,这个函数里就包含了<code>glGetUniformLocation(v5, v4);</code>和<code>j_glUniformMatrix4fv(v6, 1, 0, v3);</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;腾讯游戏安全技术竞赛决赛第一题writeup&quot;&gt;&lt;a href=&quot;#腾讯游戏安全技术竞赛决赛第一题writeup&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全技术移动平台资格题writeup</title>
    <link href="http://fancy-blogs.com/2018/04/23/mtp-mobile-1/"/>
    <id>http://fancy-blogs.com/2018/04/23/mtp-mobile-1/</id>
    <published>2018-04-22T17:36:08.650Z</published>
    <updated>2018-05-06T07:23:33.248Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="腾讯游戏安全技术移动平台资格题writeup"><a href="#腾讯游戏安全技术移动平台资格题writeup" class="headerlink" title="腾讯游戏安全技术移动平台资格题writeup"></a>腾讯游戏安全技术移动平台资格题writeup</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目要求输入key和code，匹配则会显示“success！”，否则显示“fail！”。<br>有standard和advance两个版本，advance比standard多一个函数，这里时间原因只做到了standard版本，最近每周都有ctf。</p><h3 id="key相关"><a href="#key相关" class="headerlink" title="key相关"></a>key相关</h3><blockquote><p>key只能是数字，字母a(A)～f(F)，如果是小写，会被转为大写。<br>将keystr以”#”间隔，拆分，放入vector<br>sub_4864将keystr 拆分为8块，校验每块长度不为0<br>最后会对每块取值运算，要求每块4字节，所以结构是<code>****#****#****#****#****#****#****#****</code></p></blockquote><p>sub_496C函数传入keystr，生成5个int64，用于后面校验。</p><p>生成规则脚本里有，不作详解。大概就是每次运算取vector中两个项中各一字节，参与指定运算。前两个还算有规律，后面就没什么规律了。关于这里的代码，似乎是经过混淆，循环被平坦化了。</p><p>脚本是python的，所以对数据的类型处理不是很好，可能存在bug。好尴尬。</p><h3 id="code相关"><a href="#code相关" class="headerlink" title="code相关"></a>code相关</h3><blockquote><p>输入长度需要是偶数<br>长度需要是44（由生成数据的长度决定）<br>最后12字符确定()（由生产数据的最后9字节决定）<br>最后以”=”结束</p></blockquote><p>sub_7114函数传入codestr，生成一个vector，用于后面校验。</p><p>每4字节生成3字节数据，根据字节在已知字符串<code>&quot;ZO6Kq79L&amp;CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#=&quot;</code>中的位置来确定数。</p><blockquote><p>block[0]~block[1]-&gt;result[0]<br>block[1]~block[2]-&gt;result[1]<br>block[2]~block[3]-&gt;result[2]</p></blockquote><p>最后生成44/4*3=33字节数据</p><blockquote><p>v11[3] != 0x32303138</p></blockquote><p>决定生成的数据最后8字节，值为(int64)0x0000000032303138<br>由生成规则爆破（爆破代码在脚本注释中）得到“pKqE”、“NeZZ”、“ZZZ”。</p><p>所以code最后12字节为“pKqENeZZZZZ=”</p><h3 id="验证函数"><a href="#验证函数" class="headerlink" title="验证函数"></a>验证函数</h3><p>sub_5658传入key生成的5个int64数和code生成的前24字节数据。</p><p>参数作为8个int64参与运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( ((a6 * a1 + a2) * a6 + a3) ^ a7 )        // ((S[0]*v18+v17)*S[0]+v16)==S[1]</span><br><span class="line">    return 0;</span><br><span class="line">  v8 = 0;</span><br><span class="line">  if ( (a2 - a4) * (a2 - a4) == 4 * a1 * (a6 * a4 + a3 - a7) &amp;&amp; a8 == a3 + (a5 * a1 + a2 - a4) * a5 )</span><br><span class="line">    v8 = 1;                                     // (v17-v15)*(v17-v15)==4*v18*(S[0]*v15+v14-S[1])</span><br><span class="line">                                                // S[2]==v16+(v14*v18+v17-v15)*v14</span><br></pre></td></tr></table></figure><p>将code生成的数据当作未知数，整理数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=(4*CH18*CH18)</span><br><span class="line">b=(4*CH18*(CH17-CH15))</span><br><span class="line">c=((CH17-CH15)*(CH17-CH15))</span><br><span class="line"></span><br><span class="line">#b**2==4*a*c</span><br><span class="line">#4*CH18*(CH17-CH15)*4*CH18*(CH17-CH15)==4*4*CH18*CH18*(CH17-CH15)*(CH17-CH15)</span><br></pre></td></tr></table></figure><p>可整理为一个二元一次方程。且delta=0，所以有唯一解。</p><h2 id="注册机编写思路"><a href="#注册机编写思路" class="headerlink" title="注册机编写思路"></a>注册机编写思路</h2><p>要求由输入key来计算code，key可以生成5个int64，通过还原程序的计算过程，将5个数计算出来。此时验证函数中，把code的数据当作未知数，已有系数，由整理得到的方程解出S[0],再计算得出S[1],S[2]。</p><blockquote><p>S[0]，S[1]，S[2]分别数code生成的前24字节组成的3个int64</p></blockquote><p>得到code生成的数据后，反推code输入，已经知道了code的生成规则，和之前得到code的最后12个字节一样，爆破处理，每4字节生成3字节数据，那么就3字节3字节处理。</p><p>每3字节得到4字节输入，24/3*4=32，加上已知的12字节，32+12=44，正好输入44字节。</p><h3 id="注册机使用"><a href="#注册机使用" class="headerlink" title="注册机使用"></a>注册机使用</h3><p>脚本测试环境：Python 2.7.14<br>MYKEY设置成key，注意格式。<br>运行脚本即可，最后输出的结果即是code.</p><p>几组跑出来的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ab1D#2BCE#A41B#EA2A#B3CD#8A0A#AB31#0FF0</span><br><span class="line">dn57ZfZZZZK^wxgp$FhxiamNJlIRtD20pKqENeZZZZZ=</span><br><span class="line"></span><br><span class="line">1b1D#2BCE#141B#EA2A#13CD#8A0A#1B31#0FF0</span><br><span class="line">ynoJZZZZZZK^wFr#*kEHd#uT&amp;3YdEUsBpKqENeZZZZZ=</span><br><span class="line"></span><br><span class="line">AAAA#bbbb#1111#cccc#defa#3333#4317#98f1</span><br><span class="line">OEH46EZZZZZwJYDWiCe*v0Fd@Gqo5zR9pKqENeZZZZZ=</span><br></pre></td></tr></table></figure><p>截图：<br><img src="http://p1ju8xds4.bkt.clouddn.com/success.jpg" alt="success-w400"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;腾讯游戏安全技术移动平台资格题writeup&quot;&gt;&lt;a href=&quot;#腾讯游戏安全技术移动平台资格题writeup&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GOT表hook</title>
    <link href="http://fancy-blogs.com/2018/04/08/GOTHOOK/"/>
    <id>http://fancy-blogs.com/2018/04/08/GOTHOOK/</id>
    <published>2018-04-08T15:51:17.108Z</published>
    <updated>2018-04-09T16:57:28.151Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="GOT表hook"><a href="#GOT表hook" class="headerlink" title="GOT表hook"></a>GOT表hook</h1><p>&emsp;&emsp;ELF文件中，GOT表和PLT表，不同映像间的函数和数据引用都是通过它们实现的。GOT（全局偏移表）给出了映像中所有被引用符号（函数或变量）的值。每个普通PLT表项相当于一个函数的桩函数（stub），支持懒绑定的情况下，当发生对外部函数的调用时，程序会通过PLT表将控制交给动态连接器，后者解析出函数的绝对地址，修改GOT中相应的值，之后的调用将不再需要连接器的绑定。由于linker是不支持懒绑定的，所以在进程初始化时，动态链接器首先解析出外部过程引用的绝对地址，一次性的修改所有相应的GOT表项。对共享对象来说，由于GOT，PLT节以及代码段和数据段之间的相对位置是固定的，所有引用都是基于一个固定地址（GOT）的偏移量，所以实现了PIC代码，重定位时只需要修改可写段中的GOT表。而可执行程序在连接过程中则可能发生对不可写段的修改。如果只读段和可写段不是以固定的相对位置加载的，那么在重定位是还需要修改所有指向GOT的指针。</p><h2 id="本地hook"><a href="#本地hook" class="headerlink" title="本地hook"></a>本地hook</h2><h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p>&emsp;&emsp;我们需要了解一下ELF文件的结构，因为我们得到GOT表地址是通过ELF文件格式中的字段来一步步索引的。<br>&emsp;&emsp;索引过程为：从ELFHeader里找到字符串表，因为要找节表是通过名称来搜索的，所以首先要字符串表的地址。<br><strong>ELFHeader</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_hdr &#123;</span><br><span class="line">  unsigned char e_ident[EI_NIDENT];</span><br><span class="line">  Elf32_Half e_type;</span><br><span class="line">  Elf32_Half e_machine;</span><br><span class="line">  Elf32_Word e_version;</span><br><span class="line">  Elf32_Addr e_entry;</span><br><span class="line">  Elf32_Off e_phoff;</span><br><span class="line">  Elf32_Off e_shoff;</span><br><span class="line">  Elf32_Word e_flags;</span><br><span class="line">  Elf32_Half e_ehsize;</span><br><span class="line">  Elf32_Half e_phentsize;</span><br><span class="line">  Elf32_Half e_phnum;</span><br><span class="line">  Elf32_Half e_shentsize;</span><br><span class="line">  Elf32_Half e_shnum;</span><br><span class="line">  Elf32_Half e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>Elf32_Ehdr.e_shoff:节区头表偏移<br>Elf32_Ehdr.e_shstrndx:字符串表在节区头表中的索引<br>Elf32_Ehdr.e_shentsize:每个节区头大小</p><p>字符串表偏移：Elf32_Ehdr.e_shoff+Elf32_Ehdr.e_shstrndx*Elf32_Ehdr.e_shentsize</p><p>节区头表名称来源有里之后，就可以遍历节区头表了。</p><p>节区头表偏移：Elf32_Ehdr.e_shoff</p><p><strong>ELFSectionHeader</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_shdr &#123;</span><br><span class="line">  Elf32_Word sh_name;</span><br><span class="line">  Elf32_Word sh_type;</span><br><span class="line">  Elf32_Word sh_flags;</span><br><span class="line">  Elf32_Addr sh_addr;</span><br><span class="line">  Elf32_Off sh_offset;</span><br><span class="line">  Elf32_Word sh_size;</span><br><span class="line">  Elf32_Word sh_link;</span><br><span class="line">  Elf32_Word sh_info;</span><br><span class="line">  Elf32_Word sh_addralign;</span><br><span class="line">  Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>sh_name:节区名称在字符串表中的偏移<br>sh_type:节区类型</p><p>通过判断类型值和节区名称来确定GOT表节区</p><p>最后获取到模块加载地址后作为基址，加上偏移即是GOT表地址，GOT表就是一个地址表，通过遍历挨个地址匹配，找到后修改即可，注意修改内存页权限。（不知道为什么GOT在内存中是没有可写权限的）<br><img src="http://p1ju8xds4.bkt.clouddn.com/15232059915351.jpg" alt=""><br>在地址0xb6f2af54处</p><p>代码地址：<a href="https://github.com/Minxin/gothooklocal" target="_blank" rel="noopener">https://github.com/Minxin/gothooklocal</a></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>&emsp;&emsp;在测试中发现一些问题，程序在调用函数时，特别在多次调用时，会将函数指针存放在寄存器中，供下一次调用使用，这个时候无论修改何处，寄存器中的值是不变的，每次调用形式为：<code>BLX  R4</code>.所以这样hook是没有任何效果的。<br>&emsp;&emsp;写在其他函数中，调用就会正常，间接跳转的形式，GOT修改后生效。<br><img src="http://p1ju8xds4.bkt.clouddn.com/15232067018523.jpg" alt="result-w500"></p><p>可以看到GOT修改之后，<code>just 2</code>和<code>just 3</code>是通过寄存器跳转的，没有效果；<code>for test</code>是通过间接跳转的，生效。</p><h2 id="远程hook"><a href="#远程hook" class="headerlink" title="远程hook"></a>远程hook</h2><p>相比较的话，多了一步注入操作。 </p><p>注入程序参照：<a href="https://blog.csdn.net/qq1084283172/article/details/46859931" target="_blank" rel="noopener">https://blog.csdn.net/qq1084283172/article/details/46859931</a><br><strong>注入流程：</strong><br><img src="http://gslab.qq.com/data/attachment/portal/201604/27/153304u2qgl1wax4ntlrzs.png" alt="injectflow-c"></p><h3 id="注入方案："><a href="#注入方案：" class="headerlink" title="注入方案："></a>注入方案：</h3><p>我们将上面实现的本地hook代码编译成动态库，把这个库注入到目标进程，然后调用hook函数，那么需要目标程序调用dlopen函数来装载库，调用dlsym来获取到hook函数地址，最后调用。并且这些函数需要的参数我们也需要写入目标进程的地址空间中，所以还需要mmap来开出一块地址空间开写入参数数据。</p><p>获取函数地址，我们计算一下偏移即可：<br><code>remote_func_addr=local_func_addr+(remote_base-local_base)</code></p><p>获取本模块内存基址和目标模块的内存基址，差值即为某函数在本地地址和目标地址的偏移。</p><h3 id="基址获取："><a href="#基址获取：" class="headerlink" title="基址获取："></a>基址获取：</h3><p>在<code>/proc/[pid]/maps</code> 中查找模块名，对应行的起始地址就是模块的基址。</p><h3 id="开辟空间："><a href="#开辟空间：" class="headerlink" title="开辟空间："></a>开辟空间：</h3><p>调用mmap得到一块地址空间，mmap函数定义<br><code>void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</code><br>调用前需要构造参数。</p><h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><p>arm中参数存放在r0～r3及栈中，超出四个参数，就需要用栈存放。</p><p>利用ptrace设置布置好的参数列表，跳转到函数的话，直接设置pc值即可。</p><p>mmap调用后需要获得返回值，返回值是开辟出的地址空间的地址，返回值是存放在r0中的，PTRACE_GETREGS获取寄存器，取出r0即可。</p><h3 id="装载hook库："><a href="#装载hook库：" class="headerlink" title="装载hook库："></a>装载hook库：</h3><p>调用dlopen将指定的库装载进目标进程中<br><code>void * dlopen( const char * pathname, int mode);</code></p><p>这里由于参数是指针，是一个地址，进程中没有需要的字符串，所以需要将字符串写入目标进程中，之前mmap申请的空间派上用场了，使用PTRACE_POKETEXT/PTRACE_POKEDATA写入指定地址即可，注意字节数量。</p><p>dlopen调用后返回装载的库的句柄，也需要获取。</p><h3 id="获取函数地址："><a href="#获取函数地址：" class="headerlink" title="获取函数地址："></a>获取函数地址：</h3><p>调用dlsym获得hook函数的地址<br><code>void* dlsym(void* handle,const char* symbol)</code><br>这里的符号参数也需要写入目标内存中，用ida打开so，可以看它的导出符号。</p><p>dlsym的返回值就是hook函数的地址，也需要获取。</p><p>最后再调用hook函数即可。</p><p>其实hook函数的获取可以使用计算偏移的方式，注入程序自己也装载动态库，获取hook函数地址后，加上基址差值，也可以得到hook函数在目标进程中的地址。可以不用让目标程序调用dlsym。</p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>注入程序：<br><img src="http://p1ju8xds4.bkt.clouddn.com/15232917260881.jpg" alt="inject-w500"></p><p>被注入程序：<br><img src="http://p1ju8xds4.bkt.clouddn.com/15232917491072.jpg" alt="tobehook-w500"></p><p>被注入程序首先在被hook前调用puts，进入sleep，启动注入进程，完成注入和hook后，输出的信息和之前本地hook的输出差不多，最后继续执行，再次调用puts时，已经被myputs代替，输入信息前有前缀”FAKE:”。</p><p>代码地址：<a href="https://github.com/Minxin/gothookremote" target="_blank" rel="noopener">https://github.com/Minxin/gothookremote</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;GOT表hook&quot;&gt;&lt;a href=&quot;#GOT表hook&quot; class=&quot;headerlink&quot; title=&quot;GOT表hook&quot;&gt;&lt;/a&gt;GOT表hook&lt;/h1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android虚拟机（二）</title>
    <link href="http://fancy-blogs.com/2018/04/03/androidVM2/"/>
    <id>http://fancy-blogs.com/2018/04/03/androidVM2/</id>
    <published>2018-04-03T09:31:07.171Z</published>
    <updated>2018-04-04T18:21:04.759Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="android虚拟机（二）"><a href="#android虚拟机（二）" class="headerlink" title="android虚拟机（二）"></a>android虚拟机（二）</h1><h2 id="ART虚拟机加载流程"><a href="#ART虚拟机加载流程" class="headerlink" title="ART虚拟机加载流程"></a>ART虚拟机加载流程</h2><p>summary up <a href="https://blog.csdn.net/luoshengyang/article/details/39533503" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/39533503</a></p><p>需要先了解：<br><a href="https://blog.csdn.net/lusing/article/details/52453246" target="_blank" rel="noopener">ART中几个组件</a><br><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">java中的ClassLoader</a></p><p>&emsp;&emsp;AndroidRuntime类会对mJavaVM和JNIEnv进行创建，利用JNI接口，就可以获取到mJavaVM的入口类，并通过这个入口进入虚拟机内部，开始运行。<br>&emsp;&emsp;这个入口类是com.android.internal.os.ZygoteInit，通过JNI提供的FindClass和GetStaticMethodID函数就能获取到入口类的静态成员函数main，在由JNI提供的CallStaticVoidMethod就可以调用获取到的main函数，进入虚拟机内部。</p><p>JNI类的静态成员函数FindClass：</p><p>ClassLoader<br><code>Handle&lt;mirror::ClassLoader&gt;class_loader(hs.NewHandle(GetClassLoader(soa)));</code></p><p>need to get the instance of Runtime from the current Thread，then we can get the ClassLinker by Runtime-&gt;getClassLinker.</p><p>ClassLinker<br>1⃣️-&gt;FindClass<br>2⃣️-&gt;FindSystemClass</p><h3 id="FindClass："><a href="#FindClass：" class="headerlink" title="FindClass："></a><strong>FindClass：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class_loader.Get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// The boot class loader, search the boot class path.</span></span><br><span class="line">    ClassPathEntry pair = FindInClassPath(descriptor, boot_class_path_);</span><br><span class="line">   <span class="keyword">if</span> (pair.second != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> DefineClass(descriptor, NullHandle&lt;mirror::ClassLoader&gt;(), *pair.first, *pair.second);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><ol><li>如果要找的类是基础类型，则直接调用FindPrimitiveClass查找基础类型；如果不是则在传入的ClassLoader的已加载类表中查找类(首先会判断ClassLaoder是否为null，如果为null,就在boot_class<em>table</em>中查找，否则就在ClassLoader自己的ClassTable中查找)，如果找到，确保类已经被解析并返回</li><li>如果在传入的ClassLoader的已加载类表中没有找到类,则首先判断ClassLoader是否为空，如果为空，在boot_class<em>path</em>（系统启动类路径）中查找，如果不为空，则调用FindClassInPathClassLoader在传入的ClassLoader以及它的各级parent中查找类</li><li>如果仍然没有找到，则调用传入的ClassLoader的loadClass在传入的ClassLoader中查找，找到返回，否则抛出异常</li></ol><p>copy from <a href="https://www.jianshu.com/p/29b580e452a1" target="_blank" rel="noopener">here</a></p><h3 id="DefineClass："><a href="#DefineClass：" class="headerlink" title="DefineClass："></a><strong>DefineClass：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mirror::Class* ClassLinker::DefineClass(const char* descriptor,</span><br><span class="line">                                       Handle&lt;mirror::ClassLoader&gt; class_loader,</span><br><span class="line">                                       const DexFile&amp; dex_file,</span><br><span class="line">                                       const DexFile::ClassDef&amp; dex_class_def)&#123;</span><br><span class="line">                                       ...</span><br></pre></td></tr></table></figure><ol><li>ClassLinker是否已经初始化完成（在初始化时会创建一些内部类）</li><li>未初始化完成时，loadClass内部类或为类allocclass分配空间再loadClass</li><li>LoadClass从dex中加载类，并通过InsertClass添加到已加载类列表中（在其他线程同时在加载该类时，通过EnsureResolved确保同步）</li><li>LinkClass来对加载后的类进行解析，类解析完后得到一个Class对象</li></ol><h3 id="LoadClass："><a href="#LoadClass：" class="headerlink" title="LoadClass："></a><strong>LoadClass：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ClassLinker::LoadClass(const DexFile&amp; dex_file,  </span><br><span class="line">                            const DexFile::ClassDef&amp; dex_class_def,  </span><br><span class="line">                            SirtRef&lt;mirror::Class&gt;&amp; klass,  </span><br><span class="line">                            mirror::ClassLoader* class_loader) &#123;</span><br><span class="line">                            ...</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">dex_file</td><td style="text-align:left">类型为DexFile，描述要加载的类所在的DEX文件</td></tr><tr><td style="text-align:left">dex_class_def</td><td style="text-align:left">类型为ClassDef，描述要加载的类在DEX文件里面的信息</td></tr><tr><td style="text-align:left">klass</td><td style="text-align:left">类型为Class，描述加载完成的类</td></tr><tr><td style="text-align:left">class_loader</td><td style="text-align:left">类型为ClassLoader，描述所使用的类加载器</td></tr></tbody></table><ol><li><p>将参数class_loader描述的ClassLoader设置到klass描述的Class对象中去，即给每一个已加载类关联一个类加载器。</p></li><li><p>通过DexFile类的成员函数GetIndexForClassDef获得正在加载的类在DEX文件中的类索引号，并且设置到klass描述的Class对象中去。这个类索引号是一个很重要的信息，因为我们需要通过类索引号在相应的OAT文件找到一个OatClass结构体。有了这个OatClass结构体之后，我们才可以找到类方法对应的本地机器指令。</p></li><li><p>从参数dex_file描述的DEX文件中获得正在加载的类的静态成员变量和实例成员变量个数，并且为每一个静态成员变量和实例成员变量都分配一个ArtField对象，接着通过ClassLinker类的成员函数LoadField对这些ArtField对象进行初始化。初始好得到的ArtField对象全部保存在klass描述的Class对象中。</p></li><li><p>调用ClassLinker类的成员函数GetOatClass，从相应的OAT文件中找到与正在加载的类对应的一个OatClass结构体oat_class。这需要利用到上面提到的DEX类索引号，这是因为DEX类和OAT类根据索引号存在一一对应关系。</p></li><li><p>从参数dex_file描述的DEX文件中获得正在加载的类的直接成员函数和虚拟成员函数个数，并且为每一个直接成员函数和虚拟成员函数都分配一个ArtMethod对象，接着通过ClassLinker类的成员函数LoadMethod对这些ArtMethod对象进行初始化。初始好得到的ArtMethod对象全部保存在klass描述的Class对象中。</p></li><li><p>每一个直接成员函数和虚拟成员函数都对应有一个函数索引号。根据这个函数索引号可以在第4步得到的OatClass结构体中找到对应的本地机器指令。所有与这些成员函数关联的本地机器指令信息通过全局函数LinkCode设置到klass描述的Class对象中。</p></li></ol><h3 id="LinkCode"><a href="#LinkCode" class="headerlink" title="LinkCode:"></a><strong>LinkCode:</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void LinkCode(SirtRef&lt;mirror::ArtMethod&gt;&amp; method, const OatFile::OatClass* oat_class,  </span><br><span class="line">                     uint32_t method_index)  </span><br><span class="line">    SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">method</td><td style="text-align:left">要设置本地机器指令的类方法</td></tr><tr><td style="text-align:left">oat_class</td><td style="text-align:left">类方法method在OAT文件中对应的OatClass结构体</td></tr><tr><td style="text-align:left">method_index</td><td style="text-align:left">类方法method的索引号</td><td>。</td></tr></tbody></table><p>在OatClass中，用method就能索引到method的本地指令地址，调用LinkMethod就能将method解析为ArtMethod。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void OatFile::OatMethod::LinkMethod(mirror::ArtMethod* method) const &#123;  </span><br><span class="line">  CHECK(method != NULL);  </span><br><span class="line">  method-&gt;SetEntryPointFromCompiledCode(GetCode());  </span><br><span class="line">  method-&gt;SetFrameSizeInBytes(frame_size_in_bytes_);  </span><br><span class="line">  method-&gt;SetCoreSpillMask(core_spill_mask_);  </span><br><span class="line">  method-&gt;SetFpSpillMask(fp_spill_mask_);  </span><br><span class="line">  method-&gt;SetMappingTable(GetMappingTable());  </span><br><span class="line">  method-&gt;SetVmapTable(GetVmapTable());  </span><br><span class="line">  method-&gt;SetNativeGcMap(GetNativeGcMap());  // Used by native methods in work around JNI mode.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过OatMethod::GetCode获得OatMethod结构体中的code<em>offset</em>字段（指向的是一个本地机器指令函数，这个本地机器指令函数正是通过翻译该方法的DEX字节码得到的），并且通过调用ArtMethod类的成员函数SetEntryPointFromCompiledCode设置到参数method描述的ArtMethod对象中去。</p><p>类方法可以通过本地指令执行，也可以通过解释器执行<br>NeedsInterpreter检查该类方法是否需要解释器<br>enter_interpreter?true or false</p><p><strong>设置入口点：</strong></p><p>需要解释器的非native方法：artInterpreterToInterpreterBridge设置为解释器执行该类方法的入口点<br>不需要解释器的方法或native方法：artInterpreterToCompiledCodeBridge设置为解释器执行该类方法的入口点（伪入口，间接调用本地指令）<br>抽象方法 ： GetCompiledCodeToInterpreterBridge-&gt;Interpreter</p><p><strong>调整入口点：</strong></p><p>静态类构造方法：Trampoline-&gt;wait class initializing-&gt;native code </p><blockquote><p>ClassLinker::FixupStaticTrampolines install the Trampoline</p></blockquote><p>需要通过解释器执行的方法：</p><ol><li>没有对应的本地机器指令，即参数code的值等于NULL。</li><li>ART虚拟机运行在解释模式中，并且类方法不是JNI方法，并且也不是代理方法</li></ol><p>解释器入口都设置为：GetCompiledCodeToInterpreterBridge（to get a unified enterpoint）</p><p>注册native方法</p><blockquote><p>ArtMethod类的成员函数UnregisterNative实际上就是将一个JNI方法的初始化入口设置为通过调用函数GetJniDlsymLookupStub获得的一个Stub。这个Stub的作用是，当一个JNI方法被调用时，如果还没有显示地注册有Native函数，那么它就会自动从已加载的SO文件查找是否存在一个对应的Native函数。如果存在的话，就将它注册为JNI方法的Native函数，并且执行它。这就是隐式的JNI方法注册。</p></blockquote><p>UpdateMethodsCode更新方法入口，是否设置监控函数</p><h3 id="GetStaticMethodID："><a href="#GetStaticMethodID：" class="headerlink" title="GetStaticMethodID："></a><strong>GetStaticMethodID：</strong></h3><blockquote><ol><li><p>将参数jni_class的值转换为一个Class指针c，因此就可以得到一个Class对象，并且通过ClassLinker类的成员函数EnsureInitialized确保该Class对象描述的类已经初始化。</p></li><li><p>Class对象c描述的类在加载的过程中，经过解析已经关联上一系列的成员函数。这些成员函数可以分为两类：Direct和Virtual。Direct类的成员函数包括所有的静态成员函数、私有成员函数和构造函数，而Virtual则包括所有的虚成员函数。因此：<br>2.1. 当参数is_static的值等于true时，那么就表示要查找的是静态成员函数，这时候就在Class对象c描述的类的关联的Direct成员函数列表中查找参数name和sig对应的成员函数。这是通过调用Class类的成员函数FindDirectMethod来实现的。<br>2.2. 当参数is_static的值不等于true时，那么就表示要查找的是虚拟成员函数或者非静态的Direct成员函数，这时候先在Class对象c描述的类的关联的Virtual成员函数列表中查找参数name和sig对应的成员函数。这是通过调用Class类的成员函数FindVirtualMethod来实现的。如果找不到对应的虚拟成员函数，那么再在Class对象c描述的类的关联的Direct成员函数列表中查找参数name和sig对应的成员函数。</p></li><li><p>经过前面的查找过程，如果都不能在Class对象c描述的类中找到与参数name和sig对应的成员函数，那么就抛出一个NoSuchMethodError异常。否则的话，就将查找得到的ArtMethod对象封装成一个jmethodID值返回给调用者。</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;android虚拟机（二）&quot;&gt;&lt;a href=&quot;#android虚拟机（二）&quot; class=&quot;headerlink&quot; title=&quot;android虚拟机（二）&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android虚拟机（一）</title>
    <link href="http://fancy-blogs.com/2018/03/29/androidVM1/"/>
    <id>http://fancy-blogs.com/2018/03/29/androidVM1/</id>
    <published>2018-03-28T16:38:45.766Z</published>
    <updated>2018-04-02T17:04:26.642Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="android虚拟机（一）"><a href="#android虚拟机（一）" class="headerlink" title="android虚拟机（一）"></a>android虚拟机（一）</h1><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><h3 id="Dalvik虚拟机的启动过程"><a href="#Dalvik虚拟机的启动过程" class="headerlink" title="Dalvik虚拟机的启动过程"></a>Dalvik虚拟机的启动过程</h3><p><a href="https://blog.csdn.net/luoshengyang/article/details/8885792" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/8885792</a></p><p>Zygote进程在启动时会创建一个Dalvik实例，在它孵化app的进程时会复制一份到app的进程中，使每一个app进程都有一个独立的Dalvik虚拟机实例。</p><p><img src="http://img.blog.csdn.net/20130506004759886" alt=""></p><p>Dalvik虚拟机在Zygote进程中的启动过程，这个启动过程主要完成以下4个事情：</p><ol><li>创建了一个Dalvik虚拟机实例；（这里只是对JavaVM结构的成员变量赋值，真正环境的创建在step.3）</li><li>为主线程的设置了一个JNI环境；</li><li>加载了Java核心类及其JNI方法；</li><li>注册了Android核心类的JNI方法。</li></ol><p>AndroidRuntime类的start主要做了一下四件事：</p><ol><li>调用startVm来创建一个Dalvik虚拟机实例，保存在成员变量mJavaVM。（JavaVM是Dalvik虚拟机在JNI中的表示）</li><li>调用成员函数startReg来注册一些Android核心类的JNI方法。</li><li>通过JNI接口，FindClass找到com.android.internal.os.ZygoteInit类，通过JNI接口，GetStaticMethodID找到com.android.internal.os.ZygoteInit类的静态成员函数main作为java层的入口。</li><li>在Zygote进程退出时，会调用JavaVM的成员函数DetachCurrentThread来使Dalvik虚拟机实例和Zygote进程的主线程脱离，再调用DestroyJavaVM来销毁Dalvik虚拟机实例。</li></ol><p>关于JavaVM与JVM的区别：在java里，每一个process可以产生多个java vm对象，但是在android上，每一个process只有一个Dalvik虚拟机对象，也就是在android进程中是通过有且只有一个虚拟器对象来服务所有java和c/c++代码。</p><p>startVM调用JNI_CreateJavaVM来创建</p><p>JNI_CreateJavaVM主要完成以下四件事情。</p><ol><li>为当前进程创建一个Dalvik虚拟机实例，即一个JavaVMExt对象。</li><li>为当前线程创建和初始化一个JNI环境，即一个JNIEnvExt对象，这是通过调用函数dvmCreateJNIEnv来完成的。</li><li>将参数vm_args所描述的Dalvik虚拟机启动选项拷贝到变量argv所描述的一个字符串数组中去，并且调用函数dvmStartup来初始化前面所创建的Dalvik虚拟机实例。</li><li>调用函数dvmChangeStatus将当前线程的状态设置为正在执行NATIVE代码，并且将面所创建和初始化好的JavaVMExt对象和JNIEnvExt对象通过输出参数p_vm和p_env返回给调用者。</li></ol><p>在Java层调用C层的本地函数时，调用c本地函数的线程必然通过Dalvik虚拟机来调用c层的本地函数，此时，Dalvik虚拟机会为本地的C组件实例化一个JNIEnv指针，该指针指向Dalvik虚拟机的具体的函数列表。<br>当JNI的c组件调用Java层的方法或者属性时，需要通过JNIEnv指针来进行调用。<br>当本地c/c++想获得当前线程所要使用的JNIEnv时，可以使用Dalvik虚拟机对象的JavaVM<em> jvm-&gt;GetEnv()返回当前线程所在的JNIEnv</em><br>（可以联系在native中，动态注册函数的流程）</p><p>JavaVMExt对象和JNIEnv对象都有一个函数列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct JavaVMExt &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNIInvokeInterface* funcTable;     <span class="comment">/* must be first */</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">struct JNIEnvExt &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNINativeInterface* funcTable;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>调用dvmCreateJNIEnv来创建JNIEnv</p><ol><li>创建一个JNIEnvExt对象，用来描述一个JNI环境，并且设置这个JNIEnvExt对象的宿主Dalvik虚拟机，以及所使用的本地接口表，即设置这个JNIEnvExt对象的成员变量funcTable和vm。这里的宿主Dalvik虚拟机即为当前进程的Dalvik虚拟机，它保存在全局变量gDvm的成员变量vmList中。本地接口表由全局变量gNativeInterface来描述。<ol><li>参数self描述的是前面创建的JNIEnvExt对象要关联的线程，可以通过调用函数dvmSetJniEnvThreadId来将它们关联起来。注意，当参数self的值等于NULL的时候，就表示前面的JNIEnvExt对象是要与主线程关联的，但是要等到后面再关联，因为现在用来描述主线程的Thread对象还没有准备好。通过将一个JNIEnvExt对象的成员变量envThreadId和self的值分别设置为0x77777775和0x77777779来表示它还没有与线程关联。</li><li>在一个Dalvik虚拟机里面，可以运行多个线程。所有关联有JNI环境的线程都有一个对应的JNIEnvExt对象，这些JNIEnvExt对象相互连接在一起保存在用来描述其宿主Dalvik虚拟机的一个JavaVMExt对象的成员变量envList中。因此，前面创建的JNIEnvExt对象需要连接到其宿主Dalvik虚拟机的JavaVMExt链表中去。</li></ol></li></ol><p>创建JavaVM和JNIEnv过程大致相同，绑定一个函数列表，然后将该对象的指针保存起来。</p><p>调用dvmStartup初始化JavaVM</p><p>子模块的初始化</p><p>最后一步的初始化：dvmDebuggerStartup-&gt;dvmInitZygote</p><p>调用了系统调用setpgid来设置当前进程，即Zygote进程的进程组ID，两个参数均为0，这意味着Zygote进程的进程组ID与进程ID是相同的，也就是说，Zygote进程运行在一个单独的进程组里面。</p><h3 id="Dalvik虚拟机的运行过程"><a href="#Dalvik虚拟机的运行过程" class="headerlink" title="Dalvik虚拟机的运行过程"></a>Dalvik虚拟机的运行过程</h3><p><a href="http://blog.csdn.net/luoshengyang/article/details/8914953" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/8914953</a></p><p><img src="http://img.blog.csdn.net/20130512232649003" alt=""></p><p>JNIEnv的CallStaticVoidMethod调用回调函数表中的CallStaticVoidMethodV，来执行参数clazz和methodID所描述的Java代码。</p><p>CallStaticVoidMethodV-&gt;CallStatic##_jname##MethodV-&gt;dvmCallMethodV</p><p>函数dvmCallMethodV首先检查参数method描述的函数是否是一个JNI方法。如果是的话，那么它所指向的一个Method对象的成员变量nativeFunc就指向该JNI方法的地址，因此就可以直接对它进行调用。否则的话，就说明参数method描述的是一个Java函数，这时候就需要继续调用函数dvmInterpret来执行它的代码.</p><p>dvmCallMethodV中会根据执行模式来选择不同的解释器入口。</p><p>进入解释器后，对需要执行的java的类所相关部分进行初始化，之后是循环读取、解释指令码，直到return为止。</p><p>其中讲到Dalvik虚拟机解释器的可移植版本实现中，解释器对指令流的解释时，在获取到return指令时截止，是否可以在return指令后添加junk code。</p><h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p><a href="https://blog.csdn.net/luoshengyang/article/details/39256813" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/39256813</a></p><p>ART虚拟机实例的创建和Dalvik大相径庭。<br>ART虚拟机在Zygote进程中创建并启动，再由Zygote来fork给应用程序进程</p><p>###ART加载OAT文件的过程</p><p><a href="https://blog.csdn.net/luoshengyang/article/details/39307813" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/39307813</a></p><p>讲解一下OAT文件的格式，以及加载OAT的过程，包括涉及到的函数</p><p>oat文件本质上就是一个ELF文件</p><p>启动<br>Runtime create<br>Runtime init<br>&emsp;&emsp;Android 5.0中将option的解析放在了init中<br>&emsp;&emsp;&emsp;&emsp;1⃣️ ART启动<br>&emsp;&emsp;&emsp;&emsp;2⃣️ interpret DEX<br>&emsp;&emsp;ParsedOptions::Create<br>&emsp;&emsp;&emsp;&emsp;解析启动参数<br>&emsp;&emsp;Heap<br>&emsp;&emsp;&emsp;&emsp;space::ImageSpace::Create<br>&emsp;&emsp;JavaVMExt<br>&emsp;&emsp;Thread::Attach<br>&emsp;&emsp;GetHeap</p><p>运行<br>OatFile::Open<br>&emsp;&emsp;1⃣️portable&amp;&amp;executable：OpenDlopen<br>&emsp;&emsp;new OatFile<br>&emsp;&emsp;Dlopen<br>&emsp;&emsp;&emsp;&emsp;dlopne、dlsym -&gt; get begin/end (得到内存中oatdata段的内存区域)<br>&emsp;&emsp;2⃣️OpenElfFile<br>&emsp;&emsp;ElfFileOpen<br>&emsp;&emsp;&emsp;&emsp;FindDynamicSymbolAddress-&gt;get begin/end (得到内存中oatdata段的内存区域)<br>&emsp;&emsp;&emsp;&emsp;Setup<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader().GetKeyValueStoreSize()<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader().GetDexFileCount()</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15226886044319.jpg" alt="oatdata-c500"></p><p>获取到Dex文件的过程：先获取到OAT文件中的oatdata段起始地址，找到oatheader，跃过header，找到oat_dex_file，由偏移dex_file_offset（与oatdata起始的偏移）定位到dexfile。</p><p>获取方法的过程：同样以上方式找到oat_dex_file，在dex_file_offset后是一个数组，元素是指向oat_class的指针，每个oat_class与dex中的class一一对应。<br>oat_class:</p><table><thead><tr><th>Size</th><th>Name</th></tr></thead><tbody><tr><td>Int16</td><td>status</td></tr><tr><td>Int16</td><td>Type</td></tr><tr><td>Int32</td><td>Bitsize(when type==1)</td></tr><tr><td>Byte * bitsize</td><td>Bitmap[bitsize]（when type==1）</td></tr><tr><td>Int32 <em> 2 </em> n</td><td>OatMethodOffset[n]</td></tr></tbody></table><p>OatMethodOffset:</p><table><thead><tr><th>size</th><th>name</th></tr></thead><tbody><tr><td>int32</td><td>code_offest</td></tr><tr><td>int</td><td>gc_map_offset</td></tr></tbody></table><p>根据需要的method所在类的编号（在dex中class_def_item数组的索引值），找到对应oat_class，再根据method的编号（class_def_item中方法对应的encode<em>method数组的索引值），找到对应的OatMethodOffset，由begin</em>+code_offset(begin为内存中oatdata起始地址)，得到method的本地指令地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;android虚拟机（一）&quot;&gt;&lt;a href=&quot;#android虚拟机（一）&quot; class=&quot;headerlink&quot; title=&quot;android虚拟机（一）&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dex中方法指令隐藏</title>
    <link href="http://fancy-blogs.com/2018/03/23/extractdexins/"/>
    <id>http://fancy-blogs.com/2018/03/23/extractdexins/</id>
    <published>2018-03-22T16:42:32.714Z</published>
    <updated>2018-03-22T17:49:34.426Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="dex中方法指令隐藏"><a href="#dex中方法指令隐藏" class="headerlink" title="dex中方法指令隐藏"></a>dex中方法指令隐藏</h1><p>&emsp;&emsp;通过了解dex文件格式，获取到指定方法的指令码的偏移，将指令码清空，达到对指定方法实现的隐藏效果。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;dex文件格式这里就不详讲了，可以通过010editor直观得看到dex文件中各个区域信息。<br>&emsp;&emsp;关键是我们怎么获取到对应方法的指令码。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/AB135E84-4557-4F37-BE37-250B72DA71A4.png" alt="AB135E84-4557-4F37-BE37-250B72DA71A4"></p><p>&emsp;&emsp;我们看到，首先获取到class_defs_item，找到类信息的偏移（class_data_off），得到class_data_item，里面有direct方法列表和virtual方法列表，每一项记录了对应方法的code_item的偏移，由该偏移我们就能找到存放指令码的区域。</p><p>&emsp;&emsp;即然要实现指定方法的查找，就需要解析dex，解析出所有方法并存放起来，再由我们指定取出，来将其指令置空。</p><p><a href="http://www.wjdiankong.cn/archives/1118" target="_blank" rel="noopener">解析dex文件代码</a></p><p>&emsp;&emsp;通过<a href="http://www.wjdiankong.cn/archives/1118" target="_blank" rel="noopener">这篇文章</a>中的提示，修改了部分代码，完成了对指定方法的置空。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;在解析dex代码中，我们将string、type、proto都先存放起来，以便对方法名、参数类型解析时获取。<br>&emsp;&emsp;按照之前讲的索引过程，就需要先解析class_def_item，得到class_data_item</p><p><code>public static void parseClassIds(byte[] srcByte)</code><br>&ensp;|<br>\/<br><code>private static ClassDefItem parseClassDefItem(byte[] srcByte)</code><br>&ensp;|<br>\/<br><code>public static void parseClassData(byte[] srcByte)</code></p><p>&emsp;&emsp;我编译得到的dex部分class_def_item的class_data_off为0，这里我加了个对0的判断。<br>&emsp;&emsp;得到class_data_item后就可以获取对应类的方法列表。</p><p><code>private static ClassDataItem parseClassDataItem(byte[] srcByte, int offset)</code></p><p>&emsp;&emsp;这个函数在解析class_data_item时，4个字段的类型应该是uleb128，源代码中直接byte转int，故修改了size计算函数。<br>&emsp;&emsp;class_data_item中有direct方法列表和virtual方法列表，在遍历方法时需要分开遍历。</p><p><code>public static void parseCode(byte[] srcByte)</code><br>&ensp;|<br>\/<br><code>private static CodeItem parseCodeItem(byte[] srcByte, int offset)</code></p><p>&emsp;&emsp;在解析code_item时，关键是获取到指令码数组和指令码的文件偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">short[] insnsAry = new short[item.insns_size];</span><br><span class="line">int aryOffset = offset + 16;</span><br><span class="line">item.insnsoffset=aryOffset;</span><br><span class="line">for(int i=0;i&lt;item.insns_size;i++)&#123;</span><br><span class="line">byte[] insnsByte = Utils.copyByte(srcByte, aryOffset+i*2, 2);</span><br><span class="line">insnsAry[i] = Utils.byte2Short(insnsByte);</span><br><span class="line">&#125;</span><br><span class="line">item.insns = insnsAry;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;遍历方法函数，利用<code>directMethodCodeItemMap</code>和<code>virtualMethodCodeItemMap</code>将所有的方法存放起来，一个方法名对应一个方法实例。<br>&emsp;&emsp;部分method_item的code_off为0，也需要忽略处理。</p><p><code>private static String getMethodSignStr(MethodIdsItem methodItem)</code>由方法中各个字段，获取到方法的类名、方法名、参数名、返回类型，组成一个字符串。数据来源就是之前得到的string、type、proto三个列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">codeItemMap.putAll(ParseDexUtils.directMethodCodeItemMap);</span><br><span class="line">codeItemMap.putAll(ParseDexUtils.virtualMethodCodeItemMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String key : codeItemMap.keySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key:"</span>+key);</span><br><span class="line"><span class="keyword">if</span>(key.equals(className+methodName))&#123;</span><br><span class="line">CodeItem codeitem=codeItemMap.get(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> insns_size=codeitem.insns_size;</span><br><span class="line"><span class="keyword">int</span> insnsoffset = codeitem.insnsoffset;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ins_size:"</span>+insns_size+<span class="string">"ins_offset:"</span>+insnsoffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] nopBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[insns_size*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nopBytes.length;i++) &#123;</span><br><span class="line">nopBytes[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srcByte=Utils.replaceBytes(srcByte, nopBytes, insnsoffset);</span><br><span class="line"><span class="keyword">byte</span>[] signvalue=Utils.signature(srcByte,<span class="number">32</span>);</span><br><span class="line">srcByte=Utils.replaceBytes(srcByte, signvalue, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] checksum=Utils.checksum_bin(srcByte, <span class="number">12</span>);</span><br><span class="line">srcByte=Utils.replaceBytes(srcByte, checksum, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">Utils.saveFile(<span class="string">"dex/classes_tmp.dex"</span>, srcByte);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将所有方法合并成一个map，遍历搜索指定方法签名。获取到对应的code_item，取出指令码偏移，指令码个数，挨个置空。之后修复dex的signature和checksum。完成后替换原apk中的dex即可。<br>&emsp;&emsp;之后讲解指令码还原部分。</p><p><a href="https://github.com/Minxin/ExtractDexIns" target="_blank" rel="noopener">完成版代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;dex中方法指令隐藏&quot;&gt;&lt;a href=&quot;#dex中方法指令隐藏&quot; class=&quot;headerlink&quot; title=&quot;dex中方法指令隐藏&quot;&gt;&lt;/a&gt;dex中方法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dex保护总结</title>
    <link href="http://fancy-blogs.com/2018/03/09/dexprotect/"/>
    <id>http://fancy-blogs.com/2018/03/09/dexprotect/</id>
    <published>2018-03-09T15:47:05.886Z</published>
    <updated>2018-04-04T18:21:24.634Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="dex保护总结"><a href="#dex保护总结" class="headerlink" title="dex保护总结"></a>dex保护总结</h1><h2 id="android程序启动过程"><a href="#android程序启动过程" class="headerlink" title="android程序启动过程"></a>android程序启动过程</h2><p><a href="http://blog.csdn.net/qianhaifeng2012/article/details/52039053" target="_blank" rel="noopener">http://blog.csdn.net/qianhaifeng2012/article/details/52039053</a><br>1.Launcher.startActivitySafely</p><p>点击图标，Launcher的onClick方法相应，然后根据传入参数View v的v.getTag()方法得到被点击应用图标的ShortcutInfo，然后得到Intent数据。通过final Intent intent = ((ShortcutInfo) tag).intent。语句得到数据。有了一个应用的Intent就可以启动一个应用了。</p><p>Launcher.startActivitySafely-&gt; startActivity</p><p>2.Activity.startActivity</p><p>Activity是Launcher父类</p><p>Activity.startActivity-&gt;Activity.startActivityForResult</p><p>3.Activity.startActivityForResult</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =  </span><br><span class="line">        mInstrumentation.execStartActivity(  </span><br><span class="line">            this, mMainThread.getApplicationThread(), mToken, this,  </span><br><span class="line">            intent, requestCode, options);  </span><br><span class="line">```            </span><br><span class="line"></span><br><span class="line">这里的mInstrumentation是Activity类的成员变量，它的类型是Intrumentation，定义在Instrumentation.java文件中，它用来监控应用程序和系统的交互。</span><br><span class="line">这里的mMainThread也是Activity类的成员变量，它的类型是ActivityThread，它代表的是应用程序的主线程。这里通过mMainThread.getApplicationThread获得它里面的ApplicationThread成员变量，它是一个Binder对象，ActivityManagerService会使用它来和ActivityThread来进行进程间通信。</span><br><span class="line">**这里的mMainThread代表的是Launcher应用程序运行的进程。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Instrumentation.execStartActivity</span><br><span class="line">-&gt;(**ActivityManagerService**)ActivityManagerNative.getDefault() </span><br><span class="line">-&gt;ActivityManagerProxy.startActivity</span><br><span class="line"></span><br><span class="line">ActivityManagerProxy是一个代理类，通过IPC的Binder联系到ActivityManagerService，最后会调用ActivityManagerService的startActivity方法。</span><br><span class="line"></span><br><span class="line">4.ActivityManagerService.startActivity</span><br><span class="line"></span><br><span class="line">startActivity-&gt;startActivityAsUser-&gt;mStackSupervisor.startActivityMayWait</span><br><span class="line"></span><br><span class="line">(ActivityStackSupervisor)mStackSupervisor</span><br><span class="line"></span><br><span class="line">5.ActivityStackSupervisor.startActivityMayWait</span><br><span class="line"></span><br><span class="line">涉及两个函数：</span><br></pre></td></tr></table></figure><p>ActivityInfo aInfo =<br>               resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);  </p><pre><code>...</code></pre><p>int res = startActivityLocked(caller, intent, resolvedType, aInfo,<br>       voiceSession, voiceInteractor, resultTo, resultWho,<br>       requestCode, callingPid, callingUid, callingPackage,<br>       realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,<br>       componentSpecified, null, container, inTask);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中的resolveActivity方法主要是获得对参数intent的内容进行解析，得到MainActivity的相关信息，保存在aInfo变量中.</span><br><span class="line"></span><br><span class="line">6.ActivityStackSupervisor.startActivityLocked</span><br></pre></td></tr></table></figure></p><p>final int startActivityLocked(IApplicationThread caller,<br>            Intent intent, String resolvedType, ActivityInfo aInfo,<br>            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>            IBinder resultTo, String resultWho, int requestCode,<br>            int callingPid, int callingUid, String callingPackage,<br>            int realCallingPid, int realCallingUid, int startFlags, Bundle options,<br>            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,<br>            ActivityContainer container, TaskRecord inTask)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从传进来的参数caller得到调用者的进程信息，并保存在callerApp变量中，这里就是Launcher应用程序的进程信息了。 前面说过，参数resultTo是Launcher这个Activity里面的一个Binder对象，通过它可以获得Launcher这个Activity的相关信息，保存在sourceRecord变量中。</span><br><span class="line"></span><br><span class="line">记录启动的Activity的相关信息：</span><br></pre></td></tr></table></figure></p><p>ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,<br>                intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,<br>                requestCode, componentSpecified, voiceSession != null, this, container, options);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,<br>                startFlags, true, options, inTask);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">7.ActivityStackSupervisor.startActivityUncheckedLocked</span><br><span class="line"></span><br><span class="line">这个方法主要用于创建Acitivity栈，根据Activity的启动模式，由于是点击图标进来的，一开始也设置了标志位Intent.FLAG_ACTIVITY_NEW_TASK，所以会新创建一个Activity栈。如果之前已经有栈，且不是singleinstance，就不会再创建新的栈，会将待启动的Activity添加到原来的栈中。</span><br><span class="line"></span><br><span class="line">startActivityUncheckedLocked-&gt;ActivityStack.resumeTopActivitiesLocked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.ActivityStack.resumeTopActivitiesLocked</span><br><span class="line"></span><br><span class="line">resumeTopActivitiesLocked</span><br><span class="line">-&gt;resumeTopActivityInnerLocked</span><br><span class="line">-&gt;ActivityStackSupervisor.startSpecificActivityLocked</span><br><span class="line"></span><br><span class="line">9.ActivityStackSupervisor.startSpecificActivityLocked</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,  </span><br><span class="line">        boolean andResume, boolean checkConfig) &#123;  </span><br><span class="line">    // Is this activity&apos;s application already running?  </span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,  </span><br><span class="line">            r.info.applicationInfo.uid, true);  </span><br><span class="line">  </span><br><span class="line">    r.task.stack.setLaunchTime(r);  </span><br><span class="line">  </span><br><span class="line">    if (app != null &amp;&amp; app.thread != null) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0  </span><br><span class="line">                    || !&quot;android&quot;.equals(r.info.packageName)) &#123;  </span><br><span class="line">                // Don&apos;t add this if it is a platform component that is marked  </span><br><span class="line">                // to run in multiple processes, because this is actually  </span><br><span class="line">                // part of the framework so doesn&apos;t make sense to track as a  </span><br><span class="line">                // separate apk in the process.  </span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,  </span><br><span class="line">                        mService.mProcessStats);  </span><br><span class="line">            &#125;  </span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);  </span><br><span class="line">            return;  </span><br><span class="line">        &#125; catch (RemoteException e) &#123;  </span><br><span class="line">            Slog.w(TAG, &quot;Exception when starting activity &quot;  </span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // If a dead object exception was thrown -- fall through to  </span><br><span class="line">        // restart the application.  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,  </span><br><span class="line">            &quot;activity&quot;, r.intent.getComponent(), false, false, true);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当第一次启动应用程序的Activity，取回来的app为null。在Activity应用程序中的AndroidManifest.xml配置文件中，我们没有指定Application标签的process属性，系统就会默认使用package的名称。每一个应用程序都有自己的uid，因此，这里uid + process的组合就可以为每一个应用程序创建一个ProcessRecord。</p><p>所以下面if (app != null &amp;&amp; app.thread != null)条件不成立，那么条件里面realStartActivityLocked 方法就不会执行，而是执行ActivityManagerService.startProcessLocked函数进行下一步操作。</p><p>10.ActivityManagerService.startProcessLocked</p><p>app=null<br> |<br> V<br> app = newProcessRecordLocked(info, processName, isolated, isolatedUid);<br> |<br> V<br> addProcessNameLocked<br> |<br> V<br> mProcessNames.put(proc.processName, proc.uid, proc);<br> 有了进程信息之后<br> ActivityManagerService.startProcessLocked<br> |<br> V<br>Process.start</p><p>调用Process.start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entryPoint = <span class="string">"android.app.ActivityThread"</span>  </span><br><span class="line">Process.ProcessStartResult startResult = Process.start(entryPoint,  </span><br><span class="line">      app.processName, uid, uid, gids, debugFlags, mountExternal,  </span><br><span class="line">      app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,  </span><br><span class="line">      app.info.dataDir, entryPointArgs);</span><br></pre></td></tr></table></figure><p>11.Process.start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,  </span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,  </span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;  </span><br><span class="line">        Log.e(LOG_TAG,  </span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(  </span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startViaZygote会通过<a href="https://www.cnblogs.com/bastard/archive/2012/09/03/2668579.html" target="_blank" rel="noopener">zygote机制</a>开启一个新的进程。由于我们导入的类名是android.app.ActivityThread，开启一个ActivityThread进程，这也是为什么一个应用程序只有一个ActivityThread，然后会执行他的main方法。</p><p>12.ActivityThread.main</p><p>其中调用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread thread = new ActivityThread();  </span><br><span class="line">thread.attach(false);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;  </span><br><span class="line">        .........  </span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            mgr.attachApplication(mAppThread);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;  </span><br><span class="line">             </span><br><span class="line">         &#125;  </span><br><span class="line">    ..................  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会执行mgr.attachApplication方法，mgr = ActivityManagerNative.getDefault()，通过前面分析它是ActivityManagerService的代理对象ActivityManagerProxy对象。所以最终会转向ActivityManagerService的attachApplication方法。</p><p>其中mAppThread是ApplicationThread，是一个Binder对象，用于ActivityManagerService与ActivityThread通信。</p><p>13.ActivityManagerService.attachApplication</p><p>attachApplication-&gt;attachApplicationLocked</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProcessRecord app;  </span><br><span class="line">    if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123;  </span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;  </span><br><span class="line">            app = mPidsSelfLocked.get(pid);  </span><br><span class="line">        ....</span><br><span class="line">    </span><br><span class="line">try &#123;  </span><br><span class="line">    if (mStackSupervisor.attachApplicationLocked(app)) &#123;  </span><br><span class="line">        didSomething = true;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过pid获取之前由Process.start创建的进程的信息记录,再由<code>mStackSupervisor.attachApplicationLocked(app)</code>执行</p><p>attachApplicationLocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">      if (realStartActivityLocked(hr, app, true, true)) &#123;  </span><br><span class="line">          didSomething = true;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>调用mMainStack.realStartActivityLocked执行真正的Activity启动操作。这里要启动的Activity通过调用mMainStack.topRunningActivityLocked(null)从堆栈顶端取回来，这时候在堆栈顶端的Activity就是MainActivity了。</p><p>14.ActivityManagerService.realStartActivityLocked</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r,  </span><br><span class="line">        ProcessRecord app, boolean andResume, boolean checkConfig)  </span><br><span class="line">        throws RemoteException &#123;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">        .....................  </span><br><span class="line">        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,  </span><br><span class="line">                System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),  </span><br><span class="line">                new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,  </span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,  </span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);  </span><br><span class="line">  </span><br><span class="line">        ..........................  </span><br><span class="line">  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.thread是ApplicationThreadProxy对象，是一个代理对象，代理就是ApplicationThread，情况完全类似于ActivityManagerProxy代理类。所以逻辑转向了ApplicationThread的scheduleLaunchActivity方法。</p><p>15.ApplicationThread.scheduleLaunchActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,  </span><br><span class="line">               ActivityInfo info, Configuration curConfig, Configuration overrideConfig,  </span><br><span class="line">               CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,  </span><br><span class="line">               int procState, Bundle state, PersistableBundle persistentState,  </span><br><span class="line">               List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,  </span><br><span class="line">               boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;  </span><br><span class="line"> </span><br><span class="line">           updateProcessState(procState, false);  </span><br><span class="line"> </span><br><span class="line">           ActivityClientRecord r = new ActivityClientRecord();  </span><br><span class="line"> </span><br><span class="line">           r.token = token;  </span><br><span class="line">           r.ident = ident;  </span><br><span class="line">           r.intent = intent;  </span><br><span class="line">           r.referrer = referrer;  </span><br><span class="line">           r.voiceInteractor = voiceInteractor;  </span><br><span class="line">           r.activityInfo = info;  </span><br><span class="line">           r.compatInfo = compatInfo;  </span><br><span class="line">           r.state = state;  </span><br><span class="line">           r.persistentState = persistentState;  </span><br><span class="line"> </span><br><span class="line">           r.pendingResults = pendingResults;  </span><br><span class="line">           r.pendingIntents = pendingNewIntents;  </span><br><span class="line"> </span><br><span class="line">           r.startsNotResumed = notResumed;  </span><br><span class="line">           r.isForward = isForward;  </span><br><span class="line"> </span><br><span class="line">           r.profilerInfo = profilerInfo;  </span><br><span class="line"> </span><br><span class="line">           r.overrideConfig = overrideConfig;  </span><br><span class="line">           updatePendingConfiguration(curConfig);  </span><br><span class="line"> </span><br><span class="line">           sendMessage(H.LAUNCH_ACTIVITY, r);  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>函数首先创建一个ActivityClientRecord实例，并且初始化它的成员变量，然后发送一个启动Activity的消息交给Handler处理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;  </span><br><span class="line">           if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));  </span><br><span class="line">           switch (msg.what) &#123;  </span><br><span class="line">               case LAUNCH_ACTIVITY: &#123;  </span><br><span class="line">                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);  </span><br><span class="line">                   final ActivityClientRecord r = (ActivityClientRecord) msg.obj;  </span><br><span class="line">  </span><br><span class="line">                   r.packageInfo = getPackageInfoNoCheck(  </span><br><span class="line">                           r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">                   handleLaunchActivity(r, null);  </span><br><span class="line">                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </span><br><span class="line">               &#125; break;  </span><br><span class="line">    ...................................  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>16.ActivityThread.handleLaunchActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;    </span><br><span class="line">       ......    </span><br><span class="line">   </span><br><span class="line">       Activity a = performLaunchActivity(r, customIntent);    </span><br><span class="line">   </span><br><span class="line">       if (a != null) &#123;    </span><br><span class="line">           r.createdConfig = new Configuration(mConfiguration);    </span><br><span class="line">           Bundle oldState = r.state;    </span><br><span class="line">           handleResumeActivity(r.token, false, r.isForward);    </span><br><span class="line">   </span><br><span class="line">           ......    </span><br><span class="line">       &#125; else &#123;    </span><br><span class="line">           ......    </span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面的源码可以看出，performLaunchActivity最终完成了Activity对象的创建和启动过程，并且Activity通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期方法。而onCreate这个这个生命周期方法在performLaunchActivity方法中被回调。</p><p>17.ActivityThread.performLaunchActivity</p><p>这个方法主要完成了如下几件事</p><p>1）从ActivityClientRecord中获取待启动的Activity的组件信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ActivityInfo aInfo = r.activityInfo;  </span><br><span class="line">if (r.packageInfo == null) &#123;  </span><br><span class="line">    r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,  </span><br><span class="line">            Context.CONTEXT_INCLUDE_CODE);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ComponentName component = r.intent.getComponent();  </span><br><span class="line">if (component == null) &#123;  </span><br><span class="line">    component = r.intent.resolveActivity(  </span><br><span class="line">        mInitialApplication.getPackageManager());  </span><br><span class="line">    r.intent.setComponent(component);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if (r.activityInfo.targetActivity != null) &#123;  </span><br><span class="line">    component = new ComponentName(r.activityInfo.packageName,  </span><br><span class="line">            r.activityInfo.targetActivity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）通过Instrumenttation的newActivity方法使用类加载器创建Activity对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Activity activity = null;  </span><br><span class="line">try &#123;  </span><br><span class="line">    java.lang.ClassLoader cl = r.packageInfo.getClassLoader();  </span><br><span class="line">    activity = mInstrumentation.newActivity(  </span><br><span class="line">            cl, component.getClassName(), r.intent);  </span><br><span class="line">    StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">    r.intent.setExtrasClassLoader(cl);  </span><br><span class="line">    r.intent.prepareToEnterProcess();  </span><br><span class="line">    if (r.state != null) &#123;  </span><br><span class="line">        r.state.setClassLoader(cl);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">    if (!mInstrumentation.onException(activity, e)) &#123;  </span><br><span class="line">        throw new RuntimeException(  </span><br><span class="line">            &quot;Unable to instantiate activity &quot; + component  </span><br><span class="line">            + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）通过LoadeApk的makeApplication方法来尝试创建Application对象</p><p><code>Application app = r.packageInfo.makeApplication(false, mInstrumentation);</code></p><p>makeApplication方法代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,  </span><br><span class="line">        Instrumentation instrumentation) &#123;  </span><br><span class="line">    if (mApplication != null) &#123;  </span><br><span class="line">        return mApplication;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Application app = null;  </span><br><span class="line">  </span><br><span class="line">    String appClass = mApplicationInfo.className;  </span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;  </span><br><span class="line">        appClass = &quot;android.app.Application&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    try &#123;  </span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();  </span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line">            initializeJavaContextClassLoader();  </span><br><span class="line">        &#125;  </span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);  </span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(  </span><br><span class="line">                cl, appClass, appContext);  </span><br><span class="line">        appContext.setOuterContext(app);  </span><br><span class="line">    &#125; catch (Exception e) &#123;  </span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;  </span><br><span class="line">            throw new RuntimeException(  </span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass  </span><br><span class="line">                + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mActivityThread.mAllApplications.add(app);  </span><br><span class="line">    mApplication = app;  </span><br><span class="line">  </span><br><span class="line">    if (instrumentation != null) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            instrumentation.callApplicationOnCreate(app);  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;  </span><br><span class="line">                throw new RuntimeException(  </span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()  </span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Rewrite the R &apos;constants&apos; for all library apks.  </span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread)  </span><br><span class="line">            .getAssignedPackageIdentifiers();  </span><br><span class="line">    final int N = packageIdentifiers.size();  </span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;  </span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);  </span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return app;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从makeApplication方法可以看出，通过mActivityThread.mInstrumentation.newApplication创建Application对象，然后通过callApplicationOnCreate方法间接回调onCreate方法。</p><p>4）创建ContextImpl对象并通过Activity的attach方法来完成一些重要数据的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Context appContext = createBaseContextForActivity(r, activity);  </span><br><span class="line">CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());  </span><br><span class="line">Configuration config = new Configuration(mCompatConfiguration);  </span><br><span class="line">if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;  </span><br><span class="line">    + r.activityInfo.name + &quot; with config &quot; + config);  </span><br><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,  </span><br><span class="line">    r.ident, app, r.intent, r.activityInfo, title, r.parent,  </span><br><span class="line">    r.embeddedID, r.lastNonConfigurationInstances, config,  </span><br><span class="line">    r.referrer, r.voiceInteractor);</span><br></pre></td></tr></table></figure><p>ContextImpl是一个很重要的数据结构，它是Context的具体实现，Context中的大部分逻辑都是由ContextImpl来完成的。ContextImpl是通过Activity的attach方法来和Activity建立链接的，处理之外，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Window接受到外部输入事件后就可以将时间传递给Activity。</p><p>5）调用Activity的onCreate</p><p><code>mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</code></p><p>最后回调Activity的onCreate方法。这也意味着应用已经启动起来了。</p><p>###总结</p><p>&emsp;&emsp;Launcher会响应图标点击，开始开启Activity，应用图标的shortcutinfo的intent获得应用信息，通知ActivityManagerServer来启动Activity，首先需要获取Activity的信息，并存放Activity信息，为启动作准备（对应ActivityRecord和Activity栈）。信息有了之后就要为应用准备一个进程，zygotefork出一个进程后，执行ActivityThread的main方法，在该方法里会先准备好Looper和消息队列，再调用attach将这个进程绑定到ActivityManagerServer，之后就要准备启动Activity了，ActivityManagerServer这时候会保存一个应用进程的代理对象，这样ActivityManagerServer就可以对Activity进行管理了，ActivityManagerServer获取Activity栈中的Activity信息，来通知应用进程创建入口Activity的实例。</p><h2 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h2><p>类加载器：<br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/41384667" target="_blank" rel="noopener">http://blog.csdn.net/jiangwei0910410003/article/details/41384667</a></p><p>ClassLoader:<br><img src="http://p1ju8xds4.bkt.clouddn.com/15206937280365.jpg" alt=""></p><p>代码动态加载：</p><ol><li>接管系统加载，比源程序优先获取执行权利</li><li>利用ClassLoader进行源代码加载</li><li>还原程序执行环境</li><li>将执行权利移交给源程序</li></ol><h2 id="绑定Application"><a href="#绑定Application" class="headerlink" title="绑定Application"></a>绑定Application</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> at java.lang.Thread.dumpStack(Thread.java:505)</span><br><span class="line">06-21 17:42:18.448 8620-8620/cn.terminal.egame.myphone W/System.err:     at cn.terminal.egame.myphone.MyApplication.onCreate(MyApplication.java:13)</span><br><span class="line">06-21 17:42:18.448 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1015)</span><br><span class="line">06-21 17:42:18.448 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4793)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread.access$1600(ActivityThread.java:165)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1437)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.os.Looper.loop(Looper.java:150)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:5621)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:794)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:684)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在ActivityThread的main方法中会执行ActivityThread对象的attach方法，回调了ActivityManagerService的远程接口本地代理对象ActivityManagerProxy的attachApplication函数通知attachApplication，并传入参数是mAppThread，这是ApplicationThread类型的Binder对象，用来接受ActivityManagerService的进程间消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">  ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">   .....</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> ｛</span></span><br><span class="line"><span class="function">   .......</span></span><br><span class="line"><span class="function">    <span class="keyword">final</span> IActivityManager mgr </span>= ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ActivityManagerService在接受到attachApplication函数调用远程消息之后，一系列处理之后，会有两个重要Binder通信，一个就是通过传来的参数Binder参数ApplicationThread来通知ActivityThread中mAppThread远程中调用bindApplication()，另一个是scheduleLaunchActivity。在Ams中收到attachApplication时代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AMS</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//获取applicationThread的进程id(也就是淘宝应用进程)</span></span><br><span class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the application record that is being attached...  either via</span></span><br><span class="line">        <span class="comment">// the pid if we are running in multiple processes, or just pull the</span></span><br><span class="line">        <span class="comment">// next app record if we are emulating process with anonymous threads.</span></span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为进程由AMS启动，所以在AMS中一定会有ProcessRecord（进程记录）</span></span><br><span class="line">        <span class="comment">//如果没有ProcessRecord，则需要杀死该进程并退出</span></span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ```</span><br></pre></td></tr></table></figure><pre><code>    return false;}// If this application record is still attached to a previous// process, clean it up now.if (app.thread != null) {    //如果从ProcessRecord中获取的IApplicationThread不为空，则需要处理该IApplicationThread    //因为有可能此Pid为复用，旧应用进程刚释放，内部IApplicationThread尚未清空，    //同时新进程又刚好使用了此Pid    handleAppDiedLocked(app, true, true);}//创建死亡代理（进程kill后通知AMS）AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);//进程注册成功，移除超时通知mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //******绑定Application******</span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">            profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">            app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">            mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">            isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">            new Configuration(mConfiguration), app.compat,</span><br><span class="line">            getCommonServicesLocked(app.isolated),</span><br><span class="line">            mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line"></span><br><span class="line">    updateLruProcessLocked(app, false, null);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br></pre></td></tr></table></figure>    //bindApplication失败后，重启进程    startProcessLocked(app, &quot;bind fail&quot;, processName);    return false;}try {    //******启动Activity(启动应用MainActivity)******    if (mStackSupervisor.attachApplicationLocked(app)) {        didSomething = true;//didSomething表示是否有启动四大组件    }} catch (Exception e) {    badApp = true;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    //绑定service和Broadcast的Application</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (badApp) &#123;</span><br><span class="line">        //如果以上组件启动出错，则需要杀死进程并移除记录</span><br><span class="line">        app.kill(&quot;error during init&quot;, true);</span><br><span class="line">        handleAppDiedLocked(app, false, true);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果以上没有启动任何组件，那么didSomething为false</span><br><span class="line">    if (!didSomething) &#123;</span><br><span class="line">        //调整进程的oom_adj值， oom_adj相当于一种优先级</span><br><span class="line">        //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>从上午可以看到在attachApplicationLocked中有两个比较重要的方法函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread.bindApplication（…） : 绑定Application到ActivityThread</span><br><span class="line">mStackSupervisor.attachApplicationLocked（app） : 启动Activity（7.0前为mMainStack.realStartActivityLocked()）</span><br></pre></td></tr></table></figure><h2 id="动态加载dex"><a href="#动态加载dex" class="headerlink" title="动态加载dex"></a>动态加载dex</h2><h3 id="外部类加载"><a href="#外部类加载" class="headerlink" title="外部类加载"></a>外部类加载</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制.  Java反射允许我们修改Android中隐藏的类,以及其中的属性。<br>Android 基于Java开发,因此具有Java拥有的一切优势.因此允许在程序运行起来后动态地加载额外的代码.而这个代码加载器,称为ClassLoader。</p><p><strong>时机</strong></p><p>ActivityThread.main()<br>ActivityThread.attach()<br>ActivityManagerSevice.attachApplication-&gt;attachApplicationLocked<br>ActivityThread.BindApplication– BIND_APPLICATION消息–&gt;handlBindApplication(内有等待java调试器挂接)<br> Application app = data.info.makeApplication(data.restrictedBackupMode, null);<br>LoadedApk.java:<br>makeApplication-&gt;newApplication<br>Application.attach-&gt;Application.attachBaseContext<br>Instrumentation.callApplicationOnCreate(app);<br>callApplicationOnCreate-&gt;Application.onCreate()</p><p>Activity类 、Service类 、Application类本质上都是Context子类<br>创建Application 对象时（而且整个App共一个Application对象），创建Service对象时，创建Activity对象时，都会创建Context实例。<br>选择attachBaseContext作为修改加载Activity的入口再合适不过了。</p><p><strong>实现步骤：</strong></p><ol><li>新建工程，完成主要代码，build之后提取dex文件（注意mulitDexEnable设置为false）</li><li>反编译dex，删除不需要的类，对应于smali文件</li><li>回编译dex，将dex放回工程目录（可对其加密处理）</li><li>工程中新建入口（即重载attachBaseContext），注意配置文件中启动Activity依然是原类名，添加启动Application类名</li></ol><h3 id="代码自修改"><a href="#代码自修改" class="headerlink" title="代码自修改"></a>代码自修改</h3><p>在源代码中写入虚假代码，载入内存后，利用先执行的native代码修改字节码实现逻辑代码修改。<br>在native代码中先获取到当前进程的内存信息（利用/proc/[pid]/maps) ,查找到dex段，搜索”dex\n035”magic值判断dex开头，利用dex文件格式获取对应方法地址，实现内存修改。</p><h3 id="函数动态还原"><a href="#函数动态还原" class="headerlink" title="函数动态还原"></a>函数动态还原</h3><p>利用外部类加载+native hook实现（对应于java层和native层的类加载部分）：</p><ol><li>抽取dex中需要加密的函数字节码，保存为文件，清空偏移</li><li>将提取字节码文件和dex文件移入工程，用以上方式加载</li><li>在native代码中，利用dexlib解析dex</li><li>利用hook框架实现对libdvm.so的dvmDefineClass</li><li>实现还原对应方法的字节码</li></ol><h3 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h3><p><img src="http://p1ju8xds4.bkt.clouddn.com/15211199989900.jpg" alt=""></p><p>结构图：<br><img src="http://p1ju8xds4.bkt.clouddn.com/dex.png" alt="a-c"></p><p>字符串池索引过程：<br>header.string_ids_off -&gt; string_id_list[0].string_data_off -&gt; string_item[0]|(string_item_size+byte[size])</p><p>方法字节码索引过程：<br><img src="http://p1ju8xds4.bkt.clouddn.com/AB135E84-4557-4F37-BE37-250B72DA71A4.png" alt="AB135E84-4557-4F37-BE37-250B72DA71A4"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;dex保护总结&quot;&gt;&lt;a href=&quot;#dex保护总结&quot; class=&quot;headerlink&quot; title=&quot;dex保护总结&quot;&gt;&lt;/a&gt;dex保护总结&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>so保护总结</title>
    <link href="http://fancy-blogs.com/2018/03/07/soanti/"/>
    <id>http://fancy-blogs.com/2018/03/07/soanti/</id>
    <published>2018-03-07T10:51:39.599Z</published>
    <updated>2018-09-13T10:08:51.938Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="so保护总结"><a href="#so保护总结" class="headerlink" title="so保护总结"></a>so保护总结</h1><h2 id="so反调试"><a href="#so反调试" class="headerlink" title="so反调试"></a>so反调试</h2><h3 id="检查Tracepid"><a href="#检查Tracepid" class="headerlink" title="检查Tracepid"></a>检查Tracepid</h3><p>&emsp;&emsp;由于调试进程附加到被调试进程后，目标进程会改变进程状态，将调试进程pid设为本进程的跟踪进程，在进程信息里可查看，<code>/proc/[pid]/status</code>中的TracePid字段就是跟踪进程的pid，如果进程未被跟踪，那么该值为0。所以我们可以通过该值是否为0来判断进程是否被调试。</p><p><strong>示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readtrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* fd;</span><br><span class="line">    <span class="keyword">char</span> context[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> pidname[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> pid=getpid();</span><br><span class="line">    LOGI(<span class="string">"pid is : %d "</span>,pid);</span><br><span class="line">    <span class="built_in">sprintf</span>(pidname,<span class="string">"/proc/%d/status"</span>,pid);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fd = fopen(pidname, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">while</span> (fgets(context, <span class="number">128</span>, fd)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(context, <span class="string">"TracerPid"</span>, <span class="number">9</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> status = atoi(&amp;context[<span class="number">10</span>]);</span><br><span class="line">                LOGI(<span class="string">"the process status is %d, %s"</span>, status, context);</span><br><span class="line">                fclose(fd);</span><br><span class="line">                syscall(__NR_close, fd);</span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">                    LOGI(<span class="string">"find the process was debugging"</span>);</span><br><span class="line">                    kill(pid, SIGKILL);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路讲解</strong></p><p>&emsp;&emsp;通过开辟一个线程，在线程中执行检查代码，首先获取当前进程的pid，在获取该进程的status信息，遍历字段，找到TracePid字段，然后检查该值是否为0，如果不为0，即认为进程被调试，kill掉进程即可。</p><p><strong>效果</strong><br><img src="http://p1ju8xds4.bkt.clouddn.com/15204214066019.jpg" alt=""></p><p>运行程序，开始循环检查。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15204214772786.jpg" alt="a-w400"></p><p>未被调试时，TracePid值为0.<br>我们用ida附加上去，观察效果。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15204215759112.jpg" alt=""></p><p>点击运行后，发现检查到了被调试，TracePid的值时13615.</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15204216525218.jpg" alt=""></p><p>我们的调试进程的pid正好时13615.</p><h3 id="利用ptrace实现双进程保护"><a href="#利用ptrace实现双进程保护" class="headerlink" title="利用ptrace实现双进程保护"></a>利用ptrace实现双进程保护</h3><p>&emsp;&emsp;我们发现ida附加上去后，进程停止了，这时候并不能实现检查，那么我们需要开一个进程去检查而不是线程，所以双进程保护是一个很好的方式。我们利用fork函数来开一个子进程，在子进程中检查父进程时候被调试，而子进程由父进程调试，由于linux下，进程只允许被一个进程调试，那么我们用ida附加到子进程是不被允许的，而如果附加到父进程又会被子进程检测到，所以双进程保护可以起到更好的效果。</p><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readtrace2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fd;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> pid=getpid();</span><br><span class="line">    LOGI(<span class="string">"PID : %d"</span>, pid);</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">"/proc/%d/status"</span>, pid);</span><br><span class="line">    <span class="keyword">pid_t</span> child=fork();</span><br><span class="line">    <span class="keyword">if</span> (child==<span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">long</span> pt = ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//子进程反调试</span></span><br><span class="line"></span><br><span class="line">        logptrace(<span class="string">"child traceme"</span>,pt);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            fd = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">            <span class="keyword">while</span> (fgets(line, <span class="number">128</span>, fd)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line, <span class="string">"TracerPid"</span>, <span class="number">9</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> status = atoi(&amp;line[<span class="number">10</span>]);</span><br><span class="line">                    LOGI(<span class="string">"the process status is %d, %s"</span>, status, line);</span><br><span class="line">                    fclose(fd);</span><br><span class="line">                    syscall(__NR_close, fd);</span><br><span class="line">                    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">                        LOGI(<span class="string">"find the process was debugging"</span>);</span><br><span class="line">                        kill(pid, SIGKILL);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        LOGE(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路讲解</strong></p><p>&emsp;&emsp;父进程fork后，在子进程中完成和之前通用的操作，而在父进程中，要完成对子进程的附加操作。我使用了ptrace，关于ptrace，可以看一下我之前遇到问题时找到的一篇文章，我把它翻译了——<a href="http://fancy-blogs.com/2018/03/06/ptrace/">链接</a>。<br>&emsp;&emsp;父进程<code>wait(NULL);</code>是为了获取子进程SIGTRAP信号，子进程<code>wait(NULL);</code>是为了通知父进程。因为执行PTRACE操作时，目标进程必须是停止状态。在子进程里PTRACE_TRACEME操作，在之前找到的别人的代码中只要子进程执行PTRACE_TRACEME就会被父进程跟踪，而我实验发现并不可行，必须要有这两个wait来满足被跟踪进程停止的条件。</p><p><strong>效果</strong></p><p>运行程序：<br><img src="http://p1ju8xds4.bkt.clouddn.com/15204258649788.jpg" alt=""></p><p>子进程的PTRACE_TRACE执行成功，子进程开始检查。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15204259002831.jpg" alt=""></p><p>子进程的TracePid不为0，子进程已经被跟踪。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15204261827579.jpg" alt=""></p><p>9998是父进程的一个线程。</p><p>这时候我们尝试用ida附加，先附加父进程。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15204262776372.jpg" alt=""></p><p>子进程检查到调试进程，这次不用ida使其运行起来，父进程直接被子进程kill掉了。</p><p>我们尝试附加子进程。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15204263248541.jpg" alt=""></p><p>发现根本无法附加上去。</p><p><a href="https://github.com/Minxin/checktrace" target="_blank" rel="noopener">完整代码</a></p><h3 id="执行时间校验"><a href="#执行时间校验" class="headerlink" title="执行时间校验"></a>执行时间校验</h3><p>通过计算某部分代码的执行时间差来判断是否被调试，在Linux内核下可以通过time、gettimeofday，或者直接通过sys call来获取当前时间。另外，还可以通过自定义SIGALRM信号来判断程序运行是否超时。</p><h3 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h3><p>在Linux下，inotify可以实现监控文件系统事件（打开、读写、删除等），加固方案可以通过inotify监控apk自身的某些文件，某些内存dump技术通过/proc/pid/maps、/proc/pid/mem来实现内存dump，所以监控对这些文件的读写也能起到一定的反调试效果。</p><p>###调试进程及端口检查</p><ul><li>使用IDA动态调试APK时，android_server默认监听23946端口，所以通过检测端口号可以起到一定的反调试作用。具体而言，可以通过检测/proc/net/tcp文件，或者直接system执行命令netstat -apn等。</li><li>在对APK进行动态调试时，可能会打开android_server、gdb、gdbserver等调试相关进程，一般情况下，这几个打开的进程名和文件名相同，所以可以通过运行状态下的进程名来检测这些调试相关进程。具体而言，可以通过打开/proc/pid/cmdline、/proc/pid/statue等文件来获取进程名。当然，这种检测方法非常容易绕过――直接修改android_server、gdb、gdbserver的名字即可。</li></ul><h3 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h3><p>调试器设置断点时会发出SIGTRAP信号，系统接受到SIGTRAP信号后，会用当前pc值处的原指令替换bp指令。当在代码中本来就存在bp指令时，就会陷入循环（bp指令替换bp指令）。通过先注册自己的signal函数处理breakpoint异常（SIGTRAP），然后在运行时调用该函数，即可触发自定义SIGTRAP的接管函数。而动态调试时，SIGTRAP会先被调试器接收，处理失败。</p><p>from other’s blog:<br>breakpoint命令会使被调试进程发出信号SIGTRAP。通常调试器会截获Linux系统内给被调试进程的各种信号，由调试者可选地传递给被调试进程。但是SIGTRAP是个例外，因为通常的目标程序中不会出现breakpoint，因为这会使得程序自己奔溃。因此，当调试器遇到SIGTRAP信号时会认为是自己下的断点发出的。这样一来当调试器给这个breakpoint命令插入断点breakpoint后，备份的命令也是breakpoint（原指令），这样当继续执行时，调试器将备份指令恢复并执行，结果误以为备份后这个位置发出的SIGTRAP又是自己下的断点造成的，这样一来就会使得调试器的处理逻辑出现错误，不同的调试器会导致各种不同的问题。</p><p>利用信号机制对抗，可以在代码中写好断点，自己实现对应的信号处理函数，在处理函数中加入代码解密等功能，使得调试中擅自去除断点指令会导致崩溃。再对处理函数加密或者混淆，使静态分析难度加大，而在动态调试中就必须跟入信号处理函数。</p><h2 id="so加密"><a href="#so加密" class="headerlink" title="so加密"></a>so加密</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p><strong>section 加密</strong><br>自定义section，把需要加密的函数定义在该section中，该section将会被加密，在init中将其解密。<br>加密操作是通过so的信息来获取到自定义section，通过offset和size来获取到指定section，把section所有字节加密，修改section修改ELFheader中几个无用的字段来方便解密时索引。<br>解密操作，通过之前放置的索引来获取到加密的区域，对其解密后，就可以调用了。<br>尝试了修改e_shoff，由于是动态注册函数，在加载的时候报错了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">03-13 02:17:51.362 11931-11931/com.fancy.testsoshell E/linker: </span><br><span class="line">&quot;/data/app/com.fancy.testsoshell-2/lib/arm/libencrypto.so&quot; .dynamic section header was not found</span><br></pre></td></tr></table></figure><p>尝试将信息都放置e_entry中是可行的。</p><p>代码来源：<a href="http://www.wjdiankong.cn/archives/563" target="_blank" rel="noopener">http://www.wjdiankong.cn/archives/563</a><br>文章中使用静态注册+修改e_entry+e_shoff的方法，测试中出现问题，该用动态注册，加密代码稍作了修改。</p><p><a href="https://github.com/Minxin/SoSectionEncrypto" target="_blank" rel="noopener">测试实例</a></p><p><a href="http://www.wjdiankong.cn/archives/565" target="_blank" rel="noopener"><strong>函数加密</strong></a></p><h3 id="ELF格式"><a href="#ELF格式" class="headerlink" title="ELF格式"></a>ELF格式</h3><p><img src="http://p1ju8xds4.bkt.clouddn.com/elffront.png" alt="elffront"></p><p><strong>ELF header</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">unsigned char e_ident[EI_NIDENT];    //目标文件标识信息</span><br><span class="line">Elf32_Half e_type;                             //目标文件类型</span><br><span class="line">Elf32_Half e_machine;                       //目标体系结构类型</span><br><span class="line">Elf32_Word e_version;                      //目标文件版本</span><br><span class="line">Elf32_Addr e_entry;                          //程序入口的虚拟地址,若没有，可为0</span><br><span class="line">Elf32_Off e_phoff;                            //程序头部表格（Program Header Table）的偏移量（按字节计算）,若没有，可为0</span><br><span class="line">Elf32_Off e_shoff;                            //节区头部表格（Section Header Table）的偏移量（按字节计算）,若没有，可为0</span><br><span class="line">Elf32_Word e_flags;                        //保存与文件相关的，特定于处理器的标志。标志名称采用 EF_machine_flag的格式。</span><br><span class="line">Elf32_Half e_ehsize;                        //ELF 头部的大小（以字节计算）。</span><br><span class="line">Elf32_Half e_phentsize;                 //程序头部表格的表项大小（按字节计算）。</span><br><span class="line">Elf32_Half e_phnum;                      //程序头部表格的表项数目。可以为 0。</span><br><span class="line">Elf32_Half e_shentsize;                  //节区头部表格的表项大小（按字节计算）。</span><br><span class="line">Elf32_Half e_shnum;                      //节区头部表格的表项数目。可以为 0。</span><br><span class="line">Elf32_Half e_shstrndx;                  //节区头部表格中与节区名称字符串表相关的表项的索引。如果文件没有节区名称字符串表，此参数可以为 SHN_UNDEF。</span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p><img src="http://p1ju8xds4.bkt.clouddn.com/15208398577269.png" alt=""></p><p><strong>Program segment header table</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Program segment header. */ </span><br><span class="line">typedef struct &#123; </span><br><span class="line">Elf32_Word p_type; /* Segment type */ </span><br><span class="line">Elf32_Off p_offset; /* Segment file offset */ </span><br><span class="line">Elf32_Addr p_vaddr; /* Segment virtual address */ </span><br><span class="line">Elf32_Addr p_paddr; /* Segment physical address */ </span><br><span class="line">Elf32_Word p_filesz; /* Segment size in file */ </span><br><span class="line">Elf32_Word p_memsz; /* Segment size in memory */ </span><br><span class="line">Elf32_Word p_flags; /* Segment flags */ </span><br><span class="line">Elf32_Word p_align; /* Segment alignment */ </span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><p><strong>Section header table</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct&#123;</span><br><span class="line">Elf32_Word sh_name;   //节区名，是节区头部字符串表节区（Section Header String Table Section）的索引。名字是一个 NULL 结尾的字符串。</span><br><span class="line">Elf32_Word sh_type;    //为节区类型</span><br><span class="line">Elf32_Word sh_flags;    //节区标志</span><br><span class="line">Elf32_Addr sh_addr;    //如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应处的位置。否则，此字段为 0。</span><br><span class="line">Elf32_Off sh_offset;    //此成员的取值给出节区的第一个字节与文件头之间的偏移。</span><br><span class="line">Elf32_Word sh_size;   //此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）。</span><br><span class="line">Elf32_Word sh_link;   //此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span><br><span class="line">Elf32_Word sh_info;       //此成员给出附加信息，其解释依赖于节区类型。</span><br><span class="line">Elf32_Word sh_addralign;    //某些节区带有地址对齐约束.</span><br><span class="line">Elf32_Word sh_entsize;    //某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数。</span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><img src="http://p1ju8xds4.bkt.clouddn.com/15208638014797.png" alt=""></p><p><strong>特殊节区</strong></p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15208647310267.png" alt=""></p><p><strong>section索引过程：</strong></p><p>0+header.e_shoff=section_header_table_startaddress</p><p><strong>section名称索引过程：</strong></p><p>0+section_header_table[header.strndx].s_offset=string_table_startaddresss</p><h3 id="从linker源码看so加载"><a href="#从linker源码看so加载" class="headerlink" title="从linker源码看so加载"></a>从linker源码看so加载</h3><p>首先会调用do_dlopen, 其中调用find_library来获取soinfo，find_library调用find_library_internal。<br>find_library_internal会调用find_loaded_library来查看程序so调用链solist中是否已存在需要加载的so，如果有直接返回soinfo，否则调用load_library来获取soinfo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> soinfo* <span class="title">load_library</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;    <span class="comment">// Open the file.</span>    <span class="keyword">int</span> fd = open_library(name);    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;        DL_ERR(<span class="string">"library \"%s\" not found"</span>, name);        <span class="keyword">return</span> <span class="literal">NULL</span>;    &#125;    <span class="comment">// Read the ELF header and load the segments.</span>    <span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span>;    <span class="keyword">if</span> (!elf_reader.Load()) &#123;        <span class="keyword">return</span> <span class="literal">NULL</span>;    &#125;    <span class="keyword">const</span> <span class="keyword">char</span>* bname = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);    soinfo* si = soinfo_alloc(bname ? bname + <span class="number">1</span> : name);    <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;        <span class="keyword">return</span> <span class="literal">NULL</span>;    &#125;    si-&gt;base = elf_reader.load_start();    si-&gt;size = elf_reader.load_size();    si-&gt;load_bias = elf_reader.load_bias();    si-&gt;flags = <span class="number">0</span>;    si-&gt;entry = <span class="number">0</span>;    si-&gt;dynamic = <span class="literal">NULL</span>;    si-&gt;phnum = elf_reader.phdr_count();    si-&gt;phdr = elf_reader.loaded_phdr();    <span class="keyword">return</span> si;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span>;</span><br><span class="line"></span><br><span class="line">ElfReader::ElfReader(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> fd)</span><br><span class="line">    : name_(name), fd_(fd),</span><br><span class="line">     phdr_num_(<span class="number">0</span>), phdr_mmap_(<span class="literal">NULL</span>), phdr_table_(<span class="literal">NULL</span>), phdr_size_(<span class="number">0</span>),</span><br><span class="line">     load_start_(<span class="literal">NULL</span>), load_size_(<span class="number">0</span>), load_bias_(<span class="number">0</span>),</span><br><span class="line">     loaded_phdr_(<span class="literal">NULL</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">elf_reader.Load()</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ElfReader::Load() &#123;</span><br><span class="line"><span class="keyword">return</span> ReadElfHeader() &amp;&amp;</span><br><span class="line">      VerifyElfHeader() &amp;&amp;</span><br><span class="line">      ReadProgramHeader() &amp;&amp;</span><br><span class="line">      ReserveAddressSpace() &amp;&amp;</span><br><span class="line">      LoadSegments() &amp;&amp;</span><br><span class="line">      FindPhdr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadElfHeader():获取header<br>VerifyElfHeader():校验<br>magic<br>header_.e_ident[EI<em>CLASS]<br>header</em>.e_ident[EI<em>DATA]<br>header</em>.e<em>type<br>header</em>.e<em>version<br>header</em>.e_machine<br>ReadProgramHeader():读取Program segment header table<br>ReserveAddressSpace():根据program header 计算 SO 需要的内存大小并分配相应的空间<br>LoadSegments():遍历 program header table，找到类型为 PT_LOAD 的 segment，使用 mmap 将 segment 映射到内存<br>FindPhdr():获取内存中被加载的段地址</p><p><code>soinfo* si = soinfo_alloc(bname ? bname + 1 : name);</code><br>为so分配一个soinfo，并添加到solist中</p><p><strong>链接：</strong></p><p>a.定位动态节；<br>b.解析动态节；<br>c.加载依赖so；<br>d.重定位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phdr_table_get_dynamic_section(phdr, phnum, base, &amp;si-&gt;dynamic,</span><br><span class="line">                                  &amp;dynamic_count, &amp;dynamic_flags);</span><br></pre></td></tr></table></figure><p>获取.dynamic section 在内存中的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(void) phdr_table_get_arm_exidx(phdr, phnum, base,</span><br><span class="line">                                   &amp;si-&gt;ARM_exidx, &amp;si-&gt;ARM_exidx_count);</span><br></pre></td></tr></table></figure><p>获取arm_exidx section 在内存中的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint32_t needed_count = 0;  </span><br><span class="line">   for (Elf32_Dyn* d = si-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;  </span><br><span class="line">       DEBUG(&quot;d = %p, d[0](tag) = 0x%08x d[1](val) = 0x%08x&quot;, d, d-&gt;d_tag, d-&gt;d_un.d_val);  </span><br><span class="line">       switch(d-&gt;d_tag)&#123;  </span><br><span class="line">       case DT_HASH:  </span><br><span class="line">           si-&gt;nbucket = ((unsigned *) (base + d-&gt;d_un.d_ptr))[0];  </span><br><span class="line">           si-&gt;nchain = ((unsigned *) (base + d-&gt;d_un.d_ptr))[1];  </span><br><span class="line">           ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">Elf32_Wordd_tag;/* entry tag value */</span><br><span class="line">union &#123;</span><br><span class="line">Elf32_Addrd_ptr;</span><br><span class="line">Elf32_Wordd_val;</span><br><span class="line">&#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>由.dynamic section 各自的tag确定该节用途<br>d_tag = DT_SYMTAB表示该项存储的是符号表的信息<br>d_un.d_ptr 表示符号表的虚拟地址的偏移<br>d_tag = DT_RELSZ d_un.d_val 表示重定位表rel的项数</p><p>解析的过程就是遍历数组中的每一项，根据d_tag的不同，获取到不同的信息.</p><p>不同tag类型的节使用d_ptr和d_val之一，表达意义也是不一致的。</p><p>参考文章：<a href="http://blog.csdn.net/feibabeibei_beibei/article/details/53004525" target="_blank" rel="noopener">http://blog.csdn.net/feibabeibei_beibei/article/details/53004525</a></p><p><a href="http://blog.csdn.net/feibabeibei_beibei/article/details/52986326" target="_blank" rel="noopener">http://blog.csdn.net/feibabeibei_beibei/article/details/52986326</a><br><img src="http://p1ju8xds4.bkt.clouddn.com/15209025437413.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;so保护总结&quot;&gt;&lt;a href=&quot;#so保护总结&quot; class=&quot;headerlink&quot; title=&quot;so保护总结&quot;&gt;&lt;/a&gt;so保护总结&lt;/h1&gt;&lt;h2 id=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ptrace解读</title>
    <link href="http://fancy-blogs.com/2018/03/06/ptrace/"/>
    <id>http://fancy-blogs.com/2018/03/06/ptrace/</id>
    <published>2018-03-06T13:28:00.353Z</published>
    <updated>2018-03-07T10:04:20.222Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h1><p><a href="https://mikecvet.wordpress.com/2010/08/14/ptrace-tutorial/" target="_blank" rel="noopener">原文</a></p><p>ptrace()函数在*nix系统下提供了独特的功能，允许一个进程对另一个进程查看数据，控制执行。包括读写寄存器，内存数据，和信号。进程可以通过fork()函数来和子进程，或attach一个正在执行的进程，来建立进程间的跟踪和被跟踪关系。这个函数最多的应用是在构建调试器和进程跟踪工具。</p><p>关于如何使用ptrace()没有很多在线文档，可能是因为它是一个POSIX里糟糕的系统函数。如果你以前未使用过它，那你将会有一段“难忘”的经历。文档还不算差，不过没有太多细节。</p><p>文档里的函数定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span> <span class="params">(<span class="keyword">enum</span> __ptrace_request request,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">pid_t</span> pid,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span> *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>_ptrace_request request:ptrace操作指令</li><li>pid_t pid:目标进程的pid</li><li>void* addr:部分ptrace操作需要读取或写入的内存地址</li><li>void* data:部分ptrace操作需要读取或写入的数据的地址 </li></ul><p>ptrace返回一个长整型数，表示ptrace操作执行结果，0表示执行成功，-1表示失败。对于读取数据的操作，表示从目标获取到的数据，-1表示错误。</p><p>正如你所见，这不是一个直白的或简单的系统调用。需要根据你具体的需要来使用，而且在很多特殊情况下要考虑输入和输出。首先我们来介绍一下对子任务的ptrace操作。</p><p>被跟踪的子进程有两种基本状态：停止态和运行态。ptrace操作不能在正在运行的子进程上执行，因此，需要满足一下条件：</p><ol><li>子进程主动停止</li><li>父进程手动停止子进程</li></ol><p>一般一个进程在接受到SIGSTOP信号后会停止（称作‘T’状态）。但是，当被跟踪时，除SIGKILL外，子进程收到任何信号都会停止，包括希望被忽略的信号。在接受到子进程通过wait()停止的通知后，父进程得以有时间来执行各种ptrace操作，或者通过ptrace告知子进程继续执行，无论是传递或忽略信号导致的停止。</p><p>如果父进程希望子进程停止（例如调试器里，在用户输入后，希望其停下），则可以通过常规方法发送一个SIGSTOP信号。除了SIGKILL信号外，任何未使用的信号都可以完成这项工作，但最好避免使用奇怪的信号导致含糊不清。在执行操作之前，要确保子进程被停止，这点很重要，否则ptrace会返回-1，ESRCH错误:”No such process”.</p><p>列举一下子进程的stopping，ptrace()-ing,running的状态：</p><ol><li>子进程处于running状态</li><li>子进程在接受信号（SIGSTIOP/SIGTRAP/other）后停止</li><li>父进程通过wait()接受子进程信号</li><li>父进程执行各种ptrace操作</li><li>父进程发送信号使子进程继续执行</li></ol><p>任何ptrace操作在步骤4之外都将失败（不按照以上流程）。确保在尝试使用ptrace之前已经通知子进程被停止。我上面提到的使用wait()来检索子进程的进程状态。这是正确的-就像传统的fork进程那样，跟踪进程使用wait()来接受信号后确定任务状态。事实上，使用waitpid()可能更简单，以便可以精确指定要等待的任务，而不会同时跟踪多个任务/线程。</p><p>现在我们来讨论一些更有趣的ptrace代码，我会为每一个操作提供一个简短的代码。任何NULL参数都是该ptrace操作未使用的。首先，是处理启动和终止跟踪子进程的代码。</p><p><strong>PTRACE_TRACEME</strong></p><p><code>long ret = ptrace (PTRACE_TRACEME, 0, NULL, NULL);</code></p><blockquote><p>This is the only ptrace operation which is used by the child. It’s purpose is to indicate that the child task is to be traced by a parent and to grant it necessary ptrace permissions.﻿﻿﻿ The 0 in the pid field refers to the child task’s parent. ﻿As soon as the child makes a call to any of the exec() functions, it receives a SIGTRAP, at which point it is stopped until the tracing parent allows it to continue. It is important for the parent to wait for this event to happen before performing any ptrace operations, including the configuration operations involved with PTRACE_SETOPTIONS.</p></blockquote><p>这是仅有的子进程使用的ptrace操作。它的目的是指明子进程由父进程跟踪并授予父进程必要的ptrace权限。pid参数是0，表示该进程的父进程。一旦子进程执行任何exec()函数，它会收到一个SIGTRAP信号，此时它会停止，直到跟踪的父进程允许继续。在执行任何ptrace操作之前（包括涉及PTRACE_SETOPTIONS的配置操作），父进程等待该事件是很重要的。</p><p><strong>PTRACE_ATTACH</strong></p><p><code>long ret = ptrace (PTRACE_ATTACH, target_pid, NULL, NULL);</code></p><blockquote><p>This is used by a task when it wishes to trace the execution of another task. For the most part, this will make the process represented by target_pid the literal child of tracing task. By and large, the situation created by using PTRACE_ATTACH is equivalent to what would’ve happened if the child had used PTRACE_TRACEME instead.</p><p>An important note is that this operation involves sending a SIGSTOP to the targeted process, and as usual, the parent needs to perform a wait() on target_pid after this call before continuing with any other work to ensure the child has properly stopped.</p></blockquote><p>它被使用在一个任务希望去跟踪另一个执行中的任务的情况下。大多数情况下，它会是target_pid指定的进程成为当前进程的子进程。总的来说，父进程使用PTRACE_ATTACH，就像子进程使用PTRACE_TRACEME一样。</p><p>需要注意的是，这个操作会向目标进程发送一个SIGSTOP信号，通常地，父进程需要在这个调用之后执行wait()，然后在执行其他操作，为了确保子进程已经停止。</p><p><strong>PTRACE_CONT</strong></p><p><code>long ret = ptrace (PTRACE_CONT, target_pid, NULL, 0);</code></p><blockquote><p>This will be the request you’ll use each time that wait() indicates that the child has stopped after receiving a signal to get it running again. If the data field is anything besides zero or SIGSTOP, ptrace will figure its a signal number you’d like delivered to the process. This can be used to actually deliver signals to the child which caused it to stop and notify the parent before acting on them. For common signals like SIGTRAP, you probably won’t want to do this. However, if you’d like to see if the child properly handles a SIGUSR1, this would be one way to go about it.</p></blockquote><p>这将是每次使用wait()指示被停止的子进程在接受到信号后再次运行的请求。如果数据字段是除0和SIGSTOP以外的任何内容，则ptrace会让父进程接受到你指定数值对应的信号。它也可以将让子进程停止的信号传递给父进程然后在处理它们前通知父进程。但对于一些普通的信号，像SIGTRAP，你可能并不想处理它。但是如果你想知道子进程是否正确处理了SIGUSR1，这也许是一个解决办法。</p><p><strong>PTRACE_DETACH</strong></p><p><code>long ret = ptrace (PTRACE_DETACH, child_pid, NULL, 0);</code></p><blockquote><p>Completes the tracing relationship between the parent and child, and if the parent attached to the child, “re-parents” the child back to its original parent process. Then it continues the child with a SIGCONT.</p><p>Now that we’ve covered the basics of how to get a tracing running, let’s get to some of the more interesting stuff.</p></blockquote><p>结束父子进程间的跟踪关系，如果父进程是附加到子进程上的，那么子进程会回属到原先父进程上。然后用SIGCONT信号使子进程继续执行。</p><p><strong>PTRACE_PEEKTEXT | PTRACE_PEEKDATA</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> word = ptrace (PTRACE_PEEKDATA, child_pid, addr, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (word == <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">if</span> (errno)</span><br><span class="line">    fail ();</span><br></pre></td></tr></table></figure><blockquote><p>On GNU/Linux systems, text and data address spaces are shared, so although these two codes would be used interchangeably here, on other UNIX platforms this would not be the case. The purpose of this request is to read words from the child task’s data address space and inspect the values. I mentioned above that peek operations require a little extra effort when detecting errors, which is briefly outlined in the code snippet above. Although ptrace will return -1 for error on a peek operation, -1 may also be the value stored at the provided memory address. Thus, errno must be checked in these situations to ensure an error actually happened.</p><p>The utility of this request is obvious – reading values from memory addresses in another task’s address space. If you consider GDB, printing variables or setting breakpoints would all need to use this request.</p></blockquote><p>在GNU/Linux系统上，文本和数据地址空间是共享的，所以虽然这两个代码在这里是可以互换使用的，但是在其他UNIX平台并不可以。该操作的目的是从子进程的数据地址空间获取数据和插入数据。之前提到过，peek操作在错误检查上需要额外注意，这在之前也简单介绍过。虽然ptrace执行失败时会返回-1，但也有可能这-1是从目标内存中获取来的值。因此，这种情况下就要检查是不是真的发生错误。</p><p>这个请求的目的很显然，是从目标任务的地址空间获取指定内存地址上的值。</p><p><strong>PTRACE_POKETEXT | PTRACE_POKEDATA</strong></p><p><code>long ret = ptrace (PTRACE_POKEDATA, child_pid, addr, new_val);</code></p><blockquote><p>Conversely to the peek functions, the poke functions do the opposite – write arbitrary values into the memory space of the child task. This is useful if you’d like to examine the change in behavior of the child task given different parameters, or for debugging tasks such as inserting breakpoints. This is turning into a pretty long post, but I can cover how to insert breakpoints into a child task’s address space on a later blog post.</p></blockquote><p>和peek操作相反，poke是将任意值写入子进程的内存空间。你可以通过给定不同参数来检查子进程行为中所做的改变，对于调试任务来说就比如插入断点的行为。</p><p><strong>PTRACE_SINGLESTEP</strong></p><p><code>long ret = ptrace (PTRACE_SINGLESTEP, child_pid, NULL, NULL);</code></p><blockquote><p>The single-step request is actually several operations batched into one. A PTRACE_SINGLESTEP request will execute a single instruction in the child task, then stop the child and notify the parent with a SIGTRAP. The operations involved include setting and removing a breakpoint so that only a single instruction is executed. This can be used to slowly step through the execution of a program, and assist with the usage of the other ptrace operations above. Think “stepi” from GDB.</p></blockquote><p>单步请求实际上是将多个操作合并为一个操作。PTRACE_SINGLESTEP请求将使子进程执行单个指令，然后停止子进程并通过SIGTRAP信号通知父进程。涉及到的操作包括设置和删除一个断点，以便只执行一条指令。这可以用来减缓程序运行，并协助上述的ptrace操作。</p><p><strong>PTRACE_GETREGS | PTRACE_SETREGS</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line">user_regs_struct regs;</span><br><span class="line"><span class="keyword">long</span> ret = ptrace (PTRACE_GETREGS, child_pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __x86_64__</span></span><br><span class="line">regs.rip = <span class="number">0xdeadbeef</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined __i386__</span></span><br><span class="line">regs.eip = <span class="number">0xdeadbeef</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ret = ptrace (PTRACE_SETREGS, child_pid, <span class="literal">NULL</span>, &amp;regs);</span><br></pre></td></tr></table></figure><blockquote><p>These ptrace requests involve reading and writing the general-purpose register values for the child process. The above example does three things:</p><ol><li>Reads the values of all general-purpose registers associated with child_pid</li><li>Sets the instruction pointer of the user_regs_struct structure to a not-so-random address</li><li>Writes the edited user_regs_struct back to the child, likely causing a crash upon re-execution due to the new instruction pointer setting</li></ol><p>Similar functionality is available for the designated floating-point registers as well through the use of PTRACE_GETFPREGS and PTRACE_SETFPREGS.</p></blockquote><p>这些ptrace请求涉及读取和写入子进程的通用寄存器。</p><p>上述例子：</p><ol><li>读取child_pid进程的所有通用寄存器。</li><li>将user_regs_struct结构体中的指令指针设置成指定值。</li><li>把user_regs_struct结构里写回目标进程，新指令指针的设置有可能会导致子进程重新运行时崩溃</li></ol><p>通过使用PTRACE_GETFPREGS和PTRACE_SETFPREGS，也可以操作浮点寄存器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;ptrace&quot;&gt;&lt;a href=&quot;#ptrace&quot; class=&quot;headerlink&quot; title=&quot;ptrace&quot;&gt;&lt;/a&gt;ptrace&lt;/h1&gt;&lt;p&gt;&lt;a h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>aapt部分源码分析</title>
    <link href="http://fancy-blogs.com/2018/03/01/aaptpartanalysis/"/>
    <id>http://fancy-blogs.com/2018/03/01/aaptpartanalysis/</id>
    <published>2018-03-01T15:57:44.778Z</published>
    <updated>2018-03-01T19:19:58.266Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="aapt部分源码分析"><a href="#aapt部分源码分析" class="headerlink" title="aapt部分源码分析"></a>aapt部分源码分析</h1><p>之前由于二进制修改AndroidManifest.xml失败，一开始只插入属性的字符和标签node发现失败，比较后发现要插入资源id，但是还是无法生效。</p><p>之前修改的方法都可以正常安装应用，正常启动，而且xml解析都没问题，插入的<code>debuggable=&quot;true&quot;</code>就是无法生效。了解到可以<code>aapt list</code>打印相应属性。</p><p><code>aapt list -v -a |grep debuggable</code></p><p>成功的xml：<br><code>A: android:debuggable(0x0101000f)=(type 0x12)0xffffffff</code></p><p>失败的xml：<br><code>A: android:debuggable=(type 0x12)0xffffffff</code></p><p>发现是缺少资源id，即使在<code>XmlResourceMapType</code>中插入资源id，还是无法识别。<br>所以尝试在aapt源码中看一下，是怎么查找到资源id的。</p><p>list打印AndroidManifest.xml部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> res = block-&gt;getAttributeNameResID(i);</span><br><span class="line">                ns16 = block-&gt;getAttributeNamespace(i, &amp;len);</span><br><span class="line">                String8 ns = build_namespace(namespaces, ns16);</span><br><span class="line">                String8 name(block-&gt;getAttributeName(i, &amp;len));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%sA: "</span>, prefix.<span class="built_in">string</span>());</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s%s(0x%08x)"</span>, ns.<span class="built_in">string</span>(), name.<span class="built_in">string</span>(), res);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s%s"</span>, ns.<span class="built_in">string</span>(), name.<span class="built_in">string</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                Res_value value;</span><br><span class="line">                block-&gt;getAttributeValue(i, &amp;value);</span><br><span class="line">                <span class="keyword">if</span> (value.dataType == Res_value::TYPE_NULL) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"=(null)"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.dataType == Res_value::TYPE_REFERENCE) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"=@0x%x"</span>, (<span class="keyword">int</span>)value.data);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.dataType == Res_value::TYPE_ATTRIBUTE) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"=?0x%x"</span>, (<span class="keyword">int</span>)value.data);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.dataType == Res_value::TYPE_STRING) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"=\"%s\""</span>,</span><br><span class="line">                            ResTable::normalizeForOutput(String8(block-&gt;getAttributeStringValue(i,</span><br><span class="line">                                        &amp;len)).<span class="built_in">string</span>()).<span class="built_in">string</span>());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"=(type 0x%x)0x%x"</span>, (<span class="keyword">int</span>)value.dataType, (<span class="keyword">int</span>)value.data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char16_t</span>* val = block-&gt;getAttributeStringValue(i, &amp;len);</span><br><span class="line">                <span class="keyword">if</span> (val != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" (Raw: \"%s\")"</span>, ResTable::normalizeForOutput(String8(val).<span class="built_in">string</span>()).</span><br><span class="line">                            <span class="built_in">string</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>这个部分关键：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%sA: "</span>, prefix.<span class="built_in">string</span>());</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s%s(0x%08x)"</span>, ns.<span class="built_in">string</span>(), name.<span class="built_in">string</span>(), res);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s%s"</span>, ns.<span class="built_in">string</span>(), name.<span class="built_in">string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Resid初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == RES_STRING_POOL_TYPE) &#123;</span><br><span class="line">    mStrings.setTo(chunk, size);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RES_XML_RESOURCE_MAP_TYPE) &#123;</span><br><span class="line">    mResIds = (<span class="keyword">const</span> <span class="keyword">uint32_t</span>*)</span><br><span class="line">    (((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)chunk)+dtohs(chunk-&gt;headerSize));</span><br><span class="line">    mNumResIds = (dtohl(chunk-&gt;size)-dtohs(chunk-&gt;headerSize))/ <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type &gt;= RES_XML_FIRST_CHUNK_TYPE</span><br><span class="line">       &amp;&amp; type &lt;= RES_XML_LAST_CHUNK_TYPE) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>mResIds指向<code>RES_XML_RESOURCE_MAP_TYPE</code>开头<br>mNumResIds为资源id数目</p><p>因为mResIds是顺序的，问题不在这儿，那么是由标签属性名来查找对应资源id的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> ResXMLParser::getElementNamespaceID() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventCode == START_TAG) &#123;</span><br><span class="line">        <span class="keyword">return</span> dtohl(((<span class="keyword">const</span> ResXMLTree_attrExt*)mCurExt)-&gt;ns.index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mEventCode == END_TAG) &#123;</span><br><span class="line">        <span class="keyword">return</span> dtohl(((<span class="keyword">const</span> ResXMLTree_endElementExt*)mCurExt)-&gt;ns.index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> ResXMLParser::getAttributeNameID(<span class="keyword">size_t</span> idx) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventCode == START_TAG) &#123;</span><br><span class="line">        <span class="keyword">const</span> ResXMLTree_attrExt* tag = (<span class="keyword">const</span> ResXMLTree_attrExt*)mCurExt;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; dtohs(tag-&gt;attributeCount)) &#123;</span><br><span class="line">            <span class="keyword">const</span> ResXMLTree_attribute* attr = (<span class="keyword">const</span> ResXMLTree_attribute*)</span><br><span class="line">                (((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)tag)</span><br><span class="line">                 + dtohs(tag-&gt;attributeStart)</span><br><span class="line">                 + (dtohs(tag-&gt;attributeSize)*idx));</span><br><span class="line">            <span class="keyword">return</span> dtohl(attr-&gt;name.index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由这两个函数可以看出，是根据index来确定标签属性名字符或命名空间名字符。</p><p>所以像<code>A: android:debuggable(0x0101000f)=(type 0x12)0xffffffff</code>格式的输出流程如下：</p><ul><li>顺序存储XmlResourceMapType中资源id</li><li>顺序遍历tag，获取tag属性的index（在string pool的索引）</li><li>如果在string pool中的index正好是Resid中的索引，即该tag属性的资源id为对应index的值。</li></ul><p>所以我们插入的属性字符在string pool尾部，而Resid中值太少，无法将0x0101000f的index和string pool 中的字符<code>debuggable</code>的index匹配，所以输出时并不输出资源值。</p><p>我们可以在XmlResourceMapType中填充一些资源值，把debuggable的资源值撑到和string pool中字符<code>debuggable</code>的index值一致。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15199311507372.jpg" alt="a-w500"></p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15199312134737.jpg" alt="a-w500"></p><p>我插入一些相同的资源值，撑到二者index一致，当然Resid header里的size要改，chunk header里size也要改。</p><p>修改完后，放入apk中，在输出就可以看到了<br><img src="http://p1ju8xds4.bkt.clouddn.com/15199314200100.jpg" alt=""></p><p>修改虽然成功，但是发现debuggable还是无法生效。</p><p>最后意外的发现，修改debuggable属性的位置就可以了</p><p>debuggable不生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: android:label(0x01010001)=@0x7f070000</span><br><span class="line">A: android:icon(0x01010002)=@0x7f020001</span><br><span class="line">A: android:allowBackup(0x01010280)=(type 0x12)0xffffffff</span><br><span class="line">A: android:debuggable(0x0101000f)=(type 0x12)0xffffffff</span><br></pre></td></tr></table></figure><p>debuggable生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: android:label(0x01010001)=@0x7f070000</span><br><span class="line">A: android:icon(0x01010002)=@0x7f020001</span><br><span class="line">A: android:debuggable(0x0101000f)=(type 0x12)0xffffffff</span><br><span class="line">A: android:allowBackup(0x01010280)=(type 0x12)0xffffffff</span><br></pre></td></tr></table></figure><p>不清楚为什么标签属性位置也会影响？太坑了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;aapt部分源码分析&quot;&gt;&lt;a href=&quot;#aapt部分源码分析&quot; class=&quot;headerlink&quot; title=&quot;aapt部分源码分析&quot;&gt;&lt;/a&gt;aapt部分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个native层反调试例子</title>
    <link href="http://fancy-blogs.com/2018/02/26/antidebug/"/>
    <id>http://fancy-blogs.com/2018/02/26/antidebug/</id>
    <published>2018-02-26T14:06:22.091Z</published>
    <updated>2018-03-02T14:36:15.977Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="一个native层反调试例子"><a href="#一个native层反调试例子" class="headerlink" title="一个native层反调试例子"></a>一个native层反调试例子</h1><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>apktools反编译，浏览smali代码，找原生函数。用ida打开so，找一下相关函数。</p><p>###调试准备</p><ul><li>将ida下gdbsrv目录下的android_server上传到手机上</li></ul><blockquote><p><code>adb push ./android_server /data/local/tmp</code></p></blockquote><ul><li>提升一下文件的权限后运行</li><li>转发到本地端口</li></ul><blockquote><p><code>adb forward tcp:23946 tcp:23946</code></p></blockquote><p>打开ida的debugger里的attach，选择remote ARMLinux/android debugger，填写本地地址及端口即可附加，选择对应进程包名。</p><h3 id="函数查找"><a href="#函数查找" class="headerlink" title="函数查找"></a>函数查找</h3><p>ida成功附加后，会自动断下来，打开Program Stegmentation窗口，找到目标so<img src="http://p1ju8xds4.bkt.clouddn.com/15196557781372.jpg" alt=""><br>带有X可执行权限且最低地址的段，为基地址，之前so静态分析时获得的函数地址为偏移，基地址+偏移=目标地址，在目标地址处下断，如果是未定义数据，按c将其转为code。</p><p>下完断点后，运行发现ida报错，调试停止，手机上程序也退出，重复也是如此。这里是因为程序检查到了被调试后自退出。</p><p>了解到，程序利用了<a href="http://blog.csdn.net/u012417380/article/details/60468697" target="_blank" rel="noopener">ptrace</a>。linux下一般调试器都会使用ptrace使进程被调试。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/15196564062163.jpg" alt=""><br>可看到，tracerPid值为3559，被pid为3559的进程调试，那么我们看看我们调试服务的pid：<br><img src="http://p1ju8xds4.bkt.clouddn.com/15196564861618.jpg" alt=""><br>果然，刚刚打开的ida的调试服务pid就是3559。<br>那么程序就是检查到了tracepid不为0而认为程序被调试。</p><p>在函数中无法下断，我们需要寻找另一个位置下断，如何寻找，我们先来看一下so文件加载过程。</p><h2 id="so文件加载"><a href="#so文件加载" class="headerlink" title="so文件加载"></a>so文件加载</h2><p><a href="http://www.blogfshare.com/linker-load-so.html" target="_blank" rel="noopener">http://www.blogfshare.com/linker-load-so.html</a><br>系统加载so，在完成装载、映射和重定向以后，就首先执行.init和.init_array段的代码，之后如果存在JNI_OnLoad就调用该函数.我们要对一个so进行分析，需要先看看有没有.init_array section和.init section，so加壳一般会在初始化函数进行脱壳操作。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="令其可调试"><a href="#令其可调试" class="headerlink" title="令其可调试"></a>令其可调试</h3><p>打开ddms，发现列表中没有进程，程序不可调试，首先要将其可调试，之前讲过方法。</p><ul><li>将AndroidManifest.xml提取出来</li><li>用AXMLEditor添加<code>debuggable=“true”</code>属性</li></ul><blockquote><p><code>java -jar AXMLEditor.jar -attr -i application package debuggable true old.xml out.xml</code></p></blockquote><ul><li>删除apk包中的AndroidManifest.xml</li></ul><blockquote><p><code>aapt r file.apk AndroidManifest.xml</code></p></blockquote><ul><li>将新的xml添加进去</li></ul><blockquote><p>‘aapt a file.apk AndroidManifest.xml’<br>注意添加时文件必须是当前目录，否则apk中会添加进去同样的目录</p></blockquote><ul><li>去签名，删除META-INF下除MANIFEST.MF之外的所有其他文件（签名时MANIFEST.MF会重写）</li></ul><blockquote><p>aapt r file.apk META-INF/CERT.SF<br>aapt r file.apk META-INF/CERT.RSA</p></blockquote><ul><li>自行签名即可</li></ul><p>过程中发现一些问题，xml确实存在<code>debuggable=“true”</code>属性，但是应用还是不能被系统识别为可调试。<br>比较回编译和直接插入方式得到的XML文件，原因是直接插入属性，没有在XmlResourcesMapType中插入对应属性id值。</p><p>用<a href="https://github.com/ele7enxxh/AmBinaryEditor" target="_blank" rel="noopener">AmBinaryEditor</a>插入属性id后还是有问题，只能通过反编译再回编译解决了。得去研究一下aapt怎么打包xml的。</p><p><a href="http://fancy-blogs.com/2018/03/01/aaptpartanalysis/">这里</a>解决不生效的问题，以后还是用hook插件吧。。。</p><h3 id="寻找反调试点"><a href="#寻找反调试点" class="headerlink" title="寻找反调试点"></a>寻找反调试点</h3><p>为了能让程序断在JNI_OnLoad上，我们不能直接运行app，再attach，时机太晚。<br>我们需要以debug的方式启动app来等待被调试。</p><p><code>adb shell am start -D -n com.yaotong.crackme/.MainActivity</code></p><p>以debug方式启动后，ida再attach上，之后还需要更改一下debug option：<br><img src="http://p1ju8xds4.bkt.clouddn.com/15199980730634.jpg" alt="a-w400"></p><p>这时候需要java调试器附加上去，程序才能运行起来，程序要求可调试，之前已经修改了，端口要打开devices monitor才会打开：</p><p><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></p><p>ida中F9运行后发现等待调试对话框消失了，而且断下来了，根据JNI_OnLoad的偏移寻找地址，下断，再运行后就断在JNI_OnLoad上了。<br><img src="http://p1ju8xds4.bkt.clouddn.com/15199854519199.jpg" alt="a-w600"></p><p>运行到这里，要跳转到R7的地址处<br><img src="http://p1ju8xds4.bkt.clouddn.com/15199856415959.jpg" alt="a-w600"></p><p>发现R7里是pthread_create的地址<br><img src="http://p1ju8xds4.bkt.clouddn.com/15199856177757.jpg" alt="a-w400"></p><p>果然运行之后就退出了，程序在这里开启一个线程来检测是否被调试。</p><p>简单方法就是把现线程创建函数nop掉。</p><p>发现是可以断在Java_com_yaotong_crackme_MainActivity_securityCheck函数里的：<br><img src="http://p1ju8xds4.bkt.clouddn.com/15200005028948.jpg" alt="a-w600"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于利用ptrace实现反调试，这里是利用了创建线程来检测进程的tracepid，另一种思路是父子进程相互监控来实现，可以看一下这篇<a href="http://blog.csdn.net/tianxuhong/article/details/78415864" target="_blank" rel="noopener">文章</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;一个native层反调试例子&quot;&gt;&lt;a href=&quot;#一个native层反调试例子&quot; class=&quot;headerlink&quot; title=&quot;一个native层反调试例子
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编译原理笔记一</title>
    <link href="http://fancy-blogs.com/2018/02/19/compiler1/"/>
    <id>http://fancy-blogs.com/2018/02/19/compiler1/</id>
    <published>2018-02-19T08:25:07.649Z</published>
    <updated>2018-02-21T10:58:36.301Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="编译原理笔记一"><a href="#编译原理笔记一" class="headerlink" title="编译原理笔记一"></a>编译原理笔记一</h1><p>想学习一下程序运行模拟引擎，开坑编译原理<br>结合<a href="https://www.bilibili.com/video/av17649289/?from=search&amp;seid=14395884438042552772#page=1" target="_blank" rel="noopener">哈工大编译原理课程</a>和《图解编译原理》来学习。<br>参考一位学长的<a href="https://o0xmuhe.github.io/2018/01/20/compiler学习/#2-项目结构" target="_blank" rel="noopener">总结</a></p><p>总览：<br><img src="http://p1ju8xds4.bkt.clouddn.com/compilerall.jpg" alt="compileral-c500"></p><p>讲解几个概念：</p><p>编译：将源语言翻译为目标语言的过程。</p><blockquote><p>即我们学习编译器如何自动地将源语言翻译为目标语言。</p></blockquote><p>编译器（以c语言为例）：将源程序翻译为汇编语言程序。</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/compilerpos.png" alt="compilerpos-w300"></p><p>中间语言：不受源语言限制，可抽象地表达语义的形式，能方便地转化为其它形式。<br><img src="http://p1ju8xds4.bkt.clouddn.com/ENtranslate.png" alt="ENtranslate-w400"></p><p>词法分析：将源语言中各个元素进行词性归类。</p><blockquote><p>词法分析器将源语言字符串中识别一个个符号（token），并按序保存。</p></blockquote><p><img src="http://p1ju8xds4.bkt.clouddn.com/ENLexical-1.png" alt="ENLexica-w436"></p><p>语法分析：根据源语言语法，将已归类的元素进行组合，组合成一个个语法基本结构。</p><blockquote><p>从词法分析识别出的符号流中识别出符合源语言语法的语句。</p></blockquote><p><img src="http://p1ju8xds4.bkt.clouddn.com/ENgrammar.png" alt="ENgramma-w435"></p><p>语义分析：将语法分析得到的语法结构进行语义检查和处理，产生相应的中间代码。<br><img src="http://p1ju8xds4.bkt.clouddn.com/ENSemantic.png" alt="ENSemanti-w457"></p><p>编译器结构：<br><img src="http://p1ju8xds4.bkt.clouddn.com/compilerstruc.png" alt="compilerstru-w425"></p><p>抽象语法树（<a href="http://blog.csdn.net/philosophyatmath/article/details/38170131" target="_blank" rel="noopener">AST</a>）：抽象语法树是源代码的抽象语法结构的树状表示。</p><blockquote><p>语法树是一个二维结构，中间代码是准一维结构，语法树到中间代码的转换过程，本质上是将二维结构转换为一维结构的过程。（中间代码是具有逻辑属性的，所以这个降维过程是将结构化的二维结构转化为线性逻辑的一维结构）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;编译原理笔记一&quot;&gt;&lt;a href=&quot;#编译原理笔记一&quot; class=&quot;headerlink&quot; title=&quot;编译原理笔记一&quot;&gt;&lt;/a&gt;编译原理笔记一&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python实现CSDN博客标题收集</title>
    <link href="http://fancy-blogs.com/2018/02/13/pythonforblogtitle/"/>
    <id>http://fancy-blogs.com/2018/02/13/pythonforblogtitle/</id>
    <published>2018-02-13T14:24:00.673Z</published>
    <updated>2018-02-13T14:27:09.325Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="python实现CSDN博客标题收集"><a href="#python实现CSDN博客标题收集" class="headerlink" title="python实现CSDN博客标题收集"></a>python实现CSDN博客标题收集</h1><p>使用BeautifulSoup对网页解析，再根据布局使用Tag层层搜索，找到我们所需要的元素，代码很简单。</p><p>BeautifulSoup是Python的一个库，最主要的功能就是从网页爬取我们需要的数据。BeautifulSoup将html解析为对象进行处理，全部页面转变为字典或者数组，相对于正则表达式的方式，可以大大简化处理过程。</p><p>例子中是把老罗的博客文章标题收集，由于tag嵌套导致循环重复，去重会导致效率偏低。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">url_list = []</span><br><span class="line">title_list=[]</span><br><span class="line">blog_urls = []</span><br><span class="line">collected=<span class="number">0</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        url_list.append(<span class="string">"http://blog.csdn.net/Luoshengyang/article/list/"</span>+str(i))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collect</span><span class="params">()</span>:</span> </span><br><span class="line">    <span class="keyword">global</span> collected</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">        html = requests.get(url, headers=headers)</span><br><span class="line">        html.encoding = html.apparent_encoding</span><br><span class="line">        soup = BeautifulSoup(html.text, <span class="string">'html.parser'</span>)</span><br><span class="line">        <span class="keyword">for</span> tagmain <span class="keyword">in</span> soup.find_all(<span class="string">'main'</span>):</span><br><span class="line">            <span class="keyword">for</span> ul <span class="keyword">in</span> tagmain.find_all(<span class="string">'ul'</span>):</span><br><span class="line">                <span class="keyword">for</span> li <span class="keyword">in</span> ul.find_all(<span class="string">'li'</span>):        </span><br><span class="line">                    <span class="keyword">for</span> taga <span class="keyword">in</span> li.find_all(<span class="string">'a'</span>):</span><br><span class="line">                        <span class="keyword">for</span>  h3 <span class="keyword">in</span> taga.find_all(<span class="string">'h3'</span>):</span><br><span class="line">                            <span class="keyword">if</span> (taga[<span class="string">'href'</span>][<span class="number">0</span>:<span class="number">4</span>]==<span class="string">"http"</span>):</span><br><span class="line">                                <span class="keyword">if</span> taga[<span class="string">'href'</span>] <span class="keyword">in</span> blog_urls:</span><br><span class="line">                                    <span class="keyword">break</span></span><br><span class="line">                                blog_urls.append(taga[<span class="string">'href'</span>])</span><br><span class="line">                                title_list.append(h3.text.replace(<span class="string">' '</span>,<span class="string">""</span>).replace(<span class="string">'\n'</span>,<span class="string">""</span>).replace(<span class="string">'\t'</span>,<span class="string">""</span>)) </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_url()</span><br><span class="line">collect()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(title_list)):</span><br><span class="line">    print(title_list[i],blog_urls[i])</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/kikaylee/article/details/56841789" target="_blank" rel="noopener">http://blog.csdn.net/kikaylee/article/details/56841789</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;python实现CSDN博客标题收集&quot;&gt;&lt;a href=&quot;#python实现CSDN博客标题收集&quot; class=&quot;headerlink&quot; title=&quot;python
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>应用开发（二）</title>
    <link href="http://fancy-blogs.com/2018/02/11/app2/"/>
    <id>http://fancy-blogs.com/2018/02/11/app2/</id>
    <published>2018-02-11T06:08:52.869Z</published>
    <updated>2018-02-11T11:40:49.762Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="应用开发（二）"><a href="#应用开发（二）" class="headerlink" title="应用开发（二）"></a>应用开发（二）</h1><h2 id="主界面设计"><a href="#主界面设计" class="headerlink" title="主界面设计"></a>主界面设计</h2><h3 id="顶部按钮打开菜单"><a href="#顶部按钮打开菜单" class="headerlink" title="顶部按钮打开菜单"></a>顶部按钮打开菜单</h3><p>原先考虑用PopWindow实现，看到一个酷炫的设计，利用Toolbar+Fragment实现。<br><a href="https://www.jianshu.com/p/799dbb86f908" target="_blank" rel="noopener">PopWindow</a><br><a href="https://github.com/Yalantis/Context-Menu.Android" target="_blank" rel="noopener">Context-menu</a></p><p><a href="https://www.imooc.com/article/2844" target="_blank" rel="noopener">ActionBar详解和toolbar详解</a></p><p>自定义Toolbar：<br>新建Toolbar布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;44.1dp&quot;</span><br><span class="line">    app:navigationIcon=&quot;@drawable/ic_action_back1&quot;</span><br><span class="line">    android:id=&quot;@+id/headbar&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 自定义布局 --&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/text_view_toolbar_title&quot;</span><br><span class="line">        android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:textColor=&quot;#ff888888&quot;</span><br><span class="line">        android:textSize=&quot;22sp&quot;</span><br><span class="line">        android:gravity=&quot;center&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/android.support.v7.widget.Toolbar&gt;</span><br></pre></td></tr></table></figure><p>自定义返回图标<code>app:navigationIcon=&quot;@drawable/ic_action_back1&quot;</code></p><p>主活动布局include Toolbar布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;com.fancy.infopush.HomeActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include layout=&quot;@layout/headtoolbar&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>主活动中初始化Toolbar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void initToolbar()&#123;</span><br><span class="line">      Toolbar homehead= (Toolbar) findViewById(R.id.headbar);</span><br><span class="line">      TextView mToolBarTextView = (TextView) findViewById(R.id.text_view_toolbar_title);</span><br><span class="line">      setSupportActionBar(homehead);</span><br><span class="line">      if(getSupportActionBar()!=null)&#123;</span><br><span class="line">          getSupportActionBar().setHomeButtonEnabled(true);</span><br><span class="line">          getSupportActionBar().setDisplayHomeAsUpEnabled(true);</span><br><span class="line">          getSupportActionBar().setDisplayShowTitleEnabled(false);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      homehead.setNavigationOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onClick(View v) &#123;</span><br><span class="line">              onBackPressed();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      mToolBarTextView.setText(&quot;Context&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Actionbar会带有一个菜单按钮，我们在menu中定制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/context_menu&quot;</span><br><span class="line">        android:title=&quot;context_menu&quot;</span><br><span class="line">        android:icon=&quot;@drawable/add&quot;</span><br><span class="line">        android:orderInCategory=&quot;100&quot;</span><br><span class="line">        app:showAsAction=&quot;always&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><p>可自定义图标<code>android:icon=&quot;@drawable/add&quot;</code></p><p>Toolbar的外观已修改完了，这里需要注意的是由于默认的样式中自带有Actionbar，所以我们需要修改一下样式，继承不带Actionbar的theme</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class="line">        &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">        &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:colorBackground&quot;&gt;@android:color/darker_gray&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/background_light&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在菜单响应中，为了显示酷炫的效果<code>mMenuDialogFragment.show(fragmentManager, ContextMenuDialogFragment.TAG);</code>我们需要初始化mMenuDialogFragment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void initMenuFragment() &#123;</span><br><span class="line">        MenuParams menuParams = new MenuParams();</span><br><span class="line">        menuParams.setActionBarSize((int) getResources().getDimension(R.dimen.tool_bar_height));</span><br><span class="line">        menuParams.setMenuObjects(getMenuObjects());</span><br><span class="line">        menuParams.setClosableOutside(false);</span><br><span class="line">        mMenuDialogFragment = ContextMenuDialogFragment.newInstance(menuParams);</span><br><span class="line">        mMenuDialogFragment.setItemClickListener(this);</span><br><span class="line">        mMenuDialogFragment.setItemLongClickListener(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>menuParams.setMenuObjects(getMenuObjects());</code><br>设置菜单内容，我们将MenuObject设置图标后放入List\<menuobject\>即可。</menuobject\></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> private List&lt;MenuObject&gt; getMenuObjects() &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;MenuObject&gt; menuObjects = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        MenuObject close = new MenuObject();</span><br><span class="line">        close.setResource(R.drawable.ic_action_close);</span><br><span class="line"></span><br><span class="line">        MenuObject addFav = new MenuObject(&quot;Add to favorites&quot;);</span><br><span class="line">        addFav.setResource(R.drawable.ic_action_like);</span><br><span class="line"></span><br><span class="line">        MenuObject block = new MenuObject(&quot;Block user&quot;);</span><br><span class="line">        block.setResource(R.drawable.ic_action_up);</span><br><span class="line"></span><br><span class="line">        menuObjects.add(close);</span><br><span class="line">        menuObjects.add(addFav);</span><br><span class="line">        menuObjects.add(block);</span><br><span class="line">        return menuObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src="http://p1ju8xds4.bkt.clouddn.com/toolbar.png" alt="toolbar-c500"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;应用开发（二）&quot;&gt;&lt;a href=&quot;#应用开发（二）&quot; class=&quot;headerlink&quot; title=&quot;应用开发（二）&quot;&gt;&lt;/a&gt;应用开发（二）&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>应用开发（一）</title>
    <link href="http://fancy-blogs.com/2018/02/07/app1/"/>
    <id>http://fancy-blogs.com/2018/02/07/app1/</id>
    <published>2018-02-07T12:00:49.187Z</published>
    <updated>2018-02-10T11:39:10.333Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="应用开发（一）"><a href="#应用开发（一）" class="headerlink" title="应用开发（一）"></a>应用开发（一）</h1><h2 id="欢迎界面"><a href="#欢迎界面" class="headerlink" title="欢迎界面"></a>欢迎界面</h2><p>设计为全屏显示一张图片，显示3秒后跳转到主界面。</p><p>想法为通过设置欢迎界面活动布局文件，添加背景来显示。</p><p>遇到问题，由于图片太大导致启动崩溃，报错显示<br><code>报错Binary XML file line #0 : Error inflating class</code><br>一直找不到问题所在。之前遇到过资源加载太大时会崩溃，把图片截取再压缩，大小在100kb左右，不再报错。</p><p>另外，layout里设置背景，再在代码里设置全屏会有延时，一打开不全屏，重新创建进程属于冷启动，可以用theme可以解决。WindowManager会先加载app主题样式中的windowBackground做为app的预览元素，然后再真正去加载activity的layout布局，所以将背景设置在theme里比设置在layout更快加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;StartTheme&quot; parent=&quot;AppTheme&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowBackground&quot;&gt; @drawable/welc&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>定时器设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = new Timer();</span><br><span class="line">       TimerTask timerTask = new TimerTask() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               Intent intent = new Intent(WelcomeActivity.this, HomeActivity.class);</span><br><span class="line">               startActivity(intent);</span><br><span class="line">               finish();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       timer.schedule(timerTask, 3000);</span><br></pre></td></tr></table></figure><p>效果：<br><img src="http://p1ju8xds4.bkt.clouddn.com/app_welcome.png" alt="welc"></p><blockquote><p>1、冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。</p><p>特点：冷启动因为系统会重新创建一个新的进程分配给它，所以会先创建和初始化application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。</p><p>2、热启动：当启动应用时，后台已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。</p><p>特点：热启动因为会从已有的进程中来启动，所以热启动就不会走application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化application，因为一个应用从新进程的创建到进程的销毁，application只会初始化一次。</p></blockquote><p><a href="http://www.jb51.net/article/122034.htm" target="_blank" rel="noopener">http://www.jb51.net/article/122034.htm</a><br><a href="https://www.jianshu.com/p/33a798ac3298" target="_blank" rel="noopener">https://www.jianshu.com/p/33a798ac3298</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;应用开发（一）&quot;&gt;&lt;a href=&quot;#应用开发（一）&quot; class=&quot;headerlink&quot; title=&quot;应用开发（一）&quot;&gt;&lt;/a&gt;应用开发（一）&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
    
  </entry>
  
</feed>
